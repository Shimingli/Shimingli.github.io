<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>剑指几道算法题的思考</title>
      <link href="/2018/09/03/%E5%89%91%E6%8C%87offer%E4%B8%AD%E5%87%A0%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2018/09/03/%E5%89%91%E6%8C%87offer%E4%B8%AD%E5%87%A0%E9%81%93%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<h2 id="1、在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"><a href="#1、在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。" class="headerlink" title="1、在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。"></a>1、在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</h2><a id="more"></a><ul><li><p>假如二维数组为 <code>{ {1, 2, 8, 9}, {2, 4, 9, 12}, {4, 7, 10, 13}, {6, 8, 11, 15} };</code>同时查找的值为<code>15</code>。</p><!--  more  --><ul><li>常规的思路为我们取到每个二维数组的值，然后遍历每个值，判断是否相等！同时我们知道会循环<code>16</code>次。代码如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">        private boolean lookUpInTwoDimensionalArrays(int[][] a, int num) &#123;</span><br><span class="line">        // 至少保证 长度至少为1，且还有元素，</span><br><span class="line">        if (a == null || a.length &lt; 1 || a[0].length &lt; 1) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        int b = 0;</span><br><span class="line">        for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; a[i].length; j++) &#123;</span><br><span class="line">                b++;</span><br><span class="line">                if (num == a[i][j]) &#123;</span><br><span class="line">                    // 一共循环多少次：12</span><br><span class="line">                    System.out.println(TAG + &quot;一共循环多少次：&quot; + b);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">       &#125;</span><br><span class="line">     *  解题的思路如下        </span><br><span class="line">        *  1、选取二维数组的中的第一个元素，比较最右边的值，如果相等，就查找结束</span><br><span class="line">        *  2、选取二维数组的中的第一个元素，比较最右边的值，如果大于，查找的就是这个元素，同时角标减去1，然后继续查找</span><br><span class="line">        *  3、选取二维数组的中的第一个元素，比较最右边的值，如果大于，查找的不是这个元素，就去查找下一个数组，然后继续查找![二维数组的查找过程.png](https://upload-images.jianshu.io/upload_images/5363507-a954c84b1c8c5551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">* 最终的代码如下</span><br></pre></td></tr></table></figure></li></ul><p>/**</p><ul><li>数组是递增的 ，从左到右  从上到下,那么数组一定是个正方形的样子<br>*</li><li>@param arr 原始的数组</li><li>@param num 需要查找的数字</li><li>@return 是否找到了<br>*/<br>private boolean newLookUpInTwoDimensionalArrays(int[][] arr, int num) {<br> if (arr == null || arr.length &lt; 1 || arr[0].length &lt; 1) {<pre><code>return false;</code></pre> }<br> int rowTotal = arr.length;// 数组的行数<br> int colTolal = arr[0].length;// 数组的列数<br> //开始的角标<br> int row = 0;<br> int col = colTolal - 1;<br> int i = 0;<br> while (row &gt;= 0 &amp;&amp; row &lt; rowTotal &amp;&amp; col &gt;= 0 &amp;&amp; col &lt; colTolal) {<pre><code>// 是二维数组的 arr[0][arr[0].length-1] 的值，就是最右边的值i++;if (arr[row][col] == num) {    System.out.println(TAG + &quot;newLookUpInTwoDimensionalArrays 执行了多少次&quot; + i);    return true;} else if (arr[row][col] &gt; num) {// 如果找到的值 比目标的值大的话，就把查找的列数减去1    col--;//列数减去1 ，代表向左移动} else {// 比目标的num大的，就把行数加上1，然后往下移动    row++;}</code></pre> }<br> return false;<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 如果查找的值为`15`，那么旧的代码会执行`15`次，新的代码只会执行`3`次。</span><br><span class="line"></span><br><span class="line">## 2、请实现一个函数，把字符串中的每个空格替换成`%20`，例如“We are happy.”，则输出`We%20are%20happy.`.</span><br><span class="line">* 第一种方法:先判断字符串中空格的数量。根据数量判断该字符串有没有足够的空间替换成`%20`。如果有足够空间，计算出需要的空间。根据最终需要的总空间，维护一个指针在最后。从后到前，遇到非空的就把该值挪到指针指向的位置，然后指针向前一位，遇到“ ”，则指针前移，依次替换为`02%`。</span><br></pre></td></tr></table></figure></li></ul><p>public char[]  replaceBlank(char[] string, int usedLength) {</p><pre><code>// 判断输入是否合法System.out.println(TAG+&quot;string.length=&quot;+string.length);System.out.println(TAG+&quot;usedLength=&quot;+usedLength);if (string == null || string.length &lt; usedLength) {    return null;}// 统计字符数组中的空白字符数int whiteCount = 0;for (int i = 0; i &lt; usedLength; i++) {    if (string[i] == &apos; &apos;) {        whiteCount++;    }}// 如果没有空白字符就不用处理if (whiteCount == 0) {    return string;}// 计算转换后的字符长度是多少int targetLength = whiteCount * 2 + usedLength; //新的保存的字符串的数组char[] newChars = new char[targetLength];int tmp = targetLength; // 保存长度结果用于返回</code></pre><p>//        if (targetLength &gt; string.length) { // 如果转换后的长度大于数组的最大长度，直接返回失败<br>//            return -1;<br>//        }</p><pre><code>// todo  必须先做 这个，注意体会  --i  和 i-- 的区别usedLength--; // 从后向前，第一个开始处理的字符targetLength--; // 处理后的字符放置的位置// 字符中有空白字符，一直处理到所有的空白字符处理完while (usedLength &gt;= 0 &amp;&amp; usedLength &lt; targetLength) {    // 如是当前字符是空白字符，进行&quot;%20&quot;替换    if (string[usedLength--] == &apos; &apos;) {        newChars[targetLength--] = &apos;0&apos;;        newChars[targetLength--] = &apos;2&apos;;        newChars[targetLength--] = &apos;%&apos;;    } else { // 否则移动字符        newChars[targetLength--] = string[usedLength];    }    usedLength--;}return newChars;</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第二种方法，非常的消耗时间和内存。</span><br></pre></td></tr></table></figure><p>private String idoWorkReplace(String str, String tagStr) {</p><pre><code>if (str == null || str.length() &lt; 1) {    return &quot;&quot;;}String[] split = str.split(&quot; &quot;);StringBuffer stringBuffer = new StringBuffer();for (String s : split) {    stringBuffer.append(s);    stringBuffer.append(tagStr);}CharSequence charSequence = stringBuffer.subSequence(0, stringBuffer.length() - tagStr.length());return charSequence.toString();</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第三种方法，调用`replace`方法，如果仅仅来讲替换字符串的话，是最好的方法，关键的方法是`indexOf(this, targetStr, lastMatch)`.</span><br></pre></td></tr></table></figure><p>StringBuffer sb = new StringBuffer();</p><pre><code>sb.append(str);// todo  最节能的方法sb.toString().replace(&quot; &quot;, &quot;%20&quot;);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第四种方法和第一种方法异曲同工:先统计空白的数量，然后计算出有多少空白的长度，然后设置新的长度`StringBuffer`，通过插入最大角标的地方，不断的插入，就可以了</span><br></pre></td></tr></table></figure><p>private String replaceSpaces(String string) {</p><pre><code>//判断是否 输入合法if (string == null || string.length() &lt; 1) {    return &quot;&quot;;}char[] chars = string.toCharArray();// 统计有多少的空白的数组int whiteCount = 0;for (int i = 0; i &lt; chars.length; i++) {    if (chars[i] == &apos; &apos;) {        whiteCount++;    }}if (whiteCount == 0) {    return string;}//最原本的长度int indexold = string.length() - 1;// 转换完成后的长度int newlength = string.length() + whiteCount * 2;//新的长度int indexnew = newlength - 1;StringBuffer stringBuffer = new StringBuffer(string);//设置新的buffer的长度stringBuffer.setLength(newlength);for (; indexold &gt;= 0 &amp;&amp; indexold &lt; newlength; indexold--) {    // 原来的 字符串的最后一位为空格    if (string.charAt(indexold) == &apos; &apos;) {        stringBuffer.setCharAt(indexnew--, &apos;0&apos;);        stringBuffer.setCharAt(indexnew--, &apos;2&apos;);        stringBuffer.setCharAt(indexnew--, &apos;%&apos;);    } else {//不为空的话，就直接放进去 就行了        stringBuffer.setCharAt(indexnew--, string.charAt(indexold));    }}return stringBuffer.toString();</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 3、输入个链表的头结点，从尾到头反过来打印出每个结点的值。</span><br><span class="line">* 数据结构</span><br></pre></td></tr></table></figure><p>public static class ListNode {</p><pre><code>int val;ListNode next;public ListNode(int  v){    this.val=v;}</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 初始化</span><br></pre></td></tr></table></figure><p>   ListNode listNode = new ListNode(10);<br>   ListNode listNode1 = new ListNode(11);<br>   ListNode listNode2 = new ListNode(12);<br>   ListNode listNode3 = new ListNode(13);</p><pre><code>ListNode listNode4 = new ListNode(14);  listNode.next=listNode1;  listNode1.next=listNode2;  listNode2.next=listNode3;  listNode3.next=listNode4;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第一种方法的详情,非常像二叉树的遍历，也是最简单的方法。</span><br></pre></td></tr></table></figure><p> public static ArrayList<integer> printListFromTailToHead(ListNode listNode) {</integer></p><pre><code>arrayList.clear();if (listNode != null) {    printListFromTailToHead(listNode.next);//指向下一个节点    arrayList.add(listNode.val);//将当前节点的值存到列表中}return arrayList;</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 第二种方法,利用`Stack`的特点，`Stack`类：继承自`Vector`，实现一个后进先出的栈,不太明白的同学可以看这里[常用集合的原理分析](https://www.jianshu.com/p/a5f638bafd3b);</span><br></pre></td></tr></table></figure></li></ul><p>private static void doWhat(ListNode listNode) {<br>        Stack<listnode> stack = new Stack&lt;&gt;();<br>        while (listNode!=null){<br>            stack.push(listNode);<br>            listNode=listNode.next;<br>        }<br>        System.out.println(“ stack “+stack.size());<br>//        for (int i=0;i&lt;stack.size();i++){<br>//            System.out.println(“每个该打印的元素 ::”+stack.get(i).val);<br>//        }<br>        ListNode tmp;<br>        while (!stack.empty()){<br>            // 移除堆栈顶部的对象，并作为此函数的值返回该对象。<br>            tmp = stack.pop();<br>            System.out.println(“tmp=”+tmp.val);<br>          //  System.out.println(“每个该打印的元素 ：”+tmp.val);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 4、输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。这个题的官方的答案，我本人持有严重的怀疑，也有可能是我根本没有找到正确的答案！</span><br><span class="line"></span><br><span class="line">* 认识下什么二叉树：二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”`（left subtree）`和“右子树”`（right subtree）`。二叉树常被用于实现二叉查找树和二叉堆。树的数据结构能够同时具备数组查找快的优点以及链表插入和删除快的优点</span><br><span class="line"></span><br><span class="line">* 代码结构</span><br></pre></td></tr></table></figure></listnode></p><p>public interface Tree {<br>    //查找节点<br>     Node find(int key);<br>    //插入新节点<br>     boolean insert(int data);<br>    //中序遍历<br>     void infixOrder(Node current);<br>    //前序遍历<br>     void preOrder(Node current);<br>    //后序遍历<br>     void postOrder(Node current);<br>    //查找最大值<br>     Node findMax();<br>    //查找最小值<br>     Node findMin();<br>    //删除节点<br>     boolean delete(int key);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* Node</span><br></pre></td></tr></table></figure></p><p>public class Node {<br>    int data;   //节点数据<br>    Node leftChild; //左子节点的引用<br>    Node rightChild; //右子节点的引用</p><pre><code>public Node(int data){    this.data = data;}//打印节点内容public void display(){    System.out.println(data);}@Overridepublic String toString() {    return super.toString();}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 插入数据的过程</span><br></pre></td></tr></table></figure></p><pre><code>BinaryTree bt = new BinaryTree(); // 第一个插入的结点是 根节点 bt.insert(50); bt.insert(20); bt.insert(80); bt.insert(10); bt.insert(30); bt.insert(60); bt.insert(90); bt.insert(25); bt.insert(85); bt.insert(100);</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* insert 代码</span><br></pre></td></tr></table></figure><p>//插入节点<br>    public boolean insert(int data) {<br>        Node newNode = new Node(data);<br>        if (root == null) {//当前树为空树，没有任何节点<br>            root = newNode;<br>            return true;<br>        } else {<br>            Node current = root;<br>            Node parentNode = null;<br>            while (current != null) {<br>                parentNode = current;<br>                if (current.data &gt; newNode.data) {//当前值比插入值大，搜索左子节点<br>                    current = current.leftChild;<br>                    if (current == null) {//左子节点为空，直接将新值插入到该节点<br>                        parentNode.leftChild = newNode;<br>                        return true;<br>                    }<br>                } else {<br>                    current = current.rightChild;<br>                    if (current == null) {//右子节点为空，直接将新值插入到该节点<br>                        parentNode.rightChild = newNode;<br>                        return true;<br>                    }<br>                }<br>            }<br>        }<br>        return false;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![二叉树插入数据的过程.png](https://upload-images.jianshu.io/upload_images/5363507-0b41b46b1356dcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![二叉树最终的结构.png](https://upload-images.jianshu.io/upload_images/5363507-1bce3daeb9b826cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">* 最终的图解如下</span><br><span class="line"></span><br><span class="line">![二叉树 insert 图解.jpg](https://upload-images.jianshu.io/upload_images/5363507-69f85ae2eea40afe.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">* 二叉树的前序遍历：根节点&gt;&gt;左子树&gt;&gt;右子树</span><br></pre></td></tr></table></figure></p><p>  public void preOrder(Node current) {<br>        if (current != null) {<br>            System.out.print(current.data + “ “);<br>            infixOrder(current.leftChild);<br>            infixOrder(current.rightChild);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 1、根节点50，查找左节点，找到20，然后找到10，输出10，然后找到25 ，然后30 。到这里输出的结果是 50 10 20 25 30</span><br><span class="line">* 2、查找根节点的50的右节点，然后找出80，找出80的左节点60.接着80，查找80的右节点95，输出85 然后 90 ，最后输出100</span><br><span class="line">* 3、最终的输出的结果50 10 20 25 30 60 80 85 90 100</span><br><span class="line"></span><br><span class="line">![前序遍历.png](https://upload-images.jianshu.io/upload_images/5363507-1e5c416724d9f985.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 二叉树中序遍历：首先遍历左子树，然后访问根结点，最后遍历右子树。 左子树 ---》根节点----》 右子树</span><br></pre></td></tr></table></figure></p><p>  public void infixOrder(Node current) {<br>        if (current != null) {<br>            infixOrder(current.leftChild);<br>            System.out.print(current.data + “ “);<br>            infixOrder(current.rightChild);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> * 1、传入根节点 值为50 ，查找50的左节点为20不为null，再次查找20的左节点，为10，也不为null，然后在查找10的左节点，为null ，输出10，第一个节点输出完成为 10</span><br><span class="line"> * 2、接下来，查找的10的右节点，为null，不进入输出语句</span><br><span class="line"> * 3、这下输出语句20，查找20右节点，查找到值为30，第一步查找的值为左节点，查找到的值为25，查找右节点为null</span><br><span class="line"> * 4、到这里输出的结果为  10  20 25 30</span><br><span class="line"> * 5、这样子50左节点就全部查找完了</span><br><span class="line"> * 6、接下来查找50的右节点，查找右节点80，然后查找80的左节点，查找到的值为60,60没有右节点，继续查找80的右节点，到这里 输出的结果10 20 25 30 50 60 80</span><br><span class="line"> * 7、查找80右节点，查到到值为90，接着查找90的左节点，查到到的值85，接着85的左右节点为null，返回直接查找90的右节点，查找到了100，</span><br><span class="line"> * 8、最终输出的结果，10 20 25 30 50 60 80 85 90 100</span><br><span class="line"></span><br><span class="line">![二叉树的中序遍历.png](https://upload-images.jianshu.io/upload_images/5363507-0e19a066dddcb01b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">* 后序遍历:在二叉树中，先左后右再根，即首先遍历左子树，然后遍历右子树，最后访问根结点。</span><br><span class="line">    * 1、根节点50，查找左节点20，在继续查找20的左节点10,10没有左右节点，打印10,然后查找到20的右节点30,30继续查找到25，第一次输出为 10 20 25 30</span><br><span class="line">    *  2、最终输出10 20 25 30 60 80 85 90 100 50</span><br><span class="line"></span><br><span class="line">![二叉树的后序遍历.png](https://upload-images.jianshu.io/upload_images/5363507-c7600a265ea5bcaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">* 查找最大值或者是最小值</span><br></pre></td></tr></table></figure></p><p> //找到最大值<br>    public Node findMax() {<br>        Node current = root;<br>        Node maxNode = current;<br>        while (current != null) {<br>            maxNode = current;<br>            current = current.rightChild;<br>        }<br>        return maxNode;<br>    }</p><pre><code>//找到最小值public Node findMin() {    Node current = root;    Node minNode = current;    while (current != null) {        minNode = current;        current = current.leftChild;    }    return minNode;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 例如：前序遍历序列`｛50 10 20 25 30 60 80 85 90 100｝`和中序遍历序列`｛10 20 25 30 50 60 80 85 90 100&#125;`， 重建二叉树并输出它的头结点。</span><br><span class="line">* 原始节点的遍历结果,可以很清楚的看到，有多少左右节点，那个节点是那个的节点等等的信息。</span><br></pre></td></tr></table></figure><p>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node50  是那边啊 根<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node20  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node10  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node30  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node25  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node80  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node60  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node90  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node85  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node100  是那边啊 右<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 解决方法一：</span><br></pre></td></tr></table></figure></p><p> public static Node reConstructBinaryTree(int[] pre, int[] in) {<br>        if (pre == null || in == null || pre.length != in.length)//如果先序或者中序数组有一个为空的话，就无法建树，返回为空<br>            return null;<br>        else {<br>            return reBulidTree(pre, 0, pre.length - 1, in, 0, in.length - 1);<br>        }<br>    }</p><pre><code>/** * @param pre * @param startPre * @param endPre * @param in * @param startIn * @param endIn * @return */private static Node reBulidTree(int[] pre, int startPre, int endPre, int[] in, int startIn, int endIn) {    if (startPre &gt; endPre || startIn &gt; endIn)//先对传的参数进行检查判断        return null;    int root = pre[startPre];//数组的开始位置的元素是跟元素    int locateRoot = locate(root, in, startIn, endIn);//得到根节点在中序数组中的位置 左子树的中序和右子树的中序以根节点位置为界    if (locateRoot == -1) //在中序数组中没有找到跟节点，则返回空        return null;    Node treeRoot = new Node(root);//创建树根节点    treeRoot.leftChild = reBulidTree(pre, startPre + 1, startPre + locateRoot - startIn, in, startIn, locateRoot - 1);//递归构建左子树    treeRoot.rightChild = reBulidTree(pre, startPre + locateRoot - startIn + 1, endPre, in, locateRoot + 1, endIn);//递归构建右子树    return treeRoot;}//找到根节点在中序数组中的位置，根节点之前的是左子树的中序数组，根节点之后的是右子树的中序数组private static int locate(int root, int[] in, int startIn, int endIn) {    for (int i = startIn; i &lt; endIn; i++) {        if (root == in[i])            return i;    }    return -1;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 但是这个的输出结果如下，很明显没有重建二叉树成功，它的执行流程如上面的代码，由于个人认为没有重建，所以就没有输出示意图</span><br></pre></td></tr></table></figure><p>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 新新—-的中序遍历的开始<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node50  是那边啊 根<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node10  是那边啊 左<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node20  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node25  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node60  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node80  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node85  是那边啊 右<br>09-02 05:51:53.177 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node90  是那边啊 右<br>09-02 05:51:53.185 2590-2590/com.android.interview I/System.out: 新新—-的中序遍历的结束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 解决方法二:解题思路也是不断地遍历，代码如下</span><br></pre></td></tr></table></figure></p><p> public static Node reConstructBinaryTreeNew(int[] pre, int[] in) {<br>        if (pre.length == 0 || in.length == 0)<br>            return null;<br>         Node node = new Node(pre[0]);<br>        for (int i = 0; i &lt; pre.length; i++) {<br>            if (pre[0] == in[i]) {<br>                node.leftChild = reConstructBinaryTreeNew(Arrays.copyOfRange(pre, 1, i + 1), Arrays.copyOfRange(in, 0, i));<br>                node.rightChild = reConstructBinaryTreeNew(Arrays.copyOfRange(pre, i + 1, pre.length), Arrays.copyOfRange(in, i + 1, in.length));<br>                break;<br>            }<br>        }<br>        return node;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  输出的结果和方法一的结果是一样的。二叉树的结果还是不一样。</span><br></pre></td></tr></table></figure></p><p>09-02 05:51:53.185 2590-2590/com.android.interview I/System.out: 新新—-的中序遍历的开始————<br>09-02 05:51:53.185 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node50  是那边啊 根<br>09-02 05:51:53.185 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node10  是那边啊 左<br>09-02 05:51:53.186 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node20  是那边啊 右<br>09-02 05:51:53.194 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node25  是那边啊 右<br>09-02 05:51:53.211 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node30  是那边啊 右<br>09-02 05:51:53.212 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node60  是那边啊 右<br>09-02 05:51:53.212 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node80  是那边啊 右<br>09-02 05:51:53.212 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node85  是那边啊 右<br>09-02 05:51:53.213 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node90  是那边啊 右<br>09-02 05:51:53.213 2590-2590/com.android.interview I/System.out: 这个值是什么啊 Node100  是那边啊 右<br>09-02 05:51:53.214 2590-2590/com.android.interview I/System.out: 新新—-的中序遍历的结束————<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  解决方法三：由前序遍历的第一个节点可知根节点。根据根节点，可以将中序遍历划分成左右子树。在前序遍历中找出对应的左右子树，其第一个节点便是根节点的左右子节点。按照上述方式递归便可重建二叉树。</span><br></pre></td></tr></table></figure></p><p>public class Test {<br>    /** </p><pre><code> * 请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;，例如“We are happy.“，则输出”We%20are%20happy.“。  *  * @param string     要转换的字符数组  * @param usedLength 已经字符数组中已经使用的长度  * @return 转换后使用的字符长度，-1表示处理失败  */  public static int replaceBlank(char[] string, int usedLength) {      // 判断输入是否合法      if (string == null || string.length &lt; usedLength) {          return -1;      }      // 统计字符数组中的空白字符数      int whiteCount = 0;      for (int i = 0; i &lt; usedLength; i++) {          if (string[i] == &apos; &apos;) {              whiteCount++;          }      }      // 计算转换后的字符长度是多少      int targetLength = whiteCount * 2 + usedLength;      int tmp = targetLength; // 保存长度结果用于返回      if (targetLength &gt; string.length) { // 如果转换后的长度大于数组的最大长度，直接返回失败          return -1;      }      // 如果没有空白字符就不用处理      if (whiteCount == 0) {          return usedLength;      }      usedLength--; // 从后向前，第一个开始处理的字符      targetLength--; // 处理后的字符放置的位置      // 字符中有空白字符，一直处理到所有的空白字符处理完      while (usedLength &gt;= 0 &amp;&amp; usedLength &lt; targetLength) {          // 如是当前字符是空白字符，进行&quot;%20&quot;替换          if (string[usedLength] == &apos; &apos;) {              string[targetLength--] = &apos;0&apos;;              string[targetLength--] = &apos;2&apos;;              string[targetLength--] = &apos;%&apos;;          } else { // 否则移动字符              string[targetLength--] = string[usedLength];          }          usedLength--;      }      return tmp;  }  </code></pre><p>}<br><code>`</code></p><ul><li><p>这三种的方式的结果也是一样的，我自己认为二叉树没有重构成功，如果有大佬明白的，可以指点下，谢谢了!</p></li><li><p>谢谢以下资料给与我的帮助</p><ul><li><a href="https://www.cnblogs.com/ysocean/p/8032642.html" target="_blank" rel="noopener">Java数据结构和算法（十）——二叉树</a></li><li><a href="https://github.com/Shimingli/android_interview" target="_blank" rel="noopener">android_interview</a></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 剑指几道算法题的思考 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>智能食柜</title>
      <link href="/2018/09/02/%E6%99%BA%E8%83%BD%E9%A3%9F%E6%9F%9C/"/>
      <url>/2018/09/02/%E6%99%BA%E8%83%BD%E9%A3%9F%E6%9F%9C/</url>
      <content type="html"><![CDATA[<ul><li>逻辑思维图</li><li>参考<a href="http://net.yesky.com/internet/395/463794895.shtml" target="_blank" rel="noopener">阿里的小卖柜</a><a id="more"></a> <img src="https://upload-images.jianshu.io/upload_images/5363507-d4ad6b7f9d0bed13.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="智能食柜.jpg"></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>新零售平台V1</title>
      <link href="/2018/08/27/%E6%96%B0%E9%9B%B6%E5%94%AE%E5%B9%B3%E5%8F%B0V1/"/>
      <url>/2018/08/27/%E6%96%B0%E9%9B%B6%E5%94%AE%E5%B9%B3%E5%8F%B0V1/</url>
      <content type="html"><![CDATA[<a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/5363507-b320bdfdbb01fbd3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新零售平台 V1.jpg"></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>常用集合的原理分析</title>
      <link href="/2018/08/22/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/22/%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<ul><li>分析常用集合的底层的原理：<code>ArrayList、Vector、LinckedList、HashMap、HashSet、LinkedHashMap、LruCache、SparseArray、ConcurrentHashMap</code><h4 id="一、ArrayList"><a href="#一、ArrayList" class="headerlink" title="一、ArrayList"></a>一、ArrayList</h4></li><li>最佳的做法是将<code>ArrayList</code>作为默认的首选，当你需要而外的功能的时候，或者是当程序性能由于经常需要从表中间插入和删除而变差的时候，才会去选择<code>LinkedList</code>  来源于<code>THinking in Java</code></li><li><p>源码分析</p><ul><li><p>最重要的两个属性分别是: <code>elementData</code> 数组 <code>size</code>的大小</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br><span class="line">  /**</span><br><span class="line">   * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">   *</span><br><span class="line">   * @serial</span><br><span class="line">   */</span><br><span class="line">  //以及 size 大小</span><br><span class="line">  private int size;</span><br></pre></td></tr></table></figure></li><li><p><code>transient</code>: <code>java</code>:语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。</p></li><li><p>构造函数: <code>new ArrayList()</code> 的时候，会指定一个<code>Object[]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指定长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">      super();</span><br><span class="line">      if (initialCapacity &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                  initialCapacity);</span><br><span class="line">      this.elementData = new Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>new Collection()</code> 添加一个集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">      elementData = c.toArray();</span><br><span class="line">      size = elementData.length;</span><br><span class="line">      // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">      if (elementData.getClass() != Object[].class)</span><br><span class="line">          elementData = Arrays.copyOf(elementData, size, </span><br><span class="line">Object[].class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>添加元素<code>add()</code> 将指定的元素追加到列表的末尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">    // 比如说加了一个元素</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;//这里的推算是 elementData[0]=e</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ensureCapacityInternal()</code>方法详情，如果是<code>add</code> 一个元素，那么就会走到<code>ensureExplicitCapacity()</code>的方法中！同时第一次扩容的最小的值为<code>DEFAULT_CAPACITY=10</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">     // 如果 是直接new ArrayList的话，那么扩容的最小的值为10</span><br><span class="line">     if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line">     //开始扩展</span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ensureExplicitCapacity(minCapacity)</code>,其中 <code>minCapacity</code>是最小的长度，如果是使用的 <code>new ArrayList&lt;E&gt;()</code> 然后 <code>add(E)</code>,那么这个 <code>minCapacity=10</code>.具体请看代码的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      // overflow-conscious code</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>grow(minCapactity)</code>  增加容量以确保它至少能容纳由最小容量参数指定的元素数量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    //(oldCapacity &gt;&gt; 1)等于 oldCapacity%2 意思就是除以2，取整数</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    //最小容量通常接近大小，所以这是一个胜利：</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分析上面的问题，假如第一次添加数据，那么<code>oldCapacity =0</code>;<code>0&gt;&gt;2</code>=<code>0</code>; <code>newCapacity - minCapacity &lt; 0</code>就是 ：<code>0-10</code>肯定小于<code>0</code>的,所以 <code>newCapacity = minCapacity;</code>，根据前面的分析，<code>minCapacity=10</code>!</p></li><li><p><code>minCapacity is usually close to size, so this is a win:</code> 翻译为：最小容量通常接近大小，所以这是一个胜利： 最后调用等到一个容器长度为<code>10</code>的<code>elementData</code>:</p><ul><li>最后一步在  <code>elementData[size++] = e;</code>就是把  <code>elementData[0] = e;</code>赋值完成了，size才会++ ，等于<code>size=1</code></li><li>关于 <code>&gt;&gt;</code>代表右移; <code>2</code>的二进制是<code>10</code>，&gt;&gt;代表右移，<code>10</code>右移<code>1</code>位是二进制的<code>1</code>，<code>&lt;&lt;</code>代表左移，<code>10</code>左移<code>1</code>位是二进制的<code>100</code>，也就是十进制的<code>4</code>。</li></ul></li><li><p>往指定角标中添加元素 ,过程和添加一个元素一样，只不过这个方法更加的高效<code>System.arraycopy()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">      if (index &gt; size || index &lt; 0)</span><br><span class="line">          throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">     // 首先扩容校验。</span><br><span class="line">      ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">      // TODO: 2018/8/16  使用了 native的方法</span><br><span class="line">      // 复制，向后移动 接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</span><br><span class="line">      System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">              size - index);</span><br><span class="line">      elementData[index] = element;</span><br><span class="line">      size++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在<code>ArrayList</code>中自定义了 <code>writeObject</code> 和 <code>readObject</code> ,目的是为了：<code>JVM</code> 会调用这两个自定义方法来实现序列化与反序列化 <code>ArrayList</code> 只序列化(序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象)了被使用的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ArrayList</code>的线程不安全,通过下面的方式证明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final ArrayList&lt;String&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">      Thread t1= new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line">              for (int i=0;i&lt;25;i++)&#123;</span><br><span class="line">                  lists.add(&quot;我是i=&quot;+i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      Thread t2= new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line">              for (int i=25;i&lt;50;i++)&#123;</span><br><span class="line">                  lists.add(&quot;我是i=&quot;+i);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      //主线程休眠1秒钟，以便t1和t2两个线程将lists填装完毕。</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      try &#123;</span><br><span class="line">          Thread.sleep(1000);</span><br><span class="line">          // 即使睡完觉了，但是也有可能长度不对</span><br><span class="line">          for(int l=0;l&lt;lists.size();l++)&#123;</span><br><span class="line">              // todo   两个线程不断的插入的话，就会导致插入的是null     我是i=34   我是i=10   我是i=35   我是i=11   null   null   我是i=12   我是i=38   我是i=13   我是i=39</span><br><span class="line">              System.out.print(lists.get(l)+&quot;   &quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>两个线程不断的插入的话，就会导致插入的是<code>null</code> <code>我是i=34   我是i=10   我是i=35   我是i=11   null   null   我是i=12   我是i=38   我是i=13   我是i=39</code></p><ul><li><p>如果要使用安全的线程的话，可以通过<code>List&lt;String&gt; data=Collections.synchronizedList(new ArrayList&lt;String&gt;());</code>得到线程安全的集合，<br>*<code>Collections.synchronizedList</code> 的原理,如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">    return (list instanceof RandomAccess ?</span><br><span class="line">            new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            new SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>可以在<code>SynchronizedList</code>类中方法加入了关键字 <code>synchronized</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">         synchronized (mutex) &#123;return list.get(index);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public E set(int index, E element) &#123;</span><br><span class="line">         synchronized (mutex) &#123;return list.set(index, element);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public void add(int index, E element) &#123;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>关于原型模式，<code>ArrayList</code> 实现了接口<code>Cloneable</code>;这个接口只有一个作用，就是在运行时候通知虚拟机可以安全的实现,在java的虚拟机中，只有实现了这个接口的类才可以被拷贝，否者会抛出<code>CloneNotSupportedException</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">          v.elementData = Arrays.copyOf(elementData, size);transient</span><br><span class="line">          v.modCount = 0;</span><br><span class="line">          return v;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">          throw new InternalError(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>我们可以看到这里有个深拷贝和 浅拷贝,幸运的是<code>java</code>中大部分都容器都实现了<code>Cloneable</code>这个接口，所以在程度上去实现深入拷贝不太难。</p><ul><li>深拷贝：就是需要拷贝的类中，所有的东西，比如说：原型类中的数组，容器，饮用对象等</li><li>浅拷贝：就是只拷贝基本东西，容器这些不拷贝<ul><li>更多的设计模式 <a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a></li></ul></li></ul></li><li><p><code>ArrayList</code>遍历的速度快，插入删除速度慢，随机访问的速度快</p></li></ul><h4 id="二、Vector"><a href="#二、Vector" class="headerlink" title="二、Vector"></a>二、Vector</h4><ul><li><p>关注<code>add  get</code> 方法:可以得出：使用 <code>synchronized</code>进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      ensureCapacityHelper(elementCount + 1);</span><br><span class="line">      elementData[elementCount++] = e;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  public synchronized E get(int index) &#123;</span><br><span class="line">      if (index &gt;= elementCount)</span><br><span class="line">          throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">      return elementData(index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>应该避免使用<code>Vector</code> ，它只存在支持遗留代码的类中（它能正常的工作的唯一原因是：因为为了向前兼容，它被适配成为了<code>List</code>）</p></li><li>其他的不想多说，浪费电！</li></ul><h4 id="三、LinckedList"><a href="#三、LinckedList" class="headerlink" title="三、LinckedList"></a>三、LinckedList</h4><ul><li><p>变量: 集合元素数量;链表头节点;链表尾节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//集合元素数量</span><br><span class="line">   transient int size = 0;</span><br><span class="line">   //链表头节点</span><br><span class="line">   transient Node&lt;E&gt; first;</span><br><span class="line">   //链表尾节点</span><br><span class="line">   transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure></li><li><p><code>Node</code>类，数据结构的关键类，每一个元素值，都存在两个结点，前一个，后一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">     E item;//元素值</span><br><span class="line">     Node&lt;E&gt; next;//后置节点</span><br><span class="line">     Node&lt;E&gt; prev;//前置节点</span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         this.item = element;</span><br><span class="line">         this.next = next;</span><br><span class="line">         this.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     this();</span><br><span class="line">     addAll(c);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>关注 <code>add(E)</code>方法,可以看到这个返回值永远为<code>true</code>; 每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组来说效率要高上不少</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">      linkLast(e);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>linkLast(E)</code> 方法:生成新节点 并插入到 链表尾部， 更新<code>last/first</code>节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null) //若原链表为空链表，需要额外更新头结点</span><br><span class="line">        first = newNode;</span><br><span class="line">    else//否则更新原尾节点的后置节点为现在的尾节点（新节点）</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果说，最后的一个结点为<code>null</code>;那么我们新加入的元素，就是最后一个结点，如果最后一个结点不为<code>null</code>,那么我们插入的新的值就是最后结点的<code>l.next = newNode</code>.</li></ul></li><li><p><code>get()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    // 常看数组角标是否越界</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>node(index)</code>的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    //二分查找来看 index 离 size 中间距离来判断是从头结点正序查还是从尾节点倒序查</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">     //通过下标获取某个node 的时候，（增、查 ），会根据index处于前半段还是后半段 进行一个折半，以提升查询效率</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        //不断的往前面找 ，如果查找的角标比linkedList的size的取余还小的话，就通过不断的循环去得到相对应的值</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>可以看出这是一个二分查找，如果 <code>index &lt; (size &gt;&gt; 1)</code> , <code>&gt;&gt;</code>代表右移,其实就是 <code>%2</code>,这里查找下去，知道找到为止</li><li>如果假如，我们查找的<code>index</code>约接近<code>size</code>的一半，那么我们需要的次数就会越低，总结一句话：效率是非常低的，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值。</li></ul></li><li>来源于 <code>gitHub</code><br><img src="https://upload-images.jianshu.io/upload_images/5363507-638fb161836b6be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linckedlist底层的原理.jpg"></li></ul><h4 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h4><ul><li>在 1.6 1.7 <code>hashmap</code>的类的代码一共<code>1500</code>行左右，在<code>1.8</code>一共有<code>2000</code>行左右! 这里直接看的是 <code>JDK1.8</code> 的代码。</li><li><p>关于变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">   //左移运算符，num &lt;&lt; 1,相当于num乘以2  最大的长度</span><br><span class="line">   static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 相当于把1 位移30为等于 1 + 30个0的长度</span><br><span class="line">   // 填充比 因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</span><br><span class="line">   // hashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。</span><br><span class="line">   static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">   //当add一个元素到某个位桶，其链表长度达到8时将链表转换为红黑树</span><br><span class="line">   static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">   static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">   static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>Node</code>内部类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final int hash;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">      //todo  构造函数 hash值 key 和value  和 下一个结点</span><br><span class="line">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          this.hash = hash;</span><br><span class="line">          this.key = key;</span><br><span class="line">          this.value = value;</span><br><span class="line">          this.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final K getKey()        &#123; return key; &#125;</span><br><span class="line">      public final V getValue()      &#123; return value; &#125;</span><br><span class="line">      public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">      // 是去key的hash值和 value的hash值 然后做位异运算 转为二进制 相同为0，不同为1</span><br><span class="line">      public final int hashCode() &#123;</span><br><span class="line">          //  todo 位异或运算（^）</span><br><span class="line">          // 运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1</span><br><span class="line">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final V setValue(V newValue) &#123;</span><br><span class="line">          V oldValue = value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      // todo  判断两个 node 结点是否相等，一个比较自身相等，一个是比较key和value</span><br><span class="line">      public final boolean equals(Object o) &#123;</span><br><span class="line">          if (o == this)</span><br><span class="line">              return true;</span><br><span class="line">          if (o instanceof Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                      Objects.equals(value, e.getValue()))</span><br><span class="line">                  return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><code>Node</code>类的中存储了 <code>hash</code> <code>key</code> <code>value</code> 和下一个结点 <code>Node</code>,后面解释</li><li><code>Node</code> 类的 <code>hashCode</code>是<code>Objects.hashCode(key) ^ Objects.hashCode(value)</code>;位异或运算（^）: 运算规则是两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1</li><li>判断两个<code>node</code>是否相等：一个比较自身相等，一个是比较<code>key</code>和<code>value</code></li></ul><ul><li><p><code>HashMap</code>的构造方法,指定容量和扩展因子！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                 initialCapacity);</span><br><span class="line">     //如果最大的长度大于最大的话，就默认最大的</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     //填充比为正</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                 loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     // 加入指定的容量为 10 那么新的扩容的临界值为 13</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>tableSizeFor(initialCapacity)</code> 方法，说白了就是算法，给你一个接近的值，设置<code>hashmap</code>的长度为10，那么他的新的扩容的临界值=16</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int cap=10;</span><br><span class="line"> int n = cap - 1;//9</span><br><span class="line"> n |= n &gt;&gt;&gt; 1;//9的二进制=1001  &gt;&gt;&gt;表示无符号的右移 100 =十进制 4     n=  1001 |= 100</span><br><span class="line"> System.out.println(&quot;n=&quot;+n); // n=13; 其实就是等于      n=  1001 |= 100 也就是n=1101 换成十进制等于13</span><br><span class="line"> n |= n &gt;&gt;&gt; 2;</span><br><span class="line"> n |= n &gt;&gt;&gt; 4;</span><br><span class="line"> n |= n &gt;&gt;&gt; 8;</span><br><span class="line"> n |= n &gt;&gt;&gt; 16;</span><br><span class="line"> int i= (n &lt; 0) ? 1 : (n &gt;= 1000000) ? 1000000 : n + 1;</span><br></pre></td></tr></table></figure><ul><li>无符号的右移（<code>&gt;&gt;&gt;</code>）:按照二进制把数字右移指定数位，高位直接补零，低位移除！<ul><li><code>a=a|b</code> 等于 <code>a|=b</code>的意思就是把a和b按位或然后赋值给a 按位或的意思就是先把a和b都换成2进制，然后用或操作</li></ul></li><li>比如：<code>9</code>的二进制<code>1001</code>  <code>&gt;&gt;&gt;</code>表示无符号的右移 得到<code>100</code> 等于十进制 <code>4</code>     <code>n</code>=<code>1001 |= 100</code>  ，最后 <code>n=1101</code> 转化为十进制等于<code>n=13</code>。</li><li>上面函数的运算过程 <ul><li>n |= n &gt;&gt;&gt; 1;//9的二进制=1001  &gt;&gt;&gt;表示无符号的右移 100 =十进制 4     n=  1001 |= 100<ul><li>n |= n &gt;&gt;&gt; 2; // 1101 移动两位 0011 |1101  等于1111</li><li>n |= n &gt;&gt;&gt; 4;// 1111 移动4为 0000 |1111 =1111</li><li>n |= n &gt;&gt;&gt; 8;// 1111 移动8为 0000 |1111 =1111</li><li>n |= n &gt;&gt;&gt; 16;// 1111 移动16为 0000 |1111 =1111</li></ul></li></ul></li></ul></li><li><p><code>HashMap</code>的构造方法,设置容器的长度 但是指定的默认的扩展因子为 <code>0.75</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">      this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>HashMap</code>的构造方法,什么都不指定 都给默认的,我们自己最常用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//什么都不指定 都给默认的</span><br><span class="line">   public HashMap() &#123;</span><br><span class="line">       this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>*<code>HashMap</code>的构造方法, 也可以new一个 map进去，这种的方式 我们使用的比较少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">     //默认指定了扩展的因子</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p><code>putMapEntries()</code>方法,如果是构造函数到这里来的话，就会进入到<code>threshold = tableSizeFor(t);</code>这里来，然后遍历<code>m</code>,然后一个个元素去添加，如果装载进来的<code>map</code>集合过于巨大，建议使用源<code>map</code>的原型模式<code>clone</code>方法克隆一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">       int s = m.size();</span><br><span class="line">       if (s &gt; 0) &#123;</span><br><span class="line">           // 如果是hashmap中填充了一个map 就会走到这里来 table == null  =true</span><br><span class="line">           if (table == null) &#123; // pre-size</span><br><span class="line">               float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">               int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                       (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               // t=ft</span><br><span class="line">               if (t &gt; threshold)</span><br><span class="line">                   //也就会走到这里来</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125; else if (s &gt; threshold) &#123;</span><br><span class="line">               // 扩容机制</span><br><span class="line">               resize();</span><br><span class="line">           &#125;</span><br><span class="line">           // copy的过程  遍历hashmap的话，这个应该是最高效的方式</span><br><span class="line">           for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, false, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>关键方法<code>put</code>，了解如何储存的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">      return putVal(hash(key), key, value, false, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>putVal</code>方法的详情，假装<code>put</code>数据去分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 在构造函数中，也调用了这个方法，唯一不同的地方就是 evict=fasle</span><br><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                boolean evict) &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">     if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     /*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/</span><br><span class="line">     if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">         // todo  LinkedHashMap 重新重写了这个方法，然后使用了 LinkedHashMap.Entry 里面多了两个结点    Entry&lt;K,V&gt; before, after;</span><br><span class="line">         tab[i] = newNode(hash, key, value, null);</span><br><span class="line">     ///*表示有冲突,开始处理冲突*/</span><br><span class="line">     else &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         /*检查第一个Node，p是不是要找的值*/</span><br><span class="line">         if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         else if (p instanceof TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">         else &#123;</span><br><span class="line">             for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                 /*指针为空就挂在后面*/</span><br><span class="line">                 if ((e = p.next) == null) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, null);</span><br><span class="line">                     //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　</span><br><span class="line">                     //treeifyBin首先判断当前hashMap的长度，如果不足64，只进行</span><br><span class="line">                     //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 /*如果有相同的key值就结束遍历*/</span><br><span class="line">                 if (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                     break;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  /*就是链表上有相同的key值*/</span><br><span class="line">         if (e != null) &#123; // existing mapping for key</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             // todo  LinkedHashMap  对其重写</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             return oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     /*如果当前大小大于门限，门限原本是初始容量*0.75*/</span><br><span class="line">     if (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     // todo  LinkedHashMap 对其重写</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、可以发现 <code>table</code>肯定为<code>null</code>,没有初始化，所以第一个判断条件肯定成立<code>tab = table) == null || (n = tab.length) == 0</code>,这里有个小小的问题，当<code>tab = table) == null</code>成立的时候，后面<code>||</code>的代码是不会执行的，所以不会抛出空指针的异常。也就会执行<code>n = (tab = resize()).length;</code>的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;// 第一次table没有去初始化，肯定为null</span><br></pre></td></tr></table></figure></li><li><p>2、关于  <code>resize()</code>的方法，其实这个也是很关键的方法，扩容</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">   // 扩容机制 HasMap的扩容机制resize();</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">   int oldThr = threshold;</span><br><span class="line">   int newCap, newThr = 0;</span><br><span class="line">  /*如果旧表的长度不是空*/</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">         if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">          return oldTab;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      /*把新表的长度设置为旧表长度的两倍，newCap=2*oldCap*/</span><br><span class="line">      else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">              oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"></span><br><span class="line">          /*把新表的门限设置为旧表门限的两倍，newThr=oldThr*2*/</span><br><span class="line">          newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">      newCap = oldThr;</span><br><span class="line">      /*如果旧表的长度的是0，就是说第一次初始化表*/</span><br><span class="line">  else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">      // todo 在new hashMap中的长度 ，然后调用了 put的方法的时候，就会发生一次扩容 ，长度为16</span><br><span class="line">      newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  if (newThr == 0) &#123;</span><br><span class="line">      float ft = (float)newCap * loadFactor;//新表长度乘以加载因子</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">              (int)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">  /*下面开始构造新表，初始化表中的数据*/</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  if (oldTab != null) &#123;</span><br><span class="line">      for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">          Node&lt;K,V&gt; e;</span><br><span class="line">          if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">              oldTab[j] = null;</span><br><span class="line">              if (e.next == null)//说明这个node没有链表直接放在新表的e.hash &amp; (newCap - 1)位置</span><br><span class="line">                  newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">              else if (e instanceof TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">              else &#123; // preserve order</span><br><span class="line">                  Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                  Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                  Node&lt;K,V&gt; next;</span><br><span class="line">                  do &#123;</span><br><span class="line">                      next = e.next;</span><br><span class="line">                      //记录下一个结点</span><br><span class="line">                      //新表是旧表的两倍容量，实例上就把单链表拆分为两队，</span><br><span class="line">                     //e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对</span><br><span class="line">                      if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                          if (loTail == null)</span><br><span class="line">                              loHead = e;</span><br><span class="line">                          else</span><br><span class="line">                              loTail.next = e;</span><br><span class="line">                          loTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                      else &#123;</span><br><span class="line">                          if (hiTail == null)</span><br><span class="line">                              hiHead = e;</span><br><span class="line">                          else</span><br><span class="line">                              hiTail.next = e;</span><br><span class="line">                          hiTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; while ((e = next) != null);</span><br><span class="line">                  if (loTail != null) &#123;</span><br><span class="line">                      loTail.next = null;</span><br><span class="line">                      newTab[j] = loHead;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (hiTail != null) &#123;</span><br><span class="line">                      hiTail.next = null;</span><br><span class="line">                      newTab[j + oldCap] = hiHead;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>扩容方法也比较复杂，带着问题来分析，第一次，<code>put</code>数据的时候，可以得出<code>oldCap=0</code>、<code>oldThr=0</code>;那么新的长度 <code>newCap = DEFAULT_INITIAL_CAPACITY=16;</code> <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)=0.75*16=12</code>,把新的长度赋值给<code>threshold = newThr;</code></li><li>然后<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>,根据上面我们可以的得出 <code>newCap=16</code>;<ul><li>由于 <code>oldTab==null</code>，所以，这几返回一个 <code>newTab</code> 这是一个长度为<code>16</code>的<code>Node</code>的数组</li></ul></li><li>3、回到<code>putVal</code>的方法中，那么 <code>n = (tab = resize()).length;</code>也就是<code>n=16</code></li><li>4、那么<code>(p = tab[i = (n - 1) &amp; hash]) == null</code>是否成立呢，其实我们可以猜测下，第一次肯定是成立的，这里有个运算符，位与运算符<code>&amp;</code>,把做运算的两个数都转化为二进制的，然后从高位开始比较，如果两个数都是<code>1</code>则为<code>1</code>，否者为<code>0</code>.如下面的 <code>HashMap</code>中的算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   int newHash=hash(&quot;test&quot;);</span><br><span class="line">   // 1的hash值=1    test :hash值=3556516</span><br><span class="line">   System.out.println( &quot;newHash 1的hash值=&quot;+newHash);</span><br><span class="line">   i = (16 - 1) &amp; newHash;</span><br><span class="line">   // i值=1  test值=4</span><br><span class="line">   System.out.println(&quot;newHash的 i值=&quot;+i);</span><br><span class="line">  int hash(Object key) &#123;</span><br><span class="line">   int h;</span><br><span class="line">   return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><ul><li><p>5、这样就是走到这里来<code>tab[i] = newNode(hash, key, value, null);</code>，也就是<code>tab[0]=newNode</code>。这里有个面试，面试经常问，这里注意到 <code>tab</code> 是 <code>resize()</code>方法返回的，在<code>resize()</code>方法中，又把<code>table = newTab;</code>,那么我们改动 <code>tab</code>能否去改变 <code>table</code>呢？其实是能够的，这里传递是地址值，如下面的<code>Demo</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       String[] newS=setTest();</span><br><span class="line">        newS[0]=&quot;16&quot;;</span><br><span class="line">        // newS =[Ljava.lang.String;@1e0b9a</span><br><span class="line">        System.out.println(&quot;newS =&quot;+newS);</span><br><span class="line">        //newS =[Ljava.lang.String;@1e0b9a</span><br><span class="line">        System.out.println(&quot;test =&quot;+test);</span><br><span class="line">        System.out.println(&quot;test=&quot;+test.length);</span><br><span class="line">        System.out.println(&quot;test=&quot;+test[0]);</span><br><span class="line">     &#125;</span><br><span class="line">    String[] test;</span><br><span class="line">    public String[]  setTest()&#123;</span><br><span class="line">        String[] newS=new String[10];</span><br><span class="line">        test=newS;</span><br><span class="line">        return newS;</span><br><span class="line">    &#125;</span><br><span class="line">     ```  </span><br><span class="line">  * 以上就是 `HashMap`第一次`put`数据的完整过程。</span><br><span class="line">    </span><br><span class="line">* 当多次的`put`数据的时候，如果 某个位置上的 `hash`值相同的话，准确的讲`i = (n - 1) &amp; hash` 是这个值，取出来的 `tab`不为`null`，那么储存的结构转化为链表</span><br></pre></td></tr></table></figure><p>for (int binCount = 0; ; ++binCount) {</p><pre><code>/*指针为空就挂在后面*/if ((e = p.next) == null) {    p.next = newNode(hash, key, value, null);    //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　    //treeifyBin首先判断当前hashMap的长度，如果不足64，只进行    //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st        treeifyBin(tab, hash);    break;}/*如果有相同的key值就结束遍历*/if (e.hash == hash &amp;&amp;        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))    break;</code></pre></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 当一个位置上的大于 ` TREEIFY_THRESHOLD - 1` 也就是 `7`的话，看是否需要改变冲突节点的存储结构.`treeifyBin`首先判断当前`hashMap`的长度，如果不足`64`，只进行`resize`，扩容`table`，如果达到64，那么将冲突的存储结构为红黑树.如下图的结构</span><br><span class="line">![HashMap](https://upload-images.jianshu.io/upload_images/5363507-d8230dc20a3b52b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure><p>  final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {<br>        int n, index; Node&lt;K,V&gt; e;<br>        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>            resize();<br>        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {<br>            TreeNode&lt;K,V&gt; hd = null, tl = null;<br>            do {<br>                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);<br>                if (tl == null)<br>                    hd = p;<br>                else {<br>                    p.prev = tl;<br>                    tl.next = p;<br>                }<br>                tl = p;<br>            } while ((e = e.next) != null);<br>            if ((tab[index] = hd) != null)<br>                hd.treeify(tab);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 是所有链表上的数据结构都会转，不可能在一个链表上，即存在红黑树，也存在链表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* `get`方法相对应就简单了</span><br></pre></td></tr></table></figure></p><p> public V get(Object key) {<br>        Node&lt;K,V&gt; e;<br>        return (e = getNode(hash(key), key)) == null ? null : e.value;<br>    }<br> // 不断的去取结点，是红黑树就去找红黑树，是聊边就去找链表<br>    final Node&lt;K,V&gt; getNode(int hash, Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {<br>            if (first.hash == hash &amp;&amp; // always check first node<br>                    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return first;<br>            if ((e = first.next) != null) {<br>                if (first instanceof TreeNode)<br>                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                do {<br>                    if (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        return e;<br>                } while ((e = e.next) != null);<br>            }<br>        }<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `HashMap` 是一个线程不安全的容器，发生扩容时会出现环形链表从而导致死循环</span><br><span class="line">*  ` HashMap` 是一个无序的 `Map`，因为每次根据 `key `的 `hashCode `映射到` Entry` 数组上，所以遍历出来的顺序并不是写入的顺序。</span><br><span class="line">* `HashMap` 遍历的速度慢，底层决定了，插入删除的速度快，随机访问的速度也比较快</span><br><span class="line"></span><br><span class="line">#### 五、ConcurrentHashMap</span><br><span class="line">* 支持线程安全的并发容器 `ConcurrentHashMap`,原理和`HashMap`差不多，区别就是采用了` CAS + synchronized` 来保证并发安全性</span><br><span class="line">* `putVal` 加了同步锁 `synchronized `</span><br></pre></td></tr></table></figure></p><p> final V putVal(K key, V value, boolean onlyIfAbsent) {<br>        if (key == null || value == null) throw new NullPointerException();<br>        //根据 key 计算出 hashcode<br>        int hash = spread(key.hashCode());<br>        int binCount = 0;<br>        for (Node&lt;K,V&gt;[] tab = table;;) {<br>            Node&lt;K,V&gt; f; int n, i, fh;<br>            // 判断是否需要进行初始化<br>            if (tab == null || (n = tab.length) == 0)<br>                tab = initTable();<br>            //f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功<br>            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {<br>                if (casTabAt(tab, i, null,<br>                        new Node&lt;K,V&gt;(hash, key, value, null)))<br>                    break;                   // no lock when adding to empty bin<br>            }<br>            else if ((fh = f.hash) == MOVED)<br>                tab = helpTransfer(tab, f); //如果当前位置的 hashcode == MOVED == -1,则需要进行扩容<br>            else {<br>                //如果都不满足，则利用 synchronized 锁写入数据<br>                V oldVal = null;<br>                // todo  put  数据的时候  加入了锁<br>                synchronized (f) {<br>                    if (tabAt(tab, i) == f) {<br>                        if (fh &gt;= 0) {<br>                            binCount = 1;<br>                            for (Node&lt;K,V&gt; e = f;; ++binCount) {<br>                                K ek;<br>                                if (e.hash == hash &amp;&amp;<br>                                        ((ek = e.key) == key ||<br>                                                (ek != null &amp;&amp; key.equals(ek)))) {<br>                                    oldVal = e.val;<br>                                    if (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    break;<br>                                }<br>                                Node&lt;K,V&gt; pred = e;<br>                                if ((e = e.next) == null) {<br>                                    pred.next = new Node&lt;K,V&gt;(hash, key,<br>                                            value, null);<br>                                    break;<br>                                }<br>                            }<br>                        }<br>                        else if (f instanceof TreeBin) {<br>                            Node&lt;K,V&gt; p;<br>                            binCount = 2;<br>                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                    value)) != null) {<br>                                oldVal = p.val;<br>                                if (!onlyIfAbsent)<br>                                    p.val = value;<br>                            }<br>                        }<br>                        else if (f instanceof ReservationNode)<br>                            throw new IllegalStateException(“Recursive update”);<br>                    }<br>                }<br>                if (binCount != 0) {<br>                    //如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树<br>                    if (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    if (oldVal != null)<br>                        return oldVal;<br>                    break;<br>                }<br>            }<br>        }<br>        addCount(1L, binCount);<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  `get`方法</span><br></pre></td></tr></table></figure></p><p> public V get(Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;<br>        int h = spread(key.hashCode());<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;<br>                (e = tabAt(tab, (n - 1) &amp; h)) != null) {<br>            //根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值<br>            if ((eh = e.hash) == h) {<br>                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))<br>                    return e.val;<br>            }<br>            //如果是红黑树那就按照树的方式获取值<br>            else if (eh &lt; 0)<br>                return (p = e.find(h, key)) != null ? p.val : null;<br>            // 就不满足那就按照链表的方式遍历获取值<br>            while ((e = e.next) != null) {<br>                if (e.hash == h &amp;&amp;<br>                        ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))<br>                    return e.val;<br>            }<br>        }<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 基本上的变量都是被`volatile`关键字修饰</span><br></pre></td></tr></table></figure></p><pre><code>transient volatile Node&lt;K,V&gt;[] table;private transient volatile Node&lt;K,V&gt;[] nextTable;private transient volatile long baseCount;</code></pre><p>   …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###  `volatile`关键字  `Java `多线程的三大核心 </span><br><span class="line">####  1、 原子性 :java原子性和数据库事务的原子性差不多，一个操作要么是全部执行成功或者是失败.</span><br><span class="line">  * JVM 只保证了基本的原子性，但是类似 i++ 之类的操作，看着好像是原子的操作，其实里面涉及到了三个步骤</span><br><span class="line">    *  获取 i 的值</span><br><span class="line">    *  自增</span><br><span class="line">    *  在赋值给 i</span><br><span class="line">  * 这三个步骤 要实现`i++` 这样的原子操作就需要用到 `synchronized `或者是 了`lock  `进行加锁处理。</span><br><span class="line">  *  如果是基础类的自增操作可以使用` AtomicInteger` 这样的原子类来实现(其本质是利用了` CPU` 级别的 的 `CAS` 指令来完成的)。` AtomicInteger` 是线程安全的</span><br><span class="line">* 其中用的最多的方法就是: incrementAndGet() 以原子的方式自增</span><br></pre></td></tr></table></figure></p><p>  AtomicInteger atomicInteger=new    AtomicInteger();<br>        int i = atomicInteger.incrementAndGet();<br>        System.out.println(“i=”+i); </p><pre><code>public final int incrementAndGet() {     return U.getAndAddInt(this, VALUE, 1) + 1; }</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">####  2、可见性</span><br><span class="line">  *  现在的计算机，由于 `cpu` 直接从 主内存中读取数据的效率不高。所以都会对应的 `cpu`高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存中，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时读取就是修改之前的数据 </span><br><span class="line">  </span><br><span class="line">  *  `volatile `关键字就是用于保存内存的可见性，当线程A更新了` volatite`的修饰的变量的话，他会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新的值</span><br><span class="line">  </span><br><span class="line">  *` synchronized` 和加锁也能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和` volatile` 相比较起来开销比较大 ！</span><br><span class="line">  </span><br><span class="line">  * 但是` volatile `不能够替换` synchronized `因为`volatile` 不能够保证原子性 (要么执行成功或者失败，没有中间的状态) </span><br><span class="line"></span><br><span class="line">#### 3、顺序性</span><br></pre></td></tr></table></figure><p>int a = 100 ; //1<br>int b = 200 ; //2<br>int c = a + b ; //3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  * 正常的代码的执行顺序应该是`1》》2》》3 `。但是有时候 `JVM `为了提高整体的效率会进行指令重排导致执行顺序可能是 `2》》1》》3 `。但是`JVM` 也不能是 什么都进行重排，`是在保证最终结果和代码顺序执行结果是一致的情况下才可能会进行重排`</span><br><span class="line">  * 重排在单线程中不会出现问题，但是在多线程中就会出现顺序不一致的问题 </span><br><span class="line">  *  `java `中可以使用 `volatile` 关键字来保证顺序性，`synchronized `和`lock` 也可以来保证有序性，和保证 原子性的方式一样，通过同一段时间只能一个线程访问来实现的 </span><br><span class="line">  * 除了 `volatile` 关键字显式的保证顺序之外，`jvm HIA`通过 `happen-before` 原则来隐式来保证顺序性。</span><br><span class="line"></span><br><span class="line">*  `volitle`的应用，主要是在单利，个人感觉这是常用的在移动端的开发!当然可以使用内部类或者是单利去实现，[更多的设计模式](https://www.jianshu.com/p/4e01479b6a2c)   </span><br><span class="line">   *  1、`volatile` 实现一个双重检查锁的单例模式</span><br></pre></td></tr></table></figure></p><pre><code>   public class Singleton {    private static volatile Singleton singleton;    private Singleton() {    }    public static Singleton getInstance() {        if (singleton == null) {            synchronized (Singleton.class) {                if (singleton == null) {                    singleton = new Singleton();                }            }        }        return singleton;    }} <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  * 这里的 `volatile` 关键字主要是为了防止指令重排。 如果不用` volatile `，`singleton = new Singleton()`;，这段代码其实是分为三步：</span><br><span class="line">    * 分配内存空间。(1)</span><br><span class="line">     *  初始化对象。(2)</span><br><span class="line">     * 将 singleton 对象指向分配的内存地址。(3)</span><br><span class="line">  * 加上` volatile` 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</span><br><span class="line">*  2、控制停止线程的标记</span><br></pre></td></tr></table></figure></code></pre><p>  private volatile boolean flag ;<br>     private void run(){<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                doSomeThing();<br>            }<br>        });<br>    }</p><pre><code>private void stop(){    flag = false ;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> *  如果没有用`volatile` 来修饰` flag `，就有可能其中一个线程调用了 `stop()`方法修改了` flag `的值并不会立即刷新到主内存中，导致这个循环并不会立即停止.这里主要利用的是 `volatile` 的内存可见性 .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 六、HashSet</span><br><span class="line">* `HashSet` 是一个不允许存储重复元素的集合。</span><br><span class="line">* `HashSet`的源码只有三百多行，原理非常简单，主要底层还是`HashMap`。</span><br><span class="line">*  `map` 和 `PERSENT`:</span><br></pre></td></tr></table></figure><pre><code>//  map ：用于存放最终数据的。private transient HashMap&lt;E,Object&gt; map;// Dummy value to associate with an Object in the backing Map// PRESENT ：是所有写入 map 的 value 值。private static final Object PRESENT = new Object();</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法:底层一个hashMap</span><br></pre></td></tr></table></figure><pre><code>public HashSet() {    map = new HashMap&lt;&gt;();}</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关键的就是这个 `add() `方法。 可以看出它是将存放的对象当做了 `HashMap `的健，`value` 都是相同的 `RESENT `。由于 `HashMap` 的 `key` 是不能重复的，所以每当有重复的值写入到 `HashSet `时，`value `会被覆盖，但 `key `不会受到影响，这样就保证了` HashSet` 中只能存放不重复的元素。</span><br></pre></td></tr></table></figure><p>  public boolean add(E e) {<br>        return map.put(e, PRESENT)==null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 七、LinkedHashMap</span><br><span class="line">*  `HashMap` 是一个无序的 `Map`，每次根据 `key` 的 `hashcode` 映射到 `Entry` 数组上，所以遍历出来的顺序并不是写入的顺序。 因此 `JDK` 推出一个基于` HashMap `但具有顺序的` LinkedHashMap `来解决有排序需求的场景。它的底层是继承于` HashMap `实现的，由一个双向链表所构成。</span><br><span class="line">* ` LinkedHashMap` 的排序方式有两种：</span><br><span class="line">     *  根据写入顺序排序。</span><br><span class="line">      *  根据访问顺序排序(LRU底层的原理)。 其中根据访问顺序排序时，每次` get `都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</span><br><span class="line">*  `LinkedHashMap`中的 `Entry`:利用了头节点和其余的各个节点之间通过 `Entry `中的 `after `和 `before `指针进行关联</span><br></pre></td></tr></table></figure></p><pre><code>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {    Entry&lt;K,V&gt; before, after;    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {        super(hash, key, value, next);    }}</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 变量</span><br></pre></td></tr></table></figure><p>  // 用于指向双向链表的头部<br>    transient LinkedHashMap.Entry&lt;K,V&gt; head;<br>    //用于指向双向链表的尾部</p><pre><code>transient LinkedHashMap.Entry&lt;K,V&gt; tail;// LinkedHashMap 如何达到有序的关键//   todo   还有一个 accessOrder 成员变量，默认是 false，默认按照插入顺序排序，为 true 时按照访问顺序排序，也可以调用final boolean accessOrder;</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  构造方法，`LRUchace `最近最少使用的缓存底层就是这个构造函数。</span><br></pre></td></tr></table></figure><p> public LinkedHashMap(int initialCapacity,<br>                         float loadFactor,<br>                         boolean accessOrder) {<br>        super(initialCapacity, loadFactor);<br>        this.accessOrder = accessOrder;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 侧重关注 `put`，会走父类`HashMap`中的`put`方法，具体请看`HashMap` `put` 方法的解释</span><br><span class="line">   * 1、 在 `LinkedHashMap` 重写了,`newNode`的方法。 使用了` LinkedHashMap.Entry `里面多了两个结点    `Entry&lt;K,V&gt; before, after`;</span><br></pre></td></tr></table></figure></p><pre><code>  Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {    LinkedHashMap.Entry&lt;K,V&gt; p =            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);    //秘密就在于 new的是自己的Entry类，然后调用了linkedNodeLast    linkNodeLast(p);    return p;} <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  2、实现了`afterNodeAccess()`方法， ` void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;`！此函数执行的效果就是将最近使用的Node，放在链表的最末尾。特别说明一下，这里是显示链表的修改后指针的情况，实际上在桶里面的位置是不变的，只是前后的指针指向的对象变了！</span><br></pre></td></tr></table></figure> //  此函数执行的效果就是将最近使用的Node，放在链表的最末尾void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last    LinkedHashMap.Entry&lt;K,V&gt; last;    //仅当按照LRU原则且e不在最末尾，才执行修改链表，将e移到链表最末尾的操作    if (accessOrder &amp;&amp; (last = tail) != e) {        //将e赋值临时节点p， b是e的前一个节点， a是e的后一个节点        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        //设置p的后一个节点为null，因为执行后p在链表末尾，after肯定为null        p.after = null;        //p前一个节点不存在，情况一        if (b == null)            head = a;        else            b.after = a;        if (a != null)            a.before = b;            //p的后一个节点不存在，情况二        else            last = b;        if (last == null)            head = p;        else {    //正常情况，将p设置为尾节点的准备工作，p的前一个节点为原先的last，last的after为p            p.before = last;            last.after = p;        }        //将p设置为将p设置为尾节点        tail = p;        ++modCount;    // 修改计数器+1    }} <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  3、 `put`方法 执行的第二个步骤   ，这个方法没什么用尽可能删除最老的 插入后把最老的`Entry`删除，不过`removeEldestEntry`总是返回`false`，所以不会删除，估计又是一个方法给子类用的</span><br></pre></td></tr></table></figure>void afterNodeInsertion(boolean evict) { // possibly remove eldest    LinkedHashMap.Entry&lt;K,V&gt; first;    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {        K key = first.key;        // todo hashmap中移除 Node结点        removeNode(hash(key), key, null, false, true);    }} // 如果映射表示缓存，这是有用的：它允许通过删除过时条目来减少内存消耗的映射。protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {    return false;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  4 、`afterNodeRemoval()`移除结点也会重写，因为结点都不一样</span><br></pre></td></tr></table></figure>   void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink    //与afterNodeAccess一样，记录e的前后节点b，a    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;    //p已删除，前后指针都设置为null，便于GC回收    p.before = p.after = null;    //与afterNodeAccess一样类似，一顿判断，然后b，a互为前后节点    if (b == null)        head = a;    else        b.after = a;    if (a == null)        tail = b;    else        a.before = b;}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `get()`方法详情,然后调用父类`HashMap` 的`getNode()`去找结点</span><br></pre></td></tr></table></figure></code></pre><p>  public V get(Object key) {<br>        Node&lt;K,V&gt; e;<br>        //调用HashMap的getNode的方法，<br>        if ((e = getNode(hash(key), key)) == null)<br>            return null;<br>        if (accessOrder)<br>            afterNodeAccess(e);<br>        return e.value;<br>    }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  `HashMap`中的`getNode()` 方法</span><br></pre></td></tr></table></figure></p><p>  final Node&lt;K,V&gt; getNode(int hash, Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {<br>            if (first.hash == hash &amp;&amp; // always check first node<br>                    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return first;<br>            if ((e = first.next) != null) {<br>                if (first instanceof TreeNode)<br>                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                do {<br>                    if (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        return e;<br>                } while ((e = e.next) != null);<br>            }<br>        }<br>        return null;<br>    }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于访问顺序排序的Demo,我只想说明了一下，等于用了的数据，就会放在链表的末尾，这个类也是安卓中`LruCache`的底层原理</span><br></pre></td></tr></table></figure></p><p>LinkedHashMap&lt;String, Integer&gt; map1 = new LinkedHashMap&lt;String, Integer&gt;(10, (float) 0.75,true);<br>        map1.put(“1”,1) ;<br>        map1.put(“2”,2) ;<br>        map1.put(“3”,3) ;<br>        map1.put(“4”,4) ;<br>        map1.put(“5”,5) ;<br>        map1.put(“6”,6) ;<br>        map1.put(“7”,7) ;<br>        map1.put(“8”,8) ;<br>        map1.put(“9”,9) ;<br>        map1.put(“10”,10) ;<br>        map1.get(“6”);<br>        // {1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 10=10, 6=6}<br>        System.out.println(“map1==”+map1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  ![LinkedHashMap的原理.png](https://upload-images.jianshu.io/upload_images/5363507-704c9d041bbdeae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 八、LruCache</span><br><span class="line">* `Android`中提供了一种基本的缓存策略，即`LRU（least recently used）`。基于该种策略，当存储空间用尽时，缓存会清除最近最少使用的对象</span><br><span class="line">*  `LRU（Least Recently Used）`最近最少使用的，看了源码才知道核心是`LRUCache`类，这个类的核心其实是 `LinkedHashMap`类.</span><br><span class="line">*  Demo 如下</span><br></pre></td></tr></table></figure></p><p> LruCache&lt;Integer,String&gt; lruCache=new LruCache&lt;&gt;(5);<br>        lruCache.put(1,”1”);<br>        lruCache.put(2,”2”);<br>        lruCache.put(3,”3”);<br>        lruCache.put(4,”4”);<br>        lruCache.put(5,”5”);</p><pre><code>lruCache.get(1);lruCache.get(2);lruCache.get(3);lruCache.get(4);Map&lt;Integer, String&gt; snapshot = lruCache.snapshot();//lruCache={5=5, 1=1, 2=2, 3=3, 4=4}    5最少使用到System.out.println(&quot;lruCache=&quot;+snapshot.toString());//当多添加一个的话，那么5就会被删除，加入6上去lruCache.put(6,&quot;6&quot;);// new  lruCache={1=1, 2=2, 3=3, 4=4, 6=6}Map&lt;Integer, String&gt; snapshot1 = lruCache.snapshot();System.out.println(&quot; new  lruCache=&quot;+snapshot1.toString());</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法,可以明显看出，底层使用的是`LinkedHashMap`.</span><br></pre></td></tr></table></figure><p> public LruCache(int maxSize) {<br>        if (maxSize &lt;= 0) {<br>            throw new IllegalArgumentException(“maxSize &lt;= 0”);<br>        }<br>        this.maxSize = maxSize;<br>        // 初始化这里 就是  new的 true的  所以使用的顺序排序<br>        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);<br>    }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `put`方法 :重要的就是在添加过缓存对象后，调用` trimToSize()`方法，来判断缓存是否已满，如果满了就要删除近期最少使用的算法.同时线程也是安全的。</span><br></pre></td></tr></table></figure><p>   public final V put(K key, V value) {<br>        //不可为空，否则抛出异常<br>        if (key == null || value == null) {<br>            throw new NullPointerException(“key == null || value == null”);<br>        }</p><pre><code>    V previous;    // 多线程 可以使用    synchronized (this) {        //插入的缓存对象值加1        putCount++;        //增加已有缓存的大小        size += safeSizeOf(key, value);        //向map中加入缓存对象        previous = map.put(key, value);        if (previous != null) {            //如果已有缓存对象，则缓存大小恢复到之前            size -= safeSizeOf(key, previous);        }    }    //entryRemoved()是个空方法，可以自行实现    if (previous != null) {        entryRemoved(false, key, previous, value);    }    //调整缓存大小(关键方法)    trimToSize(maxSize);    return previous;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  1、`safeSizeOf`方法,这个`sizeof`的方法，就是我们自己需要重写的，记得图片加载框架的设计，就会运用到他</span><br></pre></td></tr></table></figure><pre><code>private int safeSizeOf(K key, V value) {    //  每一个的需要缓存的大小    int result = sizeOf(key, value);    if (result &lt; 0) {        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);    }    return result;}protected int sizeOf(K key, V value) {    return 1;}</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 2、调整缓存大小(关键方法) `trimToSize(maxSize);` `maxSize`也就是指定的大小，当`     if (size &lt;= maxSize) &#123; break; &#125;`这个判断不成立的时候，就会往下走，迭代器就会去获取第一个对象，即队尾的元素，近期最少访问的元素。然后把它删除该对象，并更新缓存大小 `  map.remove(key);`</span><br></pre></td></tr></table></figure><p>  private void trimToSize(int maxSize) {<br>        while (true) {<br>            K key;<br>            V value;<br>            synchronized (this) {<br>                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {<br>                    throw new IllegalStateException(getClass().getName()</p><pre><code>                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);            }            if (size &lt;= maxSize) {                break;            }            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素            Map.Entry&lt;K, V&gt; toEvict = null;            for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {                toEvict = entry;            }            if (toEvict == null) {                break;            }            key = toEvict.getKey();            value = toEvict.getValue();            //删除该对象，并更新缓存大小            map.remove(key);            size -= safeSizeOf(key, value);            evictionCount++;        }        // 空实现        entryRemoved(true, key, value, null);    }}</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 关于 `get`方法！也是一个同步的方法。</span><br></pre></td></tr></table></figure><p> public final V get(K key) {<br>        //key为空抛出异常<br>        if (key == null) {<br>            throw new NullPointerException(“key == null”);<br>        }</p><pre><code>V mapValue;synchronized (this) {    //获取对应的缓存对象    //get()方法会实现将访问的元素更新到队列头部的功能    // todo LinkedHashMap  里面已经实现了 如果 添加到头部去    mapValue = map.get(key);    if (mapValue != null) {        hitCount++;        return mapValue;    }    missCount++;}</code></pre><p> …<br>}<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `LruCache`使用的`Demo`,这个 `Demo` 就看看，没吊用。</span><br></pre></td></tr></table></figure></p><p> public class ImageCache {<br>        //定义LruCache，指定其key和保存数据的类型<br>        private LruCache&lt;String, Bitmap&gt; mImageCache;</p><pre><code>    ImageCache() {        //获取当前进程可以使用的内存大小，单位换算为KB        final int maxMemory = (int)(Runtime.getRuntime().maxMemory() / 1024);        //取总内存的1/4作为缓存        final int cacheSize = maxMemory / 4;        //初始化LruCache        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {            //定义每一个存储对象的大小            @Override            protected int sizeOf(String key, Bitmap bitmap) {                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;            }        };    }    //获取数据    public Bitmap getBitmap(String url) {        return mImageCache.get(url);    }    //存储数据    public void putBitmap(String url, Bitmap bitmap) {        mImageCache.put(url, bitmap);    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 九、SparseArray</span><br><span class="line">*  `SparseArray`是`android`里为`&lt;Interger,Object&gt;` 这样的`Hashmap`而专门写的类,目的是提高效率，其核心是折半查找函数（`binarySearch`）。` SparseArray  `仅仅提高内存效率，而不是提高执行效率，所以也决定它只适用于`android`系统（内存对android项目有多重要）`SparseArray`不需要开辟内存空间来额外存储外部映射，从而节省内存。</span><br><span class="line"></span><br><span class="line">* 变量,核心就是两个数组:`mKeys`  `mValues`</span><br></pre></td></tr></table></figure><p> //是否可以回收，即清理mValues中标记为DELETED的值的元素<br>    private boolean mGarbage = false;<br>    private int[] mKeys;        //保存键的数组<br>    private Object[] mValues;   //保存值的数组<br>    private int mSize;          //当前已经保存的数据个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法 ：如果`initialCapacity=0`那么`mKeys,mValuse`都初始化为`size=0`的数组，当`initialCapacity&gt;0`时，系统生成`length=initialCapacity`的`value`数组，同时新建一个同样长度的`key`数组。</span><br></pre></td></tr></table></figure></p><pre><code> public SparseArray() {    this(10);  }public SparseArray(int initialCapacity) {    if (initialCapacity == 0) {        mKeys = EmptyArray.INT;        mValues = EmptyArray.OBJECT;    } else {        /* ArrayUtils.newUnpaddedObjectArray 的源码   public static Object[] newUnpaddedObjectArray(int minLen) {   return (Object[])VMRuntime.getRuntime().newUnpaddedArray(Object.class, minLen);      }         */        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);        mKeys = new int[mValues.length];    }    mSize = 0;}</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于`put`方法,关键是通过二分查找，查找相对应的`i`角标,如果存在的话，直接赋值新的值，如果不存在的话，取 `~i` 位非运算符（`~`）: 十进制变二进制：原码--反码--加一（补码），相当于 value +1 然后 取反  就可以了.然后就会走到 ` mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);`和 ` mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);` 中，这样就完成了赋值的过程。</span><br></pre></td></tr></table></figure><p>   public void put(int key, E value) {<br>        // 二分查找，这个i的值,<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br>        //如果找到了，就把这个值给替换上去 ，或者是赋值上去<br>        //  这里 也就可以解释出为啥 替换为最新的值<br>        if (i &gt;= 0) {<br>            mValues[i] = value;<br>        } else {<br>            //这里就是key要插入的位置，上面二分查找方法提到过<br>            //位非运算符（~）<br>            i = ~i;<br>            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {<br>                mKeys[i] = key;<br>                mValues[i] = value;<br>                return;<br>            }</p><pre><code>        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {            gc();            // Search again because indices may have changed.            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);        }       // 一个新的值  ，就会把key 和 value 和 i值插入到两个数组中        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);        // todo    然后长度 加上 1   nice        mSize++;    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `get`方法:通过二分查找法，在`mKeys`数组中查询`key`的位置，然后返回`mValues`数组中对应位置的值，找不到则返回默认值</span><br></pre></td></tr></table></figure><p> public E get(int key, E valueIfKeyNotFound) {<br>  // 二分查找  感觉不像啊 卧槽<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</p><pre><code>    if (i &lt; 0 || mValues[i] == DELETED) {        return valueIfKeyNotFound;    } else {        return (E) mValues[i];    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `delete`其实就是把这个 `mValues[i]`标记为 `DELETED`.</span><br></pre></td></tr></table></figure><p>public void delete(int key) {<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br>       /<em><br>       i&gt;0表示，找到了key对应的下标，否则应该是负数。同时判断mValues[i] 是不是Object这个对象，如果不是，直接替换为Object（DELETE起到标记删除位置的作用）,并标记 mGarbage=true，注意：这里delete只操作了values数组，并没有去操作key数组;        </em>/<br>        if (i &gt;= 0) {<br>            if (mValues[i] != DELETED) {<br>                mValues[i] = DELETED;<br>                mGarbage = true;<br>            }<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* `removeReturnOld` 其实就是多了一步，把要删除的值返回，其余同`delete`一样</span><br></pre></td></tr></table></figure></p><pre><code> public E removeReturnOld(int key) {    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);    if (i &gt;= 0) {        if (mValues[i] != DELETED) {            final E old = (E) mValues[i];            mValues[i] = DELETED;            mGarbage = true;            return old;        }    }    return null;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `clear`  这里要留意，`clear`只是清空了`values`数组，并没有操作`keys`数组,这里也是传递的地址值，然后通过`for`循环，把每个元素清空！</span><br></pre></td></tr></table></figure><p>  public void clear() {<br>        int n = mSize;<br>        Object[] values = mValues;<br>        for (int i = 0; i &lt; n; i++) {<br>            values[i] = null;<br>        }<br>        mSize = 0;<br>        mGarbage = false;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 其实还有个方法`append`,添加数据的时候最好去使用它，因为它会判断下`mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]`、如果满足了才会调用 `put`方法，不满足，直接添加数据，而不是一上来就开始进行二分查找。</span><br></pre></td></tr></table></figure></p><p> // 要使用这个方法 好点 。<br>    public void append(int key, E value) {<br>        // 判断了是否 需要 二分查找，还是直接插入<br>        if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) {<br>            put(key, value);<br>            return;<br>        }</p><pre><code>    if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {        // 通过gc的方法，把DELETED值的 values 清空        gc();    }    // 可以直接都要这里来 ，是最节约能量    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);    mValues = GrowingArrayUtils.append(mValues, mSize, value);    mSize++;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于原型模式中的深拷贝的实现，这里也帮我指明了，一定要记得拷贝类中的容器</span><br></pre></td></tr></table></figure><p>  @Override<br>    @SuppressWarnings(“unchecked”)<br>    public SparseArray<e> clone() {<br>        SparseArray<e> clone = null;<br>        try {<br>            clone = (SparseArray<e>) super.clone();<br>            //  原型模式的深拷贝   两个容器的拷贝的过程—-！！！<br>            clone.mKeys = mKeys.clone();<br>            clone.mValues = mValues.clone();<br>        } catch (CloneNotSupportedException cnse) {<br>            /<em> ignore </em>/<br>        }<br>        return clone;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 其他的 `SparseBooleanArray  SparseIntArray SparseLongArray` 的原理一样</span><br><span class="line">*  `SparseArray`与`HashMap`无论是怎样进行插入,数据量相同时,前者都要比后者要省下一部分内存,但是效率呢？----在倒序插入的时候,`SparseArray`的插入时间和`HashMap`的插入时间远远不是一个数量级.由于`SparseArray`每次在插入的时候都要使用二分查找判断是否有相同的值被插入.因此这种倒序的情况是`SparseArray`效率最差的时候.</span><br><span class="line"></span><br><span class="line">* 附赠一个二分查找</span><br></pre></td></tr></table></figure></e></e></e></p><p> /**</p><pre><code> * 二分查找 * @param ints  需要被查找的数组 * @param length  数组的长度 * @param value  查找的值 */private int binarySearch(int[] ints, int length, int value) {    int i = 0;    int h = length - 1;    while (i &lt;= h) {        /**         * &gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用0填充。         * —比如你的例子，byte是8位的，-1表示为byte型是11111111(补码表示法）         * b&gt;&gt;&gt;4就是无符号右移4位，即00001111，这样结果就是15。         * 这里相当移动一位，除以二         */        //中间的角标        final int mid = (i + h) &gt;&gt;&gt; 1;// 第一次 2 第二次 mid=3 第三次mid=4        final int midVal = ints[mid];// 第一次 3 第二次 midVal=4 第三次mid=5        if (midVal &lt; value) {            i = mid + 1;// 第一次 3  第二次 i=4        } else if (value &lt; midVal) {            h = mid - 1;        } else if (value == midVal) {            return mid; //第三次mid=5 返回了        }    }    // 这个取反 ，相当于 value +1 然后 取反  就可以了    return ~value;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 附赠`System.arraycopy()` 的用法</span><br></pre></td></tr></table></figure><p> int[] mKeys={10,5,14,5,46};<br>       int[] newKeys=new int[5];<br>        /*</p><pre><code> * @param      src      源数组。 * @param      srcPos    表示源数组要复制的起始位置， * @param      dest     目的地数组。 * @param      destPos  在目标数据中的起始位置。 * @param      length   要复制的数组元素的数目。 */// todo  source of type android.util.SparseArray is not an array// destPsot +length  不能超过 新的数组的长度System.arraycopy(mKeys,0, newKeys, 2, 3);for (Integer str : newKeys) {    System.out.print(&quot;newKeys=&quot;+str+&quot;   &quot;);}</code></pre><p><code>`</code></p><h4 id="最后说明几点"><a href="#最后说明几点" class="headerlink" title="最后说明几点"></a>最后说明几点</h4><ul><li><code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</li><li><code>ArrayList</code>遍历的速度快，插入删除速度慢，随机访问的速度快</li><li><code>LinkedList</code> 插入，删除都是移动指针效率很高。查找需要进行遍历查询，效率较低。二分查找，如果查找的index的越接近size的一半的话，这样查找的效率很低</li><li><code>HashMap</code> 是一个线程不安全的容器，发生扩容时会出现环形链表从而导致死循环</li><li><code>HashMap</code> 是一个无序的 <code>Map</code>，因为每次根据 <code>key</code>的 <code>hashCode</code>映射到<code>Entry</code> 数组上，所以遍历出来的顺序并不是写入的顺序。</li><li><code>HashMap</code> 遍历的速度慢，底层决定了，插入删除的速度快，随机访问的速度也比较快</li><li><code>ConcurrentHashMap</code> 并发容器，区别就是采用了CAS + synchronized 来保证并发安全性</li><li>位与运算符<code>&amp;</code>,把做运算的两个数都转化为二进制的，然后从高位开始比较，如果两个数都是<code>1</code>则为<code>1</code>，否者为<code>0</code></li><li>无符号的右移（<code>&gt;&gt;&gt;</code>）:按照二进制把数字右移指定数位，高位直接补零，低位移除！ </li><li><code>a=a|b</code> 等于 <code>a|=b</code>的意思就是把<code>a</code>和<code>b</code>按位或然后赋值给<code>a</code> 按位或的意思就是先把<code>a</code>和<code>b</code>都换成<code>2</code>进制，然后用或操作<ul><li>位异或运算（<code>^</code>）: 运算规则是两个数转为二进制，然后从高位开始比较，如果相同则为<code>0</code>，不相同则为<code>1</code></li><li><code>HashSet</code> 底层其实就是 <code>HashMap</code>，只不过是一个<code>value</code>都一样的<code>HashSet</code>.</li><li><code>LRU（Least Recently Used）</code>最近最少使用的，看了源码才知道核心是<code>LRUCache</code>类，这个类的核心其实是 <code>LinkedHashMap</code>类.</li></ul></li><li><code>~i</code> 位非运算符（<code>~</code>）: 十进制变二进制：原码–反码–加一（补码），相当于 value +1 然后 取反  就可以了</li><li><code>SparseArray</code> <code>SparseBooleanArray  SparseIntArray SparseLongArray</code> 的原理一样</li><li><code>SparseArray</code>与<code>HashMap</code>无论是怎样进行插入,数据量相同时,前者都要比后者要省下一部分内存,但是效率呢？—-在倒序插入的时候,<code>SparseArray</code>的插入时间和<code>HashMap</code>的插入时间远远不是一个数量级.由于<code>SparseArray</code>每次在插入的时候都要使用二分查找判断是否有相同的值被插入.因此这种倒序的情况是<code>SparseArray</code>效率最差的时候.</li><li>二分查找，是当角标越接近数组长度的一半，效率越低</li><li>卧槽，刚看了一下总共将近一万字，光写的过程用了16个小时，整理资料大概是10个小时。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> ArrayList </tag>
            
            <tag> Vector </tag>
            
            <tag> LinckedList </tag>
            
            <tag> HashMap </tag>
            
            <tag> HashSet </tag>
            
            <tag> LinkedHashMap </tag>
            
            <tag> LruCache </tag>
            
            <tag> SparseArray </tag>
            
            <tag> ConcurrentHashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo+GitHub+阿里域名搭建自己博客</title>
      <link href="/2018/08/14/Hexo-GitHub-%E9%98%BF%E9%87%8C%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2/"/>
      <url>/2018/08/14/Hexo-GitHub-%E9%98%BF%E9%87%8C%E5%9F%9F%E5%90%8D%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><ul><li>博客的地址：<a href="http://www.shiming.site/" target="_blank" rel="noopener">我的博客</a><a id="more"></a><ul><li>PC端的效果<br><img src="https://upload-images.jianshu.io/upload_images/5363507-ba3860adcb584a57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="PC端的效果"></li><li>手机端效果<br><img src="https://upload-images.jianshu.io/upload_images/5363507-ad4a55e07594b58a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机端效果一"></li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-c5ae27aabcc81fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机端效果二"></p><ul><li>最近抽空终于搭建完成，网上的资料很多，这篇文章只记录下遇到的问题，如果你想搭建一个博客！可能对你有些帮助。</li></ul><h2 id="Hexo-GitHub"><a href="#Hexo-GitHub" class="headerlink" title="Hexo+GitHub"></a>Hexo+GitHub</h2><ul><li>现在网络上很多，有好多的文章写得很好，在这里推荐两篇文章！只要按照这步骤来，基本上都可以完成!没有什么技术的难度，就是体力活☺☺☺<ul><li><a href="https://blog.csdn.net/u011974987/article/details/51331822/" target="_blank" rel="noopener">基于Hexo+GitHub Pages 搭建博客详细教程</a></li><li><a href="https://www.jianshu.com/p/465830080ea9" target="_blank" rel="noopener">HEXO+Github,搭建属于自己的博客</a></li></ul></li></ul><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ul><li>域名我是在阿里云上买的 <a href="https://wanwang.aliyun.com/?spm=5176.8142029.735711.56.a72376f4MMmf6X" target="_blank" rel="noopener">阿里云</a> </li><li>输入你想要买的域名地址，如图所示!选择一个您觉得合适的域名，加入到清单，然后购买就可以了<br><img src="https://upload-images.jianshu.io/upload_images/5363507-bbd42440357260be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="域名"><ul><li>这个是阿里云的代金券！<a href="https://promotion.aliyun.com/ntms/yunparter/invite.html?userCode=ikk1hmxh" target="_blank" rel="noopener">阿里云代金券</a></li><li>购买成功了，进入域名控制台<br><img src="https://upload-images.jianshu.io/upload_images/5363507-b2dfbb9ab09bd1d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制台"></li><li>点击解析设置，然后添加记录，就会出现下面的窗口<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a1df65f662543ba9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置"></li><li>设置值，结果如下<br><img src="https://upload-images.jianshu.io/upload_images/5363507-55824b1a93001047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置结果"></li></ul></li><li>这个记录值是什么？如图所示，其实就是 ：<code>https://shimingli.github.io/</code> 的<code>ip</code>值，当然你需要设置成你的<br><img src="https://upload-images.jianshu.io/upload_images/5363507-eca8fae000cea2c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><ul><li>设置完成了，还有关键的一步，就是实名认证，认证通过了，域名才可以使用。</li></ul></li></ul><h2 id="GitHub-Pages的设置"><a href="#GitHub-Pages的设置" class="headerlink" title="GitHub Pages的设置"></a><code>GitHub Pages</code>的设置</h2><ul><li>进入到 <code>name.github.io</code>的工程目录下，然后进入到<code>Settings</code>,最后定位到<code>Github Pages</code>的选项,输入你自己购买的域名，我这域名 7块一年，物超所值！<br><img src="https://upload-images.jianshu.io/upload_images/5363507-87e99bbe6ab338b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="settings"></li></ul><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><ul><li><a href="https://www.zhihu.com/question/24422335" target="_blank" rel="noopener">有哪些好看的Hexo主题</a></li><li>个人看了几个，我还是比较喜欢这个 <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" rel="noopener">Yelee</a>。感觉比较闷骚</li><li><p><code>clone</code>到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/MOxFIVE/hexo-theme-yelee.git themes/yelee</span><br></pre></td></tr></table></figure></li><li><p>使用的步骤建议参考 官方的文档，非常的详细 <a href="http://moxfive.coding.me/yelee" target="_blank" rel="noopener">Yelee 主题使用说明 [简中] </a><br><img src="https://upload-images.jianshu.io/upload_images/5363507-749dd96e0302437f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构"></p><ul><li><code>public</code>:<code>pull</code>到<code>Github</code></li><li><code>themes</code>：博客的主题`<ul><li><code>soure</code>：就是文章存放的地方</li></ul></li></ul></li><li><p>然后把<code>clone</code>的<code>yelee</code>放到<code>themes</code>目录下</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-18d0bbbd77f7c421.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>在博客的根目录下设置<code>theme: Yelee</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: Yelee</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-c1433f718015480e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置"></p><h2 id="Hexo-几个常用的命令"><a href="#Hexo-几个常用的命令" class="headerlink" title="Hexo 几个常用的命令"></a><code>Hexo</code> 几个常用的命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">hexo server (hexo s) 启动本地web服务，用于博客的预览</span><br><span class="line">hexo deploy (hexo d) 部署博客到远端服务器</span><br><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br></pre></td></tr></table></figure><ul><li><p>简写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></table></figure></li><li><p>如果一切配置ok的话，打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 就可以看到刚才搭建的本地博客了，Hexo会默认生成一个Hello World的博文。</p></li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><ul><li><code>Hexo</code>中的<code>Yelee</code>主题，首页不显示文章,需要把<code>themes</code>中的文件<code>_config.yml</code>的<code>search</code>中的<code>on: true</code>的注释去掉，同时必须注释掉<code>onload</code>，同时需要去安装插件!,然后就可以检索了。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Local Site Search | 本地站内搜索</span><br><span class="line">## Insatall below plugin to take effect | 使用搜索需先安装对应插件</span><br><span class="line">## https://github.com/PaicHyperionDev/hexo-generator-search</span><br><span class="line">search: </span><br><span class="line">  on: true</span><br><span class="line">  #onload: false     （Hexo中的Yelee主题，首页不显示文章）</span><br><span class="line">  ## true: get search.xml file when the page has loaded</span><br><span class="line">  ## false: get the file when search box gets focus</span><br></pre></td></tr></table></figure></li></ul><h4 id="再来一个好玩的，如何统计网页的访问量？如下图所示，请忽略我的可怜的访问量？"><a href="#再来一个好玩的，如何统计网页的访问量？如下图所示，请忽略我的可怜的访问量？" class="headerlink" title="再来一个好玩的，如何统计网页的访问量？如下图所示，请忽略我的可怜的访问量？"></a>再来一个好玩的，如何统计网页的访问量？如下图所示，请忽略我的可怜的访问量？</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4af81e030d02f92c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="访问量"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-683a8f05531721ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li><p>在<code>yelee</code> 主题下的 <code>_config.yml</code>文件中，有个百度统计</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#   百度统计</span><br><span class="line"># 百度统计 http://sitecenter.baidu.com/sc-web/</span><br><span class="line"># 查看代码，填入 //hm.baidu.com/hm.js? 之后的内容     </span><br><span class="line">baidu_tongji:</span><br></pre></td></tr></table></figure></li><li><p>登录注册后填写网站,然后获取代码</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-6092eaba96e7c1d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度统计.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-b3cce935c7a79442.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="获取代码的详情"></p><ul><li><p>这是我的获取代码的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt = _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">  var hm = document.createElement(&quot;script&quot;);</span><br><span class="line">  hm.src = &quot;https://hm.baidu.com/hm.js?1add6c64d9c467153aaed18d249d81c4&quot;;</span><br><span class="line">  var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br></pre></td></tr></table></figure></li><li><p>把这一串东西 <code>1add6c64d9c467153aaed18d249d81c4</code>放到百度统计一栏，即可。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-865d469abea10fea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="百度统计"></p></li><li><p>然后 <code>hexo g</code> <code>hexo s</code> <code>hexo d</code> ,然后<code>push</code>到 <code>GitHub</code>.他会自动的检测代码。</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 阿里域名 </tag>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 9 Pie 正式版总结</title>
      <link href="/2018/08/14/Android-9-Pie-%E6%AD%A3%E5%BC%8F%E7%89%88%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/14/Android-9-Pie-%E6%AD%A3%E5%BC%8F%E7%89%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul><li>先声明下，以下的整理的资料一部分来源于公众号<code>谷歌开发者</code>,一部分来源于<a href="https://developer.android.google.cn/" target="_blank" rel="noopener">谷歌安卓官方网站</a>（不用翻墙，gogogo），还有小部分自己的理解。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-88fbec19dcb39405.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android 9"><a id="more"></a></li><li>微信公众号号<code>谷歌开发者</code>推送了 <code>Android 9 Pie 现已面向全球正式发布！</code>,就去更新 <code>Android API 28</code>,想看看正式版那些功能，就发生了如下的故事 </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-246697c1c7a1fd7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="钉钉工作群"><br>这是我的电脑<code>IP</code>地址<br><img src="https://upload-images.jianshu.io/upload_images/5363507-2570704afb0266ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的电脑IP.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-981c91a3d7305557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和领导的聊天记录"></p><ul><li>然后我的电脑就被限制速度了，为了同事们能够好好工作，现在模拟器镜像都不能下载了！哈哈</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4fdf1483b6f645f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>虽然不能完成<code>Android 9</code>有些 <code>api</code>的具体的效果，先mark下，后续再来添上</p></li><li><p>今天我终于把<code>API 28</code>的源码下载下来了。哈哈！<br>##动态电量管理</p><h4 id="1、应用待机分组"><a href="#1、应用待机分组" class="headerlink" title="1、应用待机分组"></a>1、应用待机分组</h4><ul><li>Android P 新增加应用待机分组的功能，让系统根据用户的使用情况而限制应用调用CPU或网络等设备的资源, 应用待机分组是 Android P 新添加的一项电量管理功能，它能根据应用的使用频率或者最近一次使用时间，对其资源请求进行优先级排序！</li><li>优先分组   在默认的情况下，系统会更具应用的近期的使用的情况进行等级划分，应用活跃度越高，所处的分组优先级就越高，也更加容易获取设备的资源；第二种是系统安装了通过利用机器学习预加载的应用，从而预测各个应用的使用概率，然后将他们编配值相应的群组，在我朝手机设备厂商应该不会是这种。设备厂商可以自行规定非活跃应用的群组划分规则(我朝特色，厂商白名单)。请开发者不要试图篡改应用所处的群组，而是专注于改善应用行为，确保应用被划分至目标群组后，依旧能够顺利运行（小公司，好好提升技术，）<h5 id="5个分组如下-活跃-Active-、工作-Working-set-、-常用-Frequent-、-极少-Rare-、应用偶尔被使用-App-is-not-frequently-used"><a href="#5个分组如下-活跃-Active-、工作-Working-set-、-常用-Frequent-、-极少-Rare-、应用偶尔被使用-App-is-not-frequently-used" class="headerlink" title="5个分组如下  活跃 (Active)、工作 (Working set)、 常用 (Frequent)、 极少 (Rare)、应用偶尔被使用 (App is not frequently used)"></a>5个分组如下  活跃 (Active)、工作 (Working set)、 常用 (Frequent)、 极少 (Rare)、应用偶尔被使用 (App is not frequently used)</h5></li><li><p><code>活跃 (Active)</code>: 应用正在被使用 （每个应用都可以）<br>1、启动了一个Activity<br>2、正在运行的前台服务<br> 3、另外一个应用已关联该应用<br>4、 用户点击了推送</p></li><li><p><code>工作 (Working set)</code>: 应用使用频率很高<br>1、若应用的运行频率很高，但目前并未处于“活跃”状态，它就会被划分至工作群组，例如用户常用的社交媒体应用。此外，该群组还包括了那些被间接使用的应用。微信 QQ 支付宝 ，工作分组内的应用任务（Job）运行和闹铃受到系统的部分限制</p></li><li><p><code>常用 (Frequent)</code>: 应用经常但不是每天被使用<br>常用应用指用户经常使用但不是每天使用的应用，比如用户在健身房使用的打卡应用可能就属于这一群组。跑步的APP系统对常用分组采用的限制更强，应用运行任务(job)和触发闹铃的能力都会受到影响，而且接受的高优先性FCM消息也有数量上限</p></li></ul></li></ul><ul><li><p><code>极少 (Rare)</code>: 应用偶尔被使用</p><pre><code>若应用的使用频率很低，它就会被划分至该分组，(比如说你去某个地方，订酒店之类的APP，)该群组下的应用在任务 (job)、闹铃和高优先性FCM消息的资源调用上都会受到严格的限制。此外，网络访问能力也会受到影响</code></pre></li><li><p><code>应用偶尔被使用 (App is not frequently used)</code><br>安装后一次都未被使用过的应用将被划分至 “从不” 这一特殊群组，并受到十分严格的系统限制  我们自己的手机上有这种的App 很多</p><ul><li>我们做应用层<code>APP</code>应该怎么应对这几种分组 ？    </li><li>每个模式下，都能打开APP，确保App不能炸掉</li><li>要确保有启动的 Launcher Activity，如果没有的话，有可能你的应用不会切换到活跃分组</li><li>推送的消息要具有可操作性，这个的意思就是说，点了通知栏要跳到应用去</li><li>若应用在接受高优先级的 FCM 消息之后未能发送推送，用户将无法与应用产生互动并将其优先级提升至 “活跃” 等级。</li><li>如果用户多次忽略某个App的推送，系统会去询问用户是否不再接受此推送 。所以不要乱去推送，为了保持活跃群组!</li></ul></li></ul><ul><li><p>后台的限制 （微信经常这样）当系统检测到应用消耗过多的资源时，系统会发通知询问用户是否需要限制该应用的后台的活动<br>1、第一中期情况是，频繁使用唤醒锁 (wake locks)：屏幕关闭后，局部唤醒锁 (Partial wake lock) 连续开启 1 小时；<br>2、过多的后台服务：当应用目标 API 等级低于 26，且运行过多后台服务。</p></li><li><p>Android P 进一步提升了省电模式的性能。需要由设备的厂商来决定采用的具体的限制<br>作为开发者 我们自己，我们需要在省电模式下测试应用。确保自己的应用能够安全的上线和运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//使用 Android Debug Bridge 命令 https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046811&amp;idx=1&amp;sn=f0340e6fabb07a3ee40db45bdd58e7b0&amp;chksm=808ca59eb7fb2c883c6ae99be7c84460f48886cd79bb0de886a5bac84afa2d8050a58339cc89&amp;scene=21#wechat_redirect</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、后台限制"><a href="#2、后台限制" class="headerlink" title="2、后台限制"></a>2、后台限制</h4><ul><li><code>Android P</code>新增后台限制功能，如果应用出现 <code>Android Vitals</code> 里面所描述的行为，系统将提醒用户限制该应用的访问设备的资源!</li><li><code>Android Vitals</code>:是谷歌提高Android设备稳定性和性能的一项举措。当选择的用户运行你的应用程序时，他们的Android设备记录各种度量，包括关于应用程序稳定性、应用程序启动时间、电池使用时间、渲染时间和权限拒绝的数据。谷歌播放控制台聚集这些数据并将其显示在Android虚拟仪表板中。仪表板突出了崩溃率、ANR率、过度唤醒和卡尾锁：这是开发人员应该关注的核心。所有其他的vitals，当适用于你的APP或游戏类型时，都应该被监控，以确保它们不会产生负面影响。如果产生了，应用的商店被发现的可能性低，说到底的意思就是，垃圾应用，我不帮你推荐!</li></ul><h4 id="3、省电模式的优化"><a href="#3、省电模式的优化" class="headerlink" title="3、省电模式的优化"></a>3、省电模式的优化</h4><ul><li>Android P 优化了现在的省电助手的功能，在启动该功能后，系统将对所有的后台运行实施加以限制</li></ul><h4 id="4、低耗能模式，-当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android-P并没有针对低电耗模式做出改变"><a href="#4、低耗能模式，-当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android-P并没有针对低电耗模式做出改变" class="headerlink" title="4、低耗能模式， 当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android P并没有针对低电耗模式做出改变."></a>4、低耗能模式， 当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。<code>Android P</code>并没有针对低电耗模式做出改变.</h4><ul><li>低耗电模式:   低电耗模式通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络 Activity 来减少电池消耗。应用待机模式可推迟用户近期未与之交互的应用的后台网络 Activity. 如果用户设备未插接电源、处于静止状态一段时间且屏幕关闭，设备会进入低电耗模式。 在低电耗模式下，系统会尝试通过限制应用对网络和 CPU 密集型服务的访问来节省电量。 这还可以阻止应用访问网络并推迟其作业、同步和标准闹铃.一旦用户通过移动设备、打开屏幕或连接到充电器唤醒设备，系统就会立即退出低电耗模式，并且所有应用都将返回到正常 Activity。</li><li>有个例子。手机设备8.0上，打开视频APP下载视屏，关闭屏幕，一会视屏App就会关闭，在以前的版本不会出现，这就是低电耗模式!</li></ul><h4 id="5、Slices-App-Actions"><a href="#5、Slices-App-Actions" class="headerlink" title="5、Slices  App Actions"></a>5、Slices  App Actions</h4><ul><li>Google 想要透过<code>Action</code>和 <code>Slice</code> 这两个功能让使用者减少操作动作，让应用程式和操作行为更紧密结合，把以前需要操作四五下才能完成的事减少到操作两三下或是操作一下就能自动完成。</li><li><code>App Actions</code>是一种全新的应用推荐的方式，它能够对应用语义意图和使用场景进行分析，并根据分析结果在适当的时机向用户推荐应用,比如说在用户插入耳机的时候，推荐开启 音乐<code>App</code> 等等 —&gt;谷歌没有公布使用的方式  </li><li><code>Slice</code>: 的概念则是 Google Assistant 的延伸，让使用者能快速使用到 app 里的某个特定功能，只要开发者导入 Slice 功能，使用者在使用搜寻、Google Play 商店、Google Assitant 或其他内建功能时都会出现 Slice 的操作建议。在<code>go</code>语言中 有个叫切片<code>slice</code>，它的意思是：在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code>.</li></ul><h4 id="6、文本识别与-Smart-Linkify"><a href="#6、文本识别与-Smart-Linkify" class="headerlink" title="6、文本识别与 Smart Linkify"></a>6、<a href="https://developer.android.google.cn/reference/android/view/textclassifier/package-summary" target="_blank" rel="noopener">文本识别与 Smart Linkify</a></h4><ul><li>在 Android 9 中，我们对识别文本的机器学习模型进行了扩展，使其可以借助 TextClassifier API 识别出类似日期或航班号这样的信息。此外， Smart Linkify 允许开发者通过 Linkify API 使用文本识别模块完成多项操作，比如对用户可采取的操作提出建议。Smart Linkify 让系统在文本识别精确度与速度上都有明显的提升。</li><li>TextClassifier  后续更新下Demo  研究中<br><img src="https://upload-images.jianshu.io/upload_images/5363507-085482fa43bb2721.gif?imageMogr2/auto-orient/strip" alt="demo.gif"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   TextClassifier API</span><br><span class="line">  https://developer.android.google.cn/reference/android/view/textclassifier/package-summary</span><br><span class="line"> Linkify API</span><br><span class="line">https://developer.android.google.cn/reference/android/text/util/Linkify</span><br></pre></td></tr></table></figure><h4 id="7、神经网络-API-1-1"><a href="#7、神经网络-API-1-1" class="headerlink" title="7、神经网络 API 1.1"></a>7、<a href="https://developer.android.google.cn/ndk/guides/neuralnetworks/index.html" target="_blank" rel="noopener">神经网络 API 1.1</a></h4><ul><li><code>Android 9.0</code> 对神经网络 API 进行了扩展与改进，进一步优化 Android 对机器学习硬件加速的支持。神经网络 API 1.1 共增加了对 9 个新算子的支持，它们分别是<code>Pad、BatchToSpaceND、SpaceToBatchND、Transpose、Strided Slice、Mean、Div、Sub 和 Squeeze。TensorFlow Lite</code>就是一个已经用上此 API 的典型机器学习框架。</li></ul><h2 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h2><h4 id="1、全新系统导航"><a href="#1、全新系统导航" class="headerlink" title="1、全新系统导航"></a>1、全新系统导航</h4><ul><li><code>Android 9</code>迎来了全新的系统导航，让多任务切换及关联应用探索变得更加简单。您只需要向上滑动屏幕就可以全屏预览最近使用过的应用，轻触预览页后便可以切换至所选应用。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-57240ac05547289b.gif?imageMogr2/auto-orient/strip" alt="全新系统导航.gif"></p><h4 id="2、-凹口屏支持"><a href="#2、-凹口屏支持" class="headerlink" title="2、 凹口屏支持"></a>2、 <a href="https://developer.android.google.cn/guide/topics/display-cutout/" target="_blank" rel="noopener">凹口屏支持</a></h4><ul><li>想起来 苹果大佬 还是牛逼，刘海是为了屈服某种硬件的缺陷，然后谷歌就开始支持了</li><li><code>Android 9</code> 中加入了凹口屏支持，让您的应用可以充分利用最新全面屏，展现应用的独特魅力。该功能可以在大部分应用中无缝工作，系统会通过调整状态栏高度将应用内容与屏幕缺口区域分开。如果您的应用含有沉浸式内容，您可调用<code>display cutout APIs</code> 确认缺口形状与位置，然后请求围绕缺口进行全屏布局。另外，我们还加入了开发者选项来模拟任意设备上的凹口形状，从而极大简化了应用支持凹口屏幕所需的构建以及测试流程。<h4 id="3、-通知与智能回复"><a href="#3、-通知与智能回复" class="headerlink" title="3、 通知与智能回复"></a>3、 通知与智能回复</h4></li><li><code>Android 9</code> 进一步改善了通知的实用性与可操作性。消息类应用可以调用新的 <code>MessagingStyle API</code> 来显示对话，附加照片和表情，或者提供智能回复建议。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create new Person.  完蛋了，这下在安卓中Person类有了，不仅仅是一个了</span><br><span class="line">   val sender = Person()</span><br><span class="line">           .setName(name)</span><br><span class="line">           .setUri(uri)</span><br><span class="line">           .setIcon(null)</span><br><span class="line">           .build()</span><br><span class="line"> // Create image message.</span><br><span class="line">   val message = Notification.MessagingStyle.Message(&quot;Picture&quot;, time, sender)</span><br><span class="line">           .setData(&quot;image/&quot;, imageUri)</span><br><span class="line">   val style = Notification.MessagingStyle(getUser())</span><br><span class="line">           .addMessage(&quot;Check this out!&quot;, 0, sender)</span><br><span class="line">           .addMessage(message)</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、文本放大镜"><a href="#4、文本放大镜" class="headerlink" title="4、文本放大镜"></a>4、<a href="https://developer.android.google.cn/reference/android/widget/Magnifier" target="_blank" rel="noopener">文本放大镜</a></h4><ul><li>Android 9 中添加文字放大镜工具 (Magnifier widget)，以提升文本选择方面的用户体验。由于该放大器提供了可以在文本上方拖拽的文本放大面板，所以有助于用户精准地定位光标或文本选择手柄。该功能可以灵活运用在所有附加在窗口的视图上，个性化小部件和定制文本呈现均是不错的应用场景。</li><li>该放大器工具还可以提供任何视图或界面的放大版本，而不仅仅是文本。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-1298304aefb3084e.gif?imageMogr2/auto-orient/strip" alt="文本放大.gif"></li></ul><h2 id="用户安全与隐私"><a href="#用户安全与隐私" class="headerlink" title="用户安全与隐私"></a>用户安全与隐私</h2><h4 id="1、统一身份验证对话框"><a href="#1、统一身份验证对话框" class="headerlink" title="1、统一身份验证对话框"></a>1、统一身份验证对话框</h4><ul><li><p>为了保障用户在不同甘银强和应用之间能够获得一致的体验，Android P 引入了统一的身份验证对话框，提醒用户进行操作。应用可以不自行的设计，该API还支持面部识别<code>虹膜识别技术</code> 是基于眼睛中的虹膜进行身份识别，应用于安防设备（如门禁等），以及有高度保密需求的场所。</p><ul><li>优点<br>1．便于用户使用；<br>2．可能会是最可靠的生物识别技术；.<br>3．不需物理的接触；<br>4．可靠性高。</li><li>缺点<br>1．很难将图像获取设备的尺寸小型化；<br>2．设备造价高，无法大范围推广；<br>3．镜头可能产生图像畸变而使可靠性降低；<br>4．两大模块：硬件和软件；<br>5．一个自动虹膜识别系统包含硬件和软件两大模块：虹膜图像获取装置和虹膜识别算法。分别对应于图像获取和模式匹配这两个基本问题。</li></ul></li></ul><ul><li>代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// TODO 一定要在 API 28的模拟器上跑 要不然 app 会直接奔溃掉</span><br><span class="line">       val BiometricPrompt = BiometricPrompt.Builder(this)</span><br><span class="line">               .setTitle(&quot;指纹验证&quot;)</span><br><span class="line">               .setDescription(&quot;描述&quot;)</span><br><span class="line">               .setNegativeButton(&quot;取消&quot;, mainExecutor, DialogInterface.OnClickListener &#123; dialogInterface, i -&gt; Log.i(UserSecurityAndPrivacyActivity@ this.localClassName, &quot;Cancel button clicked&quot;) &#125;)</span><br><span class="line">               .build()</span><br><span class="line">       val mCancellationSignal = CancellationSignal()</span><br><span class="line">       mCancellationSignal.setOnCancelListener &#123;</span><br><span class="line">           CancellationSignal.OnCancelListener &#123;</span><br><span class="line">               fun onCancel() &#123;</span><br><span class="line">                   println(&quot;取消了啊&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       val mAuthenticationCallback = object : BiometricPrompt.AuthenticationCallback() &#123;</span><br><span class="line">           override fun onAuthenticationError(errorCode: Int, errString: CharSequence) &#123;</span><br><span class="line">               super.onAuthenticationError(errorCode, errString)</span><br><span class="line">               println(&quot;发生了 错误了啊&quot;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) &#123;</span><br><span class="line">               super.onAuthenticationSucceeded(result)</span><br><span class="line">               println(&quot;发生了 成功了啊&quot;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           override fun onAuthenticationFailed() &#123;</span><br><span class="line">               super.onAuthenticationFailed()</span><br><span class="line">               println(&quot;发生了 失败了&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       BiometricPrompt.authenticate(mCancellationSignal, mainExecutor, mAuthenticationCallback)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、Android-Protected-Confirmation"><a href="#2、Android-Protected-Confirmation" class="headerlink" title="2、Android Protected Confirmation"></a>2、<a href="https://developer.android.google.cn/preview/features/security#android-protected-confirmation" target="_blank" rel="noopener">Android Protected Confirmation</a></h4><ul><li>安卓保护确认：运行Android 9或更高版本的支持设备使您有能力使用Android保护的确认。使用此工作流时，应用程序向用户显示提示，要求用户批准简短语句。这个声明允许应用程序重新确认用户希望完成一个敏感的交易，例如支付。</li></ul><h4 id="3、KeyStore-加强密钥安全保护"><a href="#3、KeyStore-加强密钥安全保护" class="headerlink" title="3、KeyStore 加强密钥安全保护"></a>3、<code>KeyStore</code> <a href="https://link.juejin.im?target=https%25253A%25252F%25252Fdeveloper.android.google.cn%25252Fpreview%25252F" target="_blank" rel="noopener">加强密钥安全保护</a></h4><ul><li>加入了一个新的<code>KeyStore</code> 类 —— <code>StrongBox</code>，并提供相应的 API 来支持那些提供了防入侵硬件措施的设备，比如独立的 CPU，内存以及安全存储。</li></ul><p>####4、 DNS over TLS 基于TLS的DNS</p><ul><li>大多的网络连接 –DNS查询–》返回IP地址–》客服端就能连接上网页了。互联网的大佬们一直在致力于新的NDS的协议的开发，该协议就是NDS over  TLS协议     <code>TLS</code>：安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性<ul><li><code>Android  P</code> 正式版内置对 <code>DNS over TLS</code>的支持，在 “网络和互联网” 设置中添加了隐私 DNS (Private DNS) 模式。</li><li>NS over TLS 模式自动为所有系统上的应用提供安全 DNS查询。不过，若应用未使用系统 API，而是自行运行 DNS 查询，它们必须确保在系统进行安全连接情况下，不发送不安全的 DNS 查询。应用可以调用新的 API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkProperties.isPrivateDnsActive()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5、Android-P默认使用了HTTPS"><a href="#5、Android-P默认使用了HTTPS" class="headerlink" title="5、Android P默认使用了HTTPS"></a>5、<code>Android P</code>默认使用了<code>HTTPS</code></h4><h4 id="6、基于编译器的安全缓解措施"><a href="#6、基于编译器的安全缓解措施" class="headerlink" title="6、基于编译器的安全缓解措施"></a>6、基于编译器的安全缓解措施</h4><ul><li><code>Android 9</code> 将进一步扩展编译器级别的安全缓解措施，借助运行时危险行为监测进一步加强平台安全建设。<code>Android 9</code>通过控制流程完整性 <code>(CFI)</code> 技术解决了代码重用<code>(code-reuse)</code>和任意代码执行两大漏洞，并扩展了<code>CFI</code>在媒体框架和其它关键安全组件内的使用范围，如<code>NFC</code> 与蓝牙。同时，<code>Android 9</code>还针对 <code>Android</code> 常见内核的 <code>LLVM</code> 编译添加了 <code>CFI</code>内核支持。</li></ul><h4 id="7、用户隐私"><a href="#7、用户隐私" class="headerlink" title="7、用户隐私"></a>7、用户隐私</h4><ul><li><code>Android 9</code>新加入多项机制，进一步加强了对用户隐私的保护。系统禁止所有处于空闲状态的应用对话筒、摄像头和所有 <code>SensorManager</code>传感器的访问。当应用的 <code>UID</code> 空闲时，麦克风将会报告 “无音频信号”，传感器将会停止报告事件，应用使用的摄像头也会断开连接，并在应用试图访问时生成错误。在大多数情况下，这些限制不会对现有应用造成新的问题，谷歌建议从应用中移除此类传感器请求。</li><li><code>Android 9</code> 还让用户控制是否允许访问平台<code>build.serial</code>识别码 (它被 READ_PHONE_STATE 权限保护) ,设备的唯一标识<code>the hardware serial number</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取硬件序列号，如果可用的话。</span><br><span class="line">    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        //注意需要在 高版本的 SDK的手机上运行</span><br><span class="line">        val serial = Build.getSerial()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="摄像和影音的全面升级"><a href="#摄像和影音的全面升级" class="headerlink" title="摄像和影音的全面升级"></a>摄像和影音的全面升级</h2><h4 id="1、多摄像头的API的改进-–-gt"><a href="#1、多摄像头的API的改进-–-gt" class="headerlink" title="1、多摄像头的API的改进 –&gt;"></a>1、多摄像头的API的改进 –&gt;</h4><ul><li>从 Android 9 开始，您可以在支持多摄像头 API 的设备上通过两个或更多实体摄像头同时访问视频流；在配有双前置或双后置摄像头的设备上，实现单摄像头无法实现的创新功能：如无缝变焦、散景和立体视觉。该 API 还允许您调用可以在两台或更多台摄像头之间自动切换的逻辑或混合摄像头视频流。</li></ul><h4 id="2、使用动态处理增强音频–-gt-降噪技术"><a href="#2、使用动态处理增强音频–-gt-降噪技术" class="headerlink" title="2、使用动态处理增强音频–&gt;降噪技术"></a>2、使用动态处理增强音频–&gt;降噪技术</h4><ul><li>iPhone手机的降噪技术：双麦克风降噪技术，即手机中内置的两个麦克风，一个保持清晰通话，另一个麦克风从物理上主动消除噪音，通过收集外界的噪声，运用内部算法进行处理后，发出与噪音相反的声波，利用抵消原理消除噪音。其他手机估计也差不多！</li><li>开发者可以调用 <code>Dynamics Processing API</code>对音频进行动态处理，通过分离出特定频率的声音，降低过大的音量，或者增强过小的音量，来改善应用的音频质量。比如说，即便说话者声音小，离麦克风远，而且外界环境十分嘈杂，您的应用依然可以有效捕捉并他/她的声音，并进行相应优化。该 API 提供了多声场、多频段的动态处理效果，包括一个预均衡器、一个多频段压缩器，一个后均衡器以及一个串联的音量限制器。<h4 id="3、ImageDecoder-API"><a href="#3、ImageDecoder-API" class="headerlink" title="3、ImageDecoder API"></a>3、ImageDecoder API</h4></li><li><code>ImageDecoder</code> 通过一种更为简单的方式将图像解码为位图或 <code>drawable</code>。<code>ImageDecoder</code> 允许您从字节缓冲区、文件或 URI 创建位图或 drawable。它相比<code>BitmapFactory</code>有以下几个优势：支持精确缩放，支持单步解码至硬件存储器，支持解码后处理，以及动画图像解码。</li><li><p><code>ImageDecoder</code>:一个的可以将<code>PNG, JPEG, WEBP, GIF, or HEIF</code>格式的图片的转换成<code>Drawable</code> 或者<code>Bitmap</code>对象的类。</p><ul><li><p>1、正常的使用:得到<code>drawable</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val file =File(&quot;filename&quot;)</span><br><span class="line">      val source = ImageDecoder.createSource(file)</span><br><span class="line">      val drawable = ImageDecoder.decodeDrawable(source)</span><br></pre></td></tr></table></figure></li><li><p>2、传递<code>OnHeaderDecodedListener</code>，这里<code>ImageInfo</code>存放的是原始的图片的宽和高。可以修改用来修改图片宽高的时候修改<code>SampleSize</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val listener = object : ImageDecoder.OnHeaderDecodedListener &#123;</span><br><span class="line">          override fun onHeaderDecoded(decoder: ImageDecoder, info: ImageDecoder.ImageInfo, source: ImageDecoder.Source) &#123;</span><br><span class="line">              decoder.setTargetSampleSize(2)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      val drawable1 = ImageDecoder.decodeDrawable(source, listener)</span><br></pre></td></tr></table></figure></li><li><p>3、如果解码的图片是<code>gif</code>，会被解码成<code>AnimatedImageDrawable</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val drawable2 = ImageDecoder.decodeDrawable(source)</span><br><span class="line">    if (drawable is AnimatedImageDrawable) &#123;</span><br><span class="line">        drawable.start()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>4、解码出来的bitmap是不可变，可以使用<code>PostProcessor</code>来添加一些自定义的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val drawable3 = ImageDecoder.decodeDrawable(source) &#123; decoder, info, src -&gt;</span><br><span class="line">        decoder.setPostProcessor &#123; canvas -&gt;</span><br><span class="line">            // This will create rounded corners.</span><br><span class="line">            //创建圆角照片</span><br><span class="line">            val path = Path()</span><br><span class="line">            path.setFillType(Path.FillType.INVERSE_EVEN_ODD)</span><br><span class="line">            val width = canvas.width</span><br><span class="line">            val height = canvas.height</span><br><span class="line">             // 最低的API的要求是 21 所以我的工程里面的 API为 21</span><br><span class="line">            path.addRoundRect(0.toFloat(), 0.toFloat(), width.toFloat(), height.toFloat(), 20.toFloat(), 20.toFloat(), Path.Direction.CW)</span><br><span class="line">            val paint = Paint()</span><br><span class="line">            paint.setAntiAlias(true)</span><br><span class="line">            paint.setColor(Color.TRANSPARENT)</span><br><span class="line">            paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.SRC))</span><br><span class="line">            canvas.drawPath(path, paint)</span><br><span class="line">            PixelFormat.TRANSLUCENT</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、如果解码的照片是不完整的或者包含错误，解码的时候会抛出<code>DecodeException</code>，一些情况下，可能已经解码出一部分的照片，这个时候传递<code>OnPartialImageListener</code>，并返回<code>true</code>，就只显示解码出来的部分，剩余部分使用空白代替!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val drawable5 = ImageDecoder.decodeDrawable(source) &#123; decoder, info, src -&gt;</span><br><span class="line">         decoder.setOnPartialImageListener &#123; e: ImageDecoder.DecodeException -&gt;</span><br><span class="line">              true</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="网络连接与位置"><a href="#网络连接与位置" class="headerlink" title="网络连接与位置"></a>网络连接与位置</h2><h4 id="1、使用-Wi-Fi-RTT-，进行室内定位"><a href="#1、使用-Wi-Fi-RTT-，进行室内定位" class="headerlink" title="1、使用 Wi-Fi RTT ，进行室内定位"></a>1、使用 Wi-Fi RTT ，进行室内定位</h4><ul><li><code>Android 9</code> 为<code>IEEE 802.11mc Wi-Fi</code>协议添加了平台支持 (也称为 Wi-Fi 往返时间，RTT)，这可以让您在应用中使用室内定位功能。在提供硬件支持的 Android 9 设备上，在启动位置服务并勾选 “允许获取地理位置信息” 选项后，应用就可以使用 RTT API 测量与附近 Wi-Fi 接入点 (AP) 的距离。设备不需要连接到 AP 便可以使用 RTT，而且为了保护隐私，只有手机能够确定距离，而 AP 不可以。</li><li>通过测量从设备到三个或更多 AP 的距离，您可以计算设备位置至 1 到 2 米的精度。这种精确度允许您创建更多新的体验：室内导航、基于位置的细粒度服务，例如，模糊语音控制 ( “打开这里的灯” ) ；以及基于位置的资讯服务 ( “这个产品有优惠活动吗？” )。</li></ul><h4 id="2、JobScheduler-中的数据费用敏感度"><a href="#2、JobScheduler-中的数据费用敏感度" class="headerlink" title="2、JobScheduler 中的数据费用敏感度"></a>2、JobScheduler 中的数据费用敏感度</h4><ul><li>在 <code>Android 9</code>中，<code>JobScheduler</code> 可以更好地帮助用户处理与网络相关的任务，并与运营商单独提供的网络状态信号相协调</li><li><code>JobScheduler</code>是 <code>Android</code> 的一项核心服务，它可以帮助您针对低耗电模式、应用待机模式以及后台限制，妥善进行各种任务的调度。在 <code>Android 9</code>中，<code>JobScheduler</code> 可以更好地帮助用户处理与网络相关的任务，并与运营商单独提供的网络状态信号相协调。任务现在可以声明预估数据量、信号预取以及指定详细的网络要求 —— 运营商可以报告网络状况是拥塞还是不计量，然后 <code>JobScheduler</code>会根据网络状态管理作业。例如，当网络拥塞时，<code>JobScheduler</code> 可能推迟大型网络请求；而在网络可以不计量使用时，则可以运行多种预加载作业 (例如，预读标题) 来改进用户体验。<h4 id="3、-用于-NFC-支付和安全交易的-Open-Mobile-API"><a href="#3、-用于-NFC-支付和安全交易的-Open-Mobile-API" class="headerlink" title="3、 用于 NFC 支付和安全交易的 Open Mobile API"></a>3、 用于 NFC 支付和安全交易的 Open Mobile API</h4></li><li><code>Android 9</code> 将 <code>GlobalPlatform Open Mobile API</code> 的实现添加至平台中。在支持的设备上，应用可以使用 OMAPI API 访问安全元素 (SE) ，以启用智能卡支付等安全服务。硬件抽象层 (HAL) 提供了必要的 API，用于枚举多种可用的 Secure Elements (如 eSE, UICC 等)。</li></ul><h2 id="更强劲的性能表现"><a href="#更强劲的性能表现" class="headerlink" title="更强劲的性能表现"></a>更强劲的性能表现</h2><h4 id="1、ART-性能提升"><a href="#1、ART-性能提升" class="headerlink" title="1、ART 性能提升"></a>1、ART 性能提升</h4><ul><li>ART是什么？<ul><li><code>AOT</code>是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式。</li></ul></li><li><code>JIT</code>是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik。<ul><li>ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。</li><li>当然ART与Dalvik相比，还是有缺点的。<ul><li>ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%</li><li>由于有了一个转码的过程，所以应用安装时间难免会延长<ul><li>但是这些与更流畅的Android体验相比而言，不值一提。</li></ul></li></ul></li></ul></li><li><code>Android 9</code> 借助 <code>ART</code> 运行时显著提高了应用的性能表现与运行效率。扩展了 <code>ART</code>对执行特征的使用，以优化应用并减少已编译应用代码的内存占用量。ART 现可使用特征文件信息在设备上重写 DEX 文件，帮助多个常见应用的内存占用减少高达 11％。我们期望借此减少系统 DEX 内存使用量并加快应用启动时间。</li></ul><h4 id="2、Kotlin-优化"><a href="#2、Kotlin-优化" class="headerlink" title="2、Kotlin 优化"></a>2、Kotlin 优化</h4><ul><li>Kotlin 是 Android 开发的一等编程语言，改进了一些编译器优化，尤其是那些针对循环的编译器优化，以实现更好的性能。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android P </tag>
            
            <tag> 谷歌 </tag>
            
            <tag> Android 9 正式版 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓invalidate、postInvalidate、requestLayout源码分析</title>
      <link href="/2018/08/07/%E5%AE%89%E5%8D%93invalidate%E3%80%81postInvalidate%E3%80%81requestLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/07/%E5%AE%89%E5%8D%93invalidate%E3%80%81postInvalidate%E3%80%81requestLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<ul><li>最近在撸<code>Golang</code>有点上火了，来整理下安卓源码资料☺☺☺</li><li>分析结果基于<code>Audroid API 26</code><a id="more"></a><h4 id="requestLayout-源码分析"><a href="#requestLayout-源码分析" class="headerlink" title="requestLayout()源码分析"></a><code>requestLayout()</code>源码分析</h4></li><li><p>假如在一个页面上有个按钮，点击按钮就对一个 <code>view.requestLayout()</code>,这个 <code>view</code> 执行的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView------onMeasure</span><br><span class="line">InvalidateTextView------onMeasure</span><br><span class="line">InvalidateTextView-------layout</span><br><span class="line">InvalidateTextView--------onLayout</span><br><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p><code>view.requestLayout()</code>  方法的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@CallSuper</span><br><span class="line">  public void requestLayout() &#123;</span><br><span class="line">      // 清除绘制的缓存</span><br><span class="line">      if (mMeasureCache != null) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">      if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</span><br><span class="line">          //只有在布局逻辑中触发请求，如果这是请求它的视图，而不是其父层次结构中的视图</span><br><span class="line">          ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">          //如果连续请求两次，其中一次自动返回！</span><br><span class="line">          if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">              if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          mAttachInfo.mViewRequestingLayout = this;</span><br><span class="line">      &#125;</span><br><span class="line">     //todo   为当前view设置标记位 PFLAG_FORCE_LAYOUT</span><br><span class="line">      mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">      mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">      if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">         //   todo  向父容器请求布局 这里是向父容器请求布局，即调用父容器的requestLayout方法，为父容器添加PFLAG_FORCE_LAYOUT标记位，而父容器又会调用它的父容器的requestLayout方法，即requestLayout事件层层向上传递，直到DecorView，即根View，而根View又会传递给ViewRootImpl，也即是说子View的requestLayout事件，最终会被ViewRootImpl接收并得到处理</span><br><span class="line">          mParent.requestLayout();</span><br><span class="line">      &#125;</span><br><span class="line">      if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;</span><br><span class="line">          mAttachInfo.mViewRequestingLayout = null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>1、如果缓存不为<code>null</code>,清除绘制的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (mMeasureCache != null) mMeasureCache.clear();</span><br></pre></td></tr></table></figure></li><li><p>2、这里判断了是否在<code>layout</code>，如果是，就返回，也就可以理解为： 如果连续请求两次，并且其中的一次正在<code>layout</code>中，其中一次返回！这样做是节约性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</span><br><span class="line">         //只有在布局逻辑中触发请求，如果这是请求它的视图，而不是其父层次结构中的视图</span><br><span class="line">         ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">         //如果连续请求两次，其中一次自动返回！</span><br><span class="line">         if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">             if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         mAttachInfo.mViewRequestingLayout = this;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>3、  为当前<code>view</code>设置标记位<code>PFLAG_FORCE_LAYOUT</code>,关于 <code>|=</code>符号：<code>a|=b</code>的意思就是把a和b按位或然后赋值给a 按位或的意思就是先把a和b都换成2进制，然后用或操作，相当于<code>a=a|b</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">mPrivateFlags |= PFLAG_INVALIDATED;</span><br></pre></td></tr></table></figure></li><li><p>4、向父容器请求布局，即调用<code>ViewGroup</code>父容器的<code>requestLayout()</code>方法，为父容器添加<code>PFLAG_FORCE_LAYOUT</code>标记位，而父容器又会调用它的父容器的<code>requestLayout()</code>方法，即<code>requestLayout()</code>事件层层向上传递，直到<code>DecorView</code>，即根<code>View</code>，而根<code>View</code>又会传递给<code>ViewRootImpl，</code>也即是说子View的<code>requestLayout()f</code>事件，最终会被<code>ViewRootImpl.requestLayout()</code>接收并得到处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">      mParent.requestLayout();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、<code>ViewRootImpl.requestLayout()</code>方法详情</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void requestLayout() &#123;</span><br><span class="line">      if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">          // 检查是否在主线程，不在的话，抛出异常</span><br><span class="line">          checkThread();</span><br><span class="line">          mLayoutRequested = true;</span><br><span class="line">          scheduleTraversals();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、检查是否在主线程，不在的话，抛出异常<code>checkThread();</code>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 、最终走到这个方法来<code>ViewRootImpl.scheduleTraversals()</code>,在其中可以看到一行非常有意思的代码<br><code>mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> ,其中有个对象<code>mTraversalRunnable</code>,这样下去就会重新的测量、布局和绘制；具体的流程可以看这篇文章<a href="https://www.jianshu.com/p/b63c6afa1844" target="_blank" rel="noopener">Android源码分析(View的绘制流程)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   // requestLayout()  会调用这个方法 </span><br><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = true;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        // 最终调用的是这个方法</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>有个问题，我先抛出结论，<code>requessLayout() 、invalidate()、postInvalidate()</code>最终的底层调用的是 <code>ViewRootImpl.scheduleTraversals()</code>的方法,为什么仅仅<code>requessLayout()</code>才会执行<code>onMeasure()  onLayout()  onDraw()</code>这几个方法？</p></li><li><p>关于<code>view.measure()</code>方法:在前面我们知道 <code>mPrivateFlags |= PFLAG_FORCE_LAYOUT</code> 所以 <code>forceLayout = true</code>,也就是会执行<code>onMeasure(widthMeasureSpec, heightMeasureSpec);</code>,同时执行完了以后呢，最后为标记位设置为<code>mPrivateFlags |=PFLAG_LAYOUT_REQUIRED</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       ...</span><br><span class="line">       // requestLayout的方法改变的  mPrivateFlags |= PFLAG_FORCE_LAYOUT; 所以 forceLayout = true</span><br><span class="line">       final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line">       ...</span><br><span class="line">       if (forceLayout || needsLayout) &#123;</span><br><span class="line">       ...</span><br><span class="line">           if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">               //最终会走到这方法来</span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; </span><br><span class="line">           // 接着最后为标记位设置为PFLAG_LAYOUT_REQUIRED</span><br><span class="line">           mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>view.layout()</code>方法：判断标记位是否为<code>PFLAG_LAYOUT_REQUIRED</code>，如果有，则对该<code>View</code>进行布局,也就是走到<code>onLayout(changed, l, t, r, b);</code>,最后清除标记<code>mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">   public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">       if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">           //第二次调用这个方法，，，</span><br><span class="line">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int oldL = mLeft;</span><br><span class="line">       int oldT = mTop;</span><br><span class="line">       int oldB = mBottom;</span><br><span class="line">       int oldR = mRight;</span><br><span class="line"></span><br><span class="line">       boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">          //判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span><br><span class="line">       if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">           onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">           if (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">               if(mRoundScrollbarRenderer == null) &#123;</span><br><span class="line">                   mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mRoundScrollbarRenderer = null;</span><br><span class="line">           &#125;</span><br><span class="line">           //  onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">   //  //最后清除PFLAG_FORCE_LAYOUT标记位</span><br><span class="line">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上就是 <code>requestLayout()</code>的分析的结果:<code>view</code>调用了这个方法，其实会从<code>view</code>树重新进行一次测量、布局、绘制这三个流程。</p></li><li>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-727eb9d2da018f43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="requestLayout()的原理.jpg"></li></ul><h4 id="invalidate-源码分析"><a href="#invalidate-源码分析" class="headerlink" title="invalidate()源码分析"></a><code>invalidate()源码分析</code></h4><ul><li><p><code>view.invalidate()</code>;继承一个Textview，然后重写方法，设置一个but，同时请求方法，打印日志：请求一次的输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p>方法详情 : <code>view.invalidate()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void invalidate() &#123;</span><br><span class="line">      invalidate(true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>该视图的绘图缓存是否也应无效。对于完全无效,设置为true，但是如果视图的内容或维度没有改变，则可以设置为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void invalidate(boolean invalidateCache) &#123;</span><br><span class="line">     invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>invalidateInternal()</code>方法详情：其实关键的方法就是<code>invalidateChild()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</span><br><span class="line">          boolean fullInvalidate) &#123;</span><br><span class="line">      if (mGhostView != null) &#123;</span><br><span class="line">          mGhostView.invalidate(true);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      // 判断是否可见，是否在动画中，是否不是ViewGroup，三项满足一项，直接返回</span><br><span class="line">      if (skipInvalidate()) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span><br><span class="line">      if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">              || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">              || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">              || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">          if (fullInvalidate) &#123;</span><br><span class="line">              mLastIsOpaque = isOpaque();</span><br><span class="line">              mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">          &#125;</span><br><span class="line">          //设置PFLAG_DIRTY标记位</span><br><span class="line">          mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">          if (invalidateCache) &#123;</span><br><span class="line">              mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">              mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">          &#125;</span><br><span class="line">          //把需要重绘的区域传递给父容器</span><br><span class="line">          // Propagate the damage rectangle to the parent view.</span><br><span class="line">          final AttachInfo ai = mAttachInfo;</span><br><span class="line">          final ViewParent p = mParent;</span><br><span class="line">          if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">              final Rect damage = ai.mTmpInvalRect;</span><br><span class="line">              damage.set(l, t, r, b);</span><br><span class="line">              //调用父容器的方法，向上传递事件</span><br><span class="line">              p.invalidateChild(this, damage);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Damage the entire projection receiver, if necessary.</span><br><span class="line">          // 损坏整个投影接收机，如果不需要。</span><br><span class="line">          if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">              final View receiver = getProjectionReceiver();</span><br><span class="line">              if (receiver != null) &#123;</span><br><span class="line">                  receiver.damageInParent();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、判断是否可见，是否在动画中，是否不是<code>ViewGroup</code>，三项满足一项，直接返回，这个方法也可以知道，<code>invalidate()</code>针对的是<code>View</code>，而不是<code>ViewGroup</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean skipInvalidate() &#123;</span><br><span class="line">      return (mViewFlags &amp; VISIBILITY_MASK) != VISIBLE &amp;&amp; mCurrentAnimation == null &amp;&amp;</span><br><span class="line">              (!(mParent instanceof ViewGroup) ||</span><br><span class="line">                      !((ViewGroup) mParent).isViewTransitioning(this));</span><br><span class="line">  &#125;</span><br><span class="line"> ``` </span><br><span class="line">   *  2、通过View的标记位来判断孩子View是否需要重新绘制，如果没有变化的话，那么就不需要重新绘制</span><br></pre></td></tr></table></figure><p>mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN |<br>PFLAG_HAS_BOUNDS)</p><pre><code>|| (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == </code></pre><p>PFLAG_DRAWING_CACHE_VALID)</p><pre><code>     || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED|| (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  3、需要重新绘制的区域传递给父容器，向上传递事件，记住在这里 `damage`这个变量肯定不为`null`,要不然在这个方法里面就会直接抛出空指针异常。</span><br></pre></td></tr></table></figure><p>p.invalidateChild(this, damage);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  4、损坏整个投影接收机，如果不需要。` mBackground.isProjected()`： 这张画是否需要投影。</span><br></pre></td></tr></table></figure><p>if (mBackground != null &amp;&amp; mBackground.isProjected()) {</p><pre><code>    final View receiver = getProjectionReceiver();    if (receiver != null) {        receiver.damageInParent();    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* 关键的方法：`ViewRootImpl.invalidateChild(this, damage);`</span><br></pre></td></tr></table></figure></li></ul><p>@Override<br>  public void invalidateChild(View child, Rect dirty) {</p><pre><code>invalidateChildInParent(null, dirty);</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*    invalidateChildInParent(null, dirty);进行了offset和union对坐标的调整，然后把dirty区域的信息保存在mDirty中，最后调用了`scheduleTraversals()`方法，触发View的工作流程，由于没有添加measure和layout的标记位，因此measure、layout流程不会执行，而是直接从`draw`流程开始.</span><br><span class="line">       ``` </span><br><span class="line">      @Override</span><br><span class="line">       public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</span><br><span class="line">        // 检查线程，不是ui线程，直接抛出异常</span><br><span class="line">        checkThread();</span><br><span class="line">         if (DEBUG_DRAW) Log.v(mTag, &quot;Invalidate child: &quot; + dirty);</span><br><span class="line"> </span><br><span class="line">        if (dirty == null) &#123;</span><br><span class="line">             invalidate();</span><br><span class="line">            return null;</span><br><span class="line">           &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          if (mCurScrollY != 0 || mTranslator != null) &#123;</span><br><span class="line">            mTempRect.set(dirty);</span><br><span class="line">             dirty = mTempRect;</span><br><span class="line">            if (mCurScrollY != 0) &#123;</span><br><span class="line">                // 将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span><br><span class="line">                dirty.offset(0, -mCurScrollY);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mTranslator != null) &#123;</span><br><span class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">                dirty.inset(-1, -1);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //进行了offset和union对坐标的调整</span><br><span class="line">         invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><pre><code>*  1、检查线程，不是ui线程，直接抛出异常.和`requestLayout()`一样的  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkThread();</span><br></pre></td></tr></table></figure> *  2、如果是从 invalidate() 方法过来的话，那么dirty 肯定不为null  因为要是为null的话，前面调用方法的地方就抛出了空指针的异常 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dirty == null) &#123;</span><br><span class="line">    invalidate();</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> * 3、通过将dx=0添加到其左、右坐标，并将 mCurScrollY 添加到其顶部和底部坐标来抵消矩形。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirty.offset(0, -mCurScrollY);</span><br></pre></td></tr></table></figure>  *   4、进行了offset和union对坐标的调整  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalidateRectOnScreen(dirty);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>关于<code>invalidateRectOnScreen(dirty)</code>方法:最终的关键的方法： scheduleTraversals();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void invalidateRectOnScreen(Rect dirty) &#123;</span><br><span class="line">    final Rect localDirty = mDirty;</span><br><span class="line">    if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">        mAttachInfo.mSetIgnoreDirtyState = true;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Add the new dirty rect to the current one</span><br><span class="line">    // 添加一个新的 dirty rect 给当前的Rect</span><br><span class="line">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">    // Intersect with the bounds of the window to skip</span><br><span class="line">    // updates that lie outside of the visible region</span><br><span class="line">    final float appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    final boolean intersected = localDirty.intersect(0, 0,</span><br><span class="line">            (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</span><br><span class="line">    if (!intersected) &#123;</span><br><span class="line">        localDirty.setEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终的关键的方法：<code>ViewRootImpl.scheduleTraversals();</code>，也就是会调用到这个对象<code>mTraversalRunnable</code>;也就是和<code>requessLaout()</code>最终调用的底层的方法一样，只不过对于<code>invalidate()</code>没有添加<code>measure()</code>和<code>layout()</code>的标记位，后面的流程也就不会执行！具体的流程可以看这篇文章<a href="https://www.jianshu.com/p/b63c6afa1844" target="_blank" rel="noopener">Android源码分析(View的绘制流程)</a></p></li><li>该方法的调用会引起<code>View</code>树的重绘，常用于内部调用(比如 setVisiblity())或者需要刷新界面的时候,需要在主线程(即UI线程)中调用该方法，<code>invalidate</code>有多个重载方法，但最终都会调用<code>invalidateInternal</code>方法，在这个方法内部，进行了一系列的判断，判断<code>View</code>是否需要重绘，接着为该<code>View</code>设置标记位，然后把需要重绘的区域传递给父容器，即调用父容器的<code>invalidateChild</code>方法。</li><li>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-f43b39cd42720e77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidate()的原理.jpg"></li></ul><h4 id="postInvalidate-的源码解析"><a href="#postInvalidate-的源码解析" class="headerlink" title="postInvalidate()的源码解析"></a>postInvalidate()的源码解析</h4><ul><li><p><code>view.postInvalidate()</code>继承一个Textview，然后重写方法，设置一个but，同时请求方法，打印日志：请求一次的输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p><code>view.postInvalidate()</code>详情,由于方法是public，也可以调用一个时间，延迟多久开始执行，这里是delayMilliseconds，毫秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void postInvalidate() &#123;</span><br><span class="line">     postInvalidateDelayed(0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>view.postInvalidateDelayed（）</code> 只有<code>attachInfo</code>不为null的时候才会继续执行，即只有确保视图被添加到窗口的时候才会通知view树重绘，因为这是一个异步方法，如果在视图还未被添加到窗口就通知重绘的话会出现错误，所以这样要做一下判断!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void postInvalidateDelayed(long delayMilliseconds) &#123;</span><br><span class="line">     final AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">     if (attachInfo != null) &#123;</span><br><span class="line">         attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ViewRootImpl.dispatchInvalidateDelayed()</code> 用了Handler，发送了一个异步消息到主线程，显然这里发送的是MSG_INVALIDATE，即通知主线程刷新视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 用了Handler，发送了一个异步消息到主线程，显然这里发送的是`MSG_INVALIDATE`，即通知主线程刷新视图</span><br><span class="line">    * @param view  只有 postInvalidate() 使用了handler 来发送消息</span><br><span class="line">   * @param delayMilliseconds</span><br><span class="line">   */</span><br><span class="line">  public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123;</span><br><span class="line">      Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">      mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>通知对象去<code>invalidate()</code> ，底层也是调用的是<code>invalidate()</code>，只不过使用了<code>mHandler</code>发送消息,在这里就发送到主线程了，去调用<code>invalidate()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case MSG_INVALIDATE:</span><br><span class="line">              //通知对象去 invalidate ，底层也是调用的是 invalidate，只不过使用了handler发送消息</span><br><span class="line">              ((View) msg.obj).invalidate();</span><br><span class="line">              break;0</span><br></pre></td></tr></table></figure></li><li><p>方法的解释 ：<code>postInvalidate</code>是在非UI线程中调用,但是底层使用的是 <code>invalidate()</code>,通过<code>ViewRootImpl的内部handler： ViewRootHandler</code>发送的消息，但是也可以在 主线程中使用，如果在强制在主线程中使用，内部有个 <code>handler</code> 在工作，是不是显得有点浪费 ，对吧！</p></li><li><code>postInvalidate()</code>这个方法也可以主线程中使用</li><li><p>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a267e92df57adf3e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postInvalidate()的原理.jpg"></p></li><li><p>最后说明几点</p><ul><li><code>invalidate()、postInvalidate()、requestLayout()</code>,最底层处调用的是<code>viewRootImpl.scheduleTraversals()</code> 这个方法，<code>requestLayout</code>由于设置了<code>measure</code>和<code>layout</code>的标记位，所以<code>requestLayout</code>可以重新走一次绘制的流程<ul><li><code>postInvalidate()</code> 底层通过<code>Handler</code>把非UI线程的工作，调用的是<code>invalidate()</code>.</li><li><code>invalidate()、requestLayout()</code>,方法都检查了是否在<code>UI</code>线程,不在的话，直接抛出异常，所以他们只能在UI线程中使用，<code>postInvalidate()</code>可以在UI线程和非UI线程中使用。</li><li><code>view</code>自身不在适合某个区域，比如说<code></code>LayoutParams<code>发生了改变，需要对其重新的测量、布局和绘制的三个流程，那么使用这个方法最合适</code>requestLayout()`。</li><li>如果说是在刷新当前的view，是当前的view进行重新的绘制，不会进行测量、布局流程。仅仅需要某个<code>view</code>重新绘制而不需要测量，使用<code>invalidate()方法往往比requestLayout()方法更高效</code></li></ul></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
            <tag> invalidate </tag>
            
            <tag> postInvalidate </tag>
            
            <tag> requestLayout </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言实现RPC</title>
      <link href="/2018/07/19/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RPC/"/>
      <url>/2018/07/19/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RPC/</url>
      <content type="html"><![CDATA[<h4 id="RPC定义，来源于百度百科"><a href="#RPC定义，来源于百度百科" class="headerlink" title="RPC定义，来源于百度百科"></a>RPC定义，来源于百度百科</h4><ul><li>RPC（Remote Procedure Call）—<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">远程过程调用</a>，它是一种通过<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">RPC协议</a>假定某些<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输协议</a>的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">网络通信</a>模型中，RPC跨越了<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">传输层</a>和<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a>。RPC使得开发包括网络<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F" target="_blank" rel="noopener">分布式</a>多程序在内的应用程序更加容易。<a id="more"></a></li><li><p>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">信息</a>，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p></li><li><p>有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算<a href="https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">环境</a>（DCE）。</p></li><li>个人的理解：不用管什么底层网络技术的协议，是一种通过网络从计算机程序上请求服务，通俗一点，我们写代码，要在一个地方，比如安卓，就需要在一个工程里面，才可以调用到其他的程序代码执行的过程。Go语言提供RPC支持使得开发网络分布式多程序在内的应用程序更加的<code>easy</code></li></ul><h4 id="RPC工作流程图"><a href="#RPC工作流程图" class="headerlink" title="RPC工作流程图"></a>RPC工作流程图</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-147298372fc05727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来源于gitHub"></p><ul><li>1.调用客户端句柄；执行传送参数</li><li>2.调用本地系统内核发送网络消息</li><li>3.消息传送到远程主机</li><li>4.服务器句柄得到消息并取得参数</li><li>5.执行远程过程</li><li>6.执行的过程将结果返回服务器句柄</li><li>7.服务器句柄返回结果，调用远程系统内核</li><li>8.消息传回本地主机</li><li>9.客户句柄由内核接收消息</li><li>10.客户接收句柄返回的数据</li></ul><h4 id="Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC-但是在Go中RPC是独一无二的，它采用了GoLang-Gob编码-只能支持Go语言！"><a href="#Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC-但是在Go中RPC是独一无二的，它采用了GoLang-Gob编码-只能支持Go语言！" class="headerlink" title="Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC,但是在Go中RPC是独一无二的，它采用了GoLang Gob编码,只能支持Go语言！"></a>Go语言提供对RPC的支持：<code>HTTP、TCP、JSPNRPC</code>,但是在<code>Go</code>中<code>RPC</code>是独一无二的，它采用了<code>GoLang Gob</code>编码,只能支持Go语言！</h4><ul><li>GoLang Gob:是Golang包自带的一个数据结构序列化的编码/解码工具。编码使用Encoder，解码使用Decoder。一种典型的应用场景就是RPC(remote procedure calls)。</li></ul><h4 id="HTTP-RPC-Demo"><a href="#HTTP-RPC-Demo" class="headerlink" title="HTTP RPC Demo"></a>HTTP RPC Demo</h4><ul><li><p>服务端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">     rpcDemo()</span><br><span class="line">&#125;</span><br><span class="line">type Arith int</span><br><span class="line">func rpcDemo() &#123;</span><br><span class="line">arith:=new(Arith)</span><br><span class="line">//arith=== 0xc04204e090</span><br><span class="line">fmt.Println(&quot;arith===&quot;,arith)</span><br><span class="line"></span><br><span class="line">rpc.Register(arith)</span><br><span class="line">//HandleHTTP将RPC消息的HTTP处理程序注册到Debug服务器</span><br><span class="line">//DEFAUTUPCPATH和Debug调试路径上的调试处理程序。</span><br><span class="line">//仍然需要调用http.Services（），通常是在GO语句中。</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">err:=http.ListenAndServe(&quot;:1234&quot;,nil)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err=====&quot;,err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">type Args struct &#123;</span><br><span class="line">A, B int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Quotient struct &#123;</span><br><span class="line">Quo, Rem int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数必须是导出的(首字母大写)</span><br><span class="line">//必须有两个导出类型的参数，</span><br><span class="line">//第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的</span><br><span class="line">//函数还要有一个返回值error</span><br><span class="line">func (t *Arith) Multiply(args *Args, reply *int) error &#123;</span><br><span class="line">*reply = args.A * args.B</span><br><span class="line">fmt.Println(&quot;这个方法执行了啊---嘿嘿--- Multiply &quot;,reply)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (t *Arith) Divide(args *Args, quo *Quotient) error &#123;</span><br><span class="line">if args.B == 0 &#123;</span><br><span class="line">return errors.New(&quot;divide by zero&quot;)</span><br><span class="line">&#125;</span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B</span><br><span class="line">fmt.Println(&quot;这个方法执行了啊---嘿嘿--- Divide quo==&quot;,quo)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go RPC 的函数只有符合四个条件才能够被远程访问，不然会被忽略</p><ul><li>函数必须是首字母大写（可以导出的）</li><li>必须有两个导出类型的参数 </li><li>第一个参数是接受的参数，第二个参数是返回给客户端的参数，而且第二个参数是指针的类型 </li><li>函数还要有一个返回值<code>error</code> </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) MethodName(argType T1, replyType *T2) error</span><br></pre></td></tr></table></figure><ul><li><p>T、T1和T2类型必须能被<code>encoding/gob</code>包编解码。</p></li><li><p>客户端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ArgsTwo struct &#123;</span><br><span class="line">A, B int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QuotientTwo struct &#123;</span><br><span class="line">Quo, Rem int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 如果什么都不输入的话 ，就是以下的这个值</span><br><span class="line">//os***************** [C:\Users\win7\AppData\Local\Temp\go-build669605574\command-</span><br><span class="line">//line-arguments\_obj\exe\GoRPCWeb.exe 127.0.0.1] **********************</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;os*****************&quot;,os.Args,&quot;**********************&quot;)</span><br><span class="line">if len(os.Args) != 4 &#123; //   todo  第二个地址是  我们本地的地址</span><br><span class="line">fmt.Println(&quot;老子要退出了哦 傻逼 一号start--------》》》&quot;, os.Args[0], &quot;《《《---------------server  end&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;长度是多少 &quot;+strconv.Itoa( len(os.Args))+&quot;才是准确的长度 哦---》&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    //获取输入的地址是获取输入得 os 数据的 第一个位置的值</span><br><span class="line">serverAddress := os.Args[1]</span><br><span class="line">    fmt.Println(&quot;severAddress==&quot;,serverAddress)</span><br><span class="line">// //DelayHTTP在指定的网络地址连接到HTTP RPC服务器</span><br><span class="line">///在默认HTTP RPC路径上监听。</span><br><span class="line">client, err := rpc.DialHTTP(&quot;tcp&quot;, serverAddress)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;发生错误了 在这里地方  DialHTTP&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">i1,_:=strconv.Atoi( os.Args[2])</span><br><span class="line">i2,_:=strconv.Atoi( os.Args[3])</span><br><span class="line">args := ArgsTwo&#123;i1, i2&#125;</span><br><span class="line">var reply int</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;Call Multiply  发生错误了哦   arith error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Arith 乘法: %d*%d=%d\n&quot;, args.A, args.B, reply)</span><br><span class="line"></span><br><span class="line">var quot QuotientTwo</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err = client.Call(&quot;Arith.Divide&quot;, args, &amp;quot)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;arith error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Arith 除法取整数: %d/%d=%d 余数 %d\n&quot;, args.A, args.B, quot.Quo, quot.Rem)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-2ebbd9d70053e8e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行的结果图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoRPCWeb8.go 127.0.0.1:1234  20 3</span><br><span class="line">os***************** [C:\Users\win7\AppData\Local\Temp\go-build011170718\command-</span><br><span class="line">line-arguments\_obj\exe\GoRPCWeb8.exe 127.0.0.1:1234 20 3] *********************</span><br><span class="line">*</span><br><span class="line">长度是多少 4才是准确的长度 哦---》</span><br><span class="line">severAddress== 127.0.0.1:1234</span><br><span class="line">Arith 乘法: 20*3=60</span><br><span class="line">Arith 除法取整数: 20/3=6 余数 2</span><br></pre></td></tr></table></figure></p><ul><li>go run GoRPCWeb8.go 127.0.0.1:1234  20 3 <ul><li>go run 运行的命令 </li><li>GoRPCWeb8.go ：这是文件的名称，需要到指定的目录下启动<code>cmd</code> <ul><li>127.0.0.1:1234  ： ip地址和端口号</li></ul></li><li>20 3 这是客服端传入的值：一个除数，一个被除数，传入到服务器做乘法运算 乘法: <code>20*3=60</code>和除法取整数: <code>20/3=6</code> 余数 <code>2</code>,怎么做的，客户端不关心，给到服务端去完成</li></ul></li><li><code>os.Args[0]</code>=<code>[C:\Users\win7\AppData\Local\Temp\go-build011170718\command-line-arguments\_obj\exe\GoRPCWeb8.exe 127.0.0.1:1234 20 3]</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if len(os.Args) != 4 &#123; //   todo  第二个地址是  我们本地的地址</span><br><span class="line">fmt.Println(&quot;老子要退出了哦 傻逼 一号start--------》》》&quot;, os.Args[0], &quot;《《《---------------server  end&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;长度是多少 &quot;+strconv.Itoa( len(os.Args))+&quot;才是准确的长度 哦---》&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="TCP-RPC-Demo"><a href="#TCP-RPC-Demo" class="headerlink" title="TCP RPC Demo"></a>TCP RPC Demo</h4><ul><li><p>基于TCP协议实现的RPC，服务端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">fmt.Println(&quot;基于TCP协议实现的RPC，服务端的代码如下&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type Me struct &#123;</span><br><span class="line">A,B int</span><br><span class="line">&#125;</span><br><span class="line">type You struct &#123;</span><br><span class="line">CC,D int</span><br><span class="line">&#125;</span><br><span class="line">type Num int</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Go RPC的函数只有符合下面的条件才能够被远程访问，不然会被忽略</span><br><span class="line">1 函数必须是导出的（首字母大写）</span><br><span class="line">2 必须有两个导出类型的参数</span><br><span class="line">3 第一个参数是接受的参数，第二个参数是返回给客户端的参数，第二个参数必须是指正类型的</span><br><span class="line">4 函数还必须有一个返回值error</span><br><span class="line"> */</span><br><span class="line">func (n *Num) M(args *Me,reply *int) error  &#123;</span><br><span class="line">*reply=args.A * args.B</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (n *Num) F(args * Me,u *You ) error  &#123;</span><br><span class="line">if  args.B==0&#123;</span><br><span class="line">return errors.New(&quot;输入不能够为0 被除数&quot;)</span><br><span class="line">&#125;</span><br><span class="line">u.D=args.A/args.B</span><br><span class="line">u.CC=args.A % args.B</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：</span><br><span class="line">//new返回指针。</span><br><span class="line">    num:=new(Num)</span><br><span class="line">    rpc.Register(num)</span><br><span class="line">    //ResolveTCPAddr返回TCP端点的地址。</span><br><span class="line">//网络必须是TCP网络名称。</span><br><span class="line">    tcpAddr,err:=net.ResolveTCPAddr(&quot;tcp&quot;,&quot;:1234&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;错误了哦&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">    listener,err:=net.ListenTCP(&quot;tcp&quot;,tcpAddr)</span><br><span class="line">for  &#123;</span><br><span class="line">// todo   需要自己控制连接，当有客户端连接上来后，我们需要把这个连接交给rpc 来处理</span><br><span class="line">conn,err:=listener.Accept()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于TCP客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go&quot;)</span><br><span class="line"></span><br><span class="line">if len(os.Args)==4&#123;</span><br><span class="line">fmt.Println(&quot;长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip=&quot;,os.Args[1],&quot;嘿嘿,加上后面的被除数os.Args[2]=&quot;,os.Args[2],&quot;和除数os.Args[3]=&quot;,os.Args[3])</span><br><span class="line">//os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">    // 获取 ip 地址</span><br><span class="line">    service:= os.Args[1]</span><br><span class="line">    //连接 拨号连接到指定的网络地址的RPC服务器。</span><br><span class="line">    client,err:=rpc.Dial(&quot;tcp&quot;,service)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">log.Fatal(&quot;老子在连接Dial的发生了错误，我要退出了&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">num1:=os.Args[2]</span><br><span class="line">i1,error1:=strconv.Atoi(num1)</span><br><span class="line">if error1!=nil &#123;</span><br><span class="line">fmt.Println(&quot;自己不知道 自己输入错误了啊 请看error ：&quot;,error1)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">num2:=os.Args[3]</span><br><span class="line">i2,error2:=strconv.Atoi(num2)</span><br><span class="line">if error2!=nil &#123;</span><br><span class="line">fmt.Println(&quot;自己不知道 自己输入错误了啊 请看error ：&quot;,error2)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">aa:=AAA&#123;i1,i2&#125;</span><br><span class="line">var reply  int</span><br><span class="line">err1:=client.Call(&quot;Num.M&quot;,aa,&amp;reply)</span><br><span class="line"></span><br><span class="line">if err1 != nil&#123;</span><br><span class="line">log.Fatal(&quot;我要退出了，因为我在Call的时候发生了 错误&quot;,err1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;我进行正常结果如下&quot;)</span><br><span class="line">fmt.Printf(&quot;Num : %d*%d=%d\n&quot;,aa.A,aa.B,reply)</span><br><span class="line"></span><br><span class="line">var bb BDemo</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err= client.Call(&quot;Num.F&quot;,aa,&amp;bb)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">log.Fatal(&quot;我对这个方法发生了过敏的反应 哈哈哈哈  err=====&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Num: %d/%d=%d 余数 %d\n&quot;,aa.A,aa.B,bb.DD,bb.CC)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义两个类，那边需要操作的类</span><br><span class="line">type AAA struct &#123;</span><br><span class="line">A,B int</span><br><span class="line">&#125;</span><br><span class="line">//记住这里不能够大写 两个连着一起大写 有点意思</span><br><span class="line">//reading body gob: type mismatch: no fields matched compiling decoder for  DDDD</span><br><span class="line">//  todo 为啥 第二个参数  只要是两个连在一起的DDDD   就会报错   reading body gob: type mismatch: no fields matched compiling decoder for</span><br><span class="line">type BDemo struct &#123;</span><br><span class="line">DD, CC int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a4168e88f7eaf474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果图"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 1</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 1</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*1=20</span><br><span class="line">Num: 20/1=0 余数 0</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 2</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 2</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*2=40</span><br><span class="line">Num: 20/2=0 余数 0</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 3</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 3</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*3=60</span><br><span class="line">Num: 20/3=0 余数 2</span><br></pre></td></tr></table></figure><ul><li>在定义<code>BDemo</code> 的时候，  如果定义的<code>DD, CC int</code>和服务端不一样，就会报错  <code>reading body gob: type mismatch: no fields matched compiling decoder for</code> ,其实发现好多种情况，也会出现这种错误，但是目前不知道为啥会这样，后续，等源码深入一点，回来看这个问题    todo2018/07/19 </li><li><p>这种<code>TCP</code>方式和上面的<code>HTTP</code>不同的是</p><ul><li><p>HTTP:指定的网络地址连接到HTTP RPC服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        //DelayHTTP在指定的网络地址连接到HTTP RPC服务器</span><br><span class="line">///在默认HTTP RPC路径上监听。</span><br><span class="line">client, err := rpc.DialHTTP(&quot;tcp&quot;, serverAddress)</span><br></pre></td></tr></table></figure></li><li><p>TCP:指定的网络地址连接到HTTP RPC服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client,err:=rpc.Dial(&quot;tcp&quot;,service)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON RPC"></a>JSON RPC</h4><ul><li><p><code>JSON RPC</code>是数据编码采用了<code>JSON</code>，而不是<code>gob</code>编码，其他和上面介绍的<code>RPC</code>概念一模一样的。</p></li><li><p>服务端的代码如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;net/rpc/jsonrpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//使用Go提供的json-rpc 标准包</span><br><span class="line">func init() &#123;</span><br><span class="line">fmt.Println(&quot;JSON RPC 采用了JSON，而不是 gob编码，和RPC概念一模一样，&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type Work struct &#123;</span><br><span class="line">Who,DoWhat string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DemoM string</span><br><span class="line"></span><br><span class="line">func (m *DemoM) DoWork(w *Work,whoT *string) error  &#123;</span><br><span class="line">    *whoT=&quot;是谁：&quot;+w.Who+&quot;，在做什么---&quot;+w.DoWhat</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    str:=new(DemoM)</span><br><span class="line">    rpc.Register(str)</span><br><span class="line"></span><br><span class="line">    tcpAddr,err:=net.ResolveTCPAddr(&quot;tcp&quot;,&quot;:8080&quot;)</span><br><span class="line">if  err!=nil&#123;</span><br><span class="line">fmt.Println(&quot;大哥发生错误了啊，请看错误 ResolveTCPAddr err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    listener,err:=net.ListenTCP(&quot;tcp&quot;,tcpAddr)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">fmt.Println(&quot;发生错误了--》err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for  &#123;</span><br><span class="line"> conn,err:= listener.Accept()</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">jsonrpc.ServeConn(conn)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端的代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc/jsonrpc&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;这是客户端，用来启动，通过命令行来启动&quot;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go&quot;)</span><br><span class="line"></span><br><span class="line">if len(os.Args)==4&#123;</span><br><span class="line">fmt.Println(&quot;长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip=&quot;,os.Args[1],&quot;嘿嘿,加上后面的被除数os.Args[2]=&quot;,os.Args[2],&quot;和除数os.Args[3]=&quot;,os.Args[3])</span><br><span class="line">//os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> service:=os.Args[1]</span><br><span class="line"> client,err:=jsonrpc.Dial(&quot;tcp&quot;,service)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;Dial 发生了错误了哦 错误的信息为   err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">send:=Send&#123;os.Args[2],os.Args[3]&#125;</span><br><span class="line">var  resive  string</span><br><span class="line">err1:=client.Call(&quot;DemoM.DoWork&quot;,send,&amp;resive)</span><br><span class="line">if err1!=nil &#123;</span><br><span class="line">fmt.Println(&quot;shiming call error    &quot;)</span><br><span class="line">fmt.Println(&quot;Call 的时候发生了错误了哦  err=&quot;,err1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;收到信息了&quot;,resive)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 类可以不一样 但是 Who 和DoWhat 要必须一样  要不然接收到不到值，等我在详细的了解了 才去分析下原因  感觉有点蒙蔽啊</span><br><span class="line">type Send struct &#123;</span><br><span class="line">Who, DoWhat string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行的结果如下<br><img src="https://upload-images.jianshu.io/upload_images/5363507-48090786abf0e69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoJSONRPCWeb11.go 127.0.0.1:8080  shiming g</span><br><span class="line">ongzuo</span><br><span class="line">这是客户端，用来启动，通过命令行来启动</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:8080 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= shiming 和除数os.Args[3]= gongzuo</span><br><span class="line">收到信息了 是谁：shiming，在做什么---gongzuo</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoJSONRPCWeb11.go 127.0.0.1:8080  shiming q</span><br><span class="line">iaodaima</span><br><span class="line">这是客户端，用来启动，通过命令行来启动</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:8080 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= shiming 和除数os.Args[3]= qiaodaima</span><br><span class="line">收到信息了 是谁：shiming，在做什么---qiaodaima</span><br></pre></td></tr></table></figure><ul><li><code>os.Args</code>是一个数组  <code>var Args []string</code>,通过输入获取到，然后把这个客户端输入的内容传送到服务端，服务端做些操作，然后在返回给客户端 </li><li><code>Go</code>已经提供了<code>RPC</code>良好的支持，通过<code>HTTP</code> <code>TCP</code> <code>JSONRPC</code>的实现，可以很方便开发分布式的<code>Web</code>应用，但是我目前还不会，在学习中。遗憾的是<code>Go</code>没有提供<code>SOAP RPC</code>的支持~~~</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Golang </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言实现的WebSocket</title>
      <link href="/2018/07/15/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84WebSocket/"/>
      <url>/2018/07/15/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E7%9A%84WebSocket/</url>
      <content type="html"><![CDATA[<ul><li>最终的效果如下<a id="more"></a><img src="https://upload-images.jianshu.io/upload_images/5363507-1df3bbfdd7b78fff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Web端上传的信息"><br><img src="https://upload-images.jianshu.io/upload_images/5363507-394f230f0c32cdab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Web端得到的打印的信息"></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-1c4e57241edf86c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端的代码的实现"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-7335f93af21b8ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="服务端的信息"></p><ul><li>WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工(full-duplex)通信——允许服务器主动发送信息给客户端。WebSocket通信协议于2011年被<a href="https://baike.baidu.com/item/IETF" target="_blank" rel="noopener">IETF</a>定为标准RFC 6455，并被RFC7936所补充规范。WebSocket是<code>HTML5</code>的重要特性，它实现了基于浏览器的远程<code>socket</code>，它使浏览器和服务器可以进行全双工通信，许多浏览器<code>Firefox、Google Chrome和Safari</code>都已对此做了支持</li><li>在<code>WebSocket</code>出现之前，为了实现即时通信，采用的技术都是“轮询”，即在特定的时间间隔内，由浏览器对服务器发出HTTP Request，服务器在收到请求后，返回最新的数据给浏览器刷新，“轮询”使得浏览器需要对服务器不断发出请求，这样会占用大量带宽。</li><li>很多的游戏的服务都是采用的是<code>Socket</code>，因为HTTP协议相对而言比较耗费性能， 随着<code>HTML5</code>的发展，<code>WebSocket</code>也逐渐发展成为很多页游公司接下来开发的一些手段。</li><li>安卓推送的原理： C2DM 推送 (Google) C2DM 推送简介 : 全称 Cloudto Device Messaging, Google 提供的 推送解决方案;<ul><li>运行方式 : 提供一个轻量级机制, 允许服务器通知应用程序, 主动与客户端进行数据交互, 处理消息排队, 并向运行于目标设备的应用程序分发消息;</li><li>优点 : Google 提供的原生框架, 无需在应用中添加第三方代码 和 部署服务器端;</li><li>缺点 : 1.该推送依赖 Google 服务器, 需要绑定 Google 帐号, 目前在中国 Google 被屏蔽, 无法使用; 2. 许多手机厂商去掉了软件中的该模块;</li></ul></li><li><p>极光推送的原理：因为<code>IP v4</code> 的 IP 量有限，运营商分配给手机终端的 IP 是运营商内网的 IP，手机要连接 Internet，就需要通过运营商的网关做一个网络地址转换<code>Network Address Translation，NAT</code>。简单的说运营商的网关需要维护一个外网 IP、端口到内网 IP、端口的对应关系，以确保内网的手机可以跟 <code>Internet</code> 的服务器通讯。</p></li><li><p>Android 平台上长连接的实现</p><ul><li>Timer<br>Android 的 Timer 类可以用来计划需要循环执行的任务，Timer 的问题是它需要用 WakeLock 让 CPU 保持唤醒状态，这样会大量消耗手机电量，大大减短手机待机时间。</li><li>AlarmManager 这篇文章有介绍怎么使用<code>AlarmManager</code><a href="https://www.jianshu.com/p/82b76e0cb41e" target="_blank" rel="noopener">安卓网络和电量优化</a><br>AlarmManager 是 Android 系统封装的用于管理 RTC 的模块，RTC (Real Time Clock) 是一个独立的硬件时钟，可以在 CPU 休眠时正常运行，在预设的时间到达时，通过中断唤醒 CPU。<br>这意味着，如果我们用 AlarmManager 来定时执行任务，CPU 可以正常的休眠，只有在需要运行任务时醒来一段很短的时间。极光推送的 Android SDK 就是基于这种技术实现的。<a href="http://blog.jiguang.cn/jpush_wireless_push_principle/" target="_blank" rel="noopener">极光官方文档</a></li></ul></li><li><p>WebSocket URL的起始输入是<code>ws://</code>或是<code>wss://</code>（在SSL上）。一个带有特定报头的HTTP握手被发送到了服务器端，接着在服务器端或是客户端就可以通过JavaScript来使用某种套接口（socket），这一套接口可被用来通过事件句柄异步地接收数据。</p></li></ul><h4 id="WebSocket-原理"><a href="#WebSocket-原理" class="headerlink" title="WebSocket 原理"></a>WebSocket 原理</h4><ul><li>WebSocket的协议:在第一次<code>handshake</code>通过以后，连接便建立成功，其后的通讯数据都是以”\x00″开头，以”\xFF”结尾。在客户端，这个是透明的，<code>WebSocket</code>组件会自动将原始数据“掐头去尾”。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-edfd9eb6a6232a99.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="request的信息.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET http://localhost:8080/shiming HTTP/1.1</span><br><span class="line">Host: localhost:8080</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Cache-Control: no-cache</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Origin: file://</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0</span><br><span class="line">Accept-Encoding: gzip, deflate, sdch, br</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8</span><br><span class="line">Cookie: _ga=GA1.1.27955907.1529919744</span><br><span class="line">Sec-WebSocket-Key: PCD+pA79juC6tlBK9zD3Vw==</span><br><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span><br></pre></td></tr></table></figure></p><ul><li><code>Sec-WebSocket-Key</code>这个是个随机的值，是一个经过base64编写后的数据<code>Sec-WebSocket-Key: PCD+pA79juC6tlBK9zD3Vw==</code></li><li>然后服务器收到这个请求之后把这个字符串连接上一个固定的字符串 <code>258EAFA5-E914-47DA-95CA-C5AB0DC85B11</code> 为啥是这样的，我目前还不明白，仅仅是自己记录下而已。</li><li><p>最终得到:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PCD+pA79juC6tlBK9zD3Vw==258EAFA5-E914-47DA-95CA-C5AB0DC85B11</span><br></pre></td></tr></table></figure></li><li><p>对该字符使用shal 安全散列算法计算出二进制的值，然后用base64 对其进行编码，即可以得到握手的字符串: <code>8+5CLWTBYLARKoxBxS5uk6s6zZo=</code> ,如下图所示</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-174d684336e9c839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="response信息.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: 8+5CLWTBYLARKoxBxS5uk6s6zZo=</span><br></pre></td></tr></table></figure></p><ul><li><code>Sec-WebSocket-Accept</code>作为响应头的值反馈给客户端。</li></ul><h4 id="Go语言实现Websocket"><a href="#Go语言实现Websocket" class="headerlink" title="Go语言实现Websocket"></a>Go语言实现Websocket</h4><ul><li><p>由于Go语言标准包里面没有对<code>WebSocket</code>的支持，但是官方维护的<code>go.net</code>对这个有支持，所以可以获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/net/websocket</span><br></pre></td></tr></table></figure></li><li><p>但是有个小问题，当我 <code>go get</code>后，我在代码中导入包会报错，同时去掉x也不行，所以我在本地目录创建了一个x的目录，然后把<code>net</code>全部放进去了<br><img src="https://upload-images.jianshu.io/upload_images/5363507-b8bb98e7cdda07ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="注意问题.png"><br><img src="https://upload-images.jianshu.io/upload_images/5363507-952095a76359642d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导包"></p></li><li><p>html 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;好好学习&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    var sock = null;</span><br><span class="line">    // var wsuri = &quot;wss://127.0.0.1:8080&quot;; //本地的地址 是可以改变的哦</span><br><span class="line">     var wsuri = &quot;ws://localhost:8080/shiming&quot;; //本地的地址 是可以改变的哦</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    window.onload = function() &#123;</span><br><span class="line">        //可以看到客户端JS，很容易的就通过WebSocket函数建立了一个与服务器的连接sock，当握手成功后，会触发WebScoket对象的onopen事件，告诉客户端连接已经成功建立。客户端一共绑定了四个事件。</span><br><span class="line">        console.log(&quot;开始了 onload&quot;);</span><br><span class="line"></span><br><span class="line">        sock = new WebSocket(wsuri);</span><br><span class="line">        //建立连接后触发</span><br><span class="line">        sock.onopen = function() &#123;</span><br><span class="line">            console.log(&quot; 建立连接后触发 connected to &quot; + wsuri);</span><br><span class="line">        &#125;</span><br><span class="line">        // 关闭连接时候触发</span><br><span class="line">        sock.onclose = function(e) &#123;</span><br><span class="line">            console.log(&quot;关闭连接时候触发 connection closed (&quot; + e.code + &quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        // 收到消息后触发</span><br><span class="line">        sock.onmessage = function(e) &#123;</span><br><span class="line">            console.log(&quot;收到消息后触发 message received: &quot; + e.data);</span><br><span class="line">        &#125;</span><br><span class="line">        //发生错误的时候触发</span><br><span class="line">        sock.onerror=function (e) &#123;</span><br><span class="line">            console.log(&quot;发生错误时候触发&quot;+wsuri)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">     //如果sock被关闭掉了 这里 也会报错的啊</span><br><span class="line">    function send() &#123;</span><br><span class="line">        var msg = document.getElementById(&apos;message&apos;).value;</span><br><span class="line">        sock.send(msg);</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;h1&gt;GoWebSocketDemo&lt;/h1&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        Message: &lt;input id=&quot;message&quot; type=&quot;text&quot; value=&quot;你好啊  shiming 小哥哥  嘿嘿   &quot;&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;button onclick=&quot;send();&quot;&gt;给服务器发送消息&lt;/button&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>go 代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">    //草拟吗 自己创建的目录 哈哈哈哈哈    还好我比较聪明  要不然 就完蛋了  麻痹</span><br><span class="line">&quot;golang.org/x/net/websocket&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Go语言标准包里面没有提供对WebSocket的支持，但是在由官方维护的go.net子包中有对这个的支持 go get golang.org/x/net/websocket&quot;)</span><br><span class="line">//打印这个信息就，os.Exit(1)  退出程序</span><br><span class="line">//log.Fatal(&quot;shiming&quot;)  todo  草拟吗 啊   看清楚啊   后面的域名的地址 有个老子的名字啊</span><br><span class="line">    http.Handle(&quot;/shiming&quot;,websocket.Handler(Echo))</span><br><span class="line"> if err:=http.ListenAndServe(&quot;:8080&quot;,nil);err!=nil&#123;</span><br><span class="line"> log.Fatal(err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func Echo(w *websocket.Conn)  &#123;</span><br><span class="line">    var error error</span><br><span class="line">for   &#123;</span><br><span class="line">var reply string</span><br><span class="line">if  error= websocket.Message.Receive(w,&amp;reply);error!=nil&#123;</span><br><span class="line">fmt.Println(&quot;不能够接受消息 error==&quot;,error)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;能够接受到消息了--- &quot;,reply)</span><br><span class="line">msg:=&quot;我已经收到消息 Received:&quot;+reply</span><br><span class="line">//  连接的话 只能是   string；类型的啊</span><br><span class="line">fmt.Println(&quot;发给客户端的消息： &quot;+msg)</span><br><span class="line"></span><br><span class="line">if error = websocket.Message.Send(w, msg); error != nil &#123;</span><br><span class="line">fmt.Println(&quot;不能够发送消息 悲催哦&quot;)</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>说明一点：<code>http.Handle(&quot;/shiming&quot;,websocket.Handler(funName))</code>,如果在这里有路由的话，记得在  <code>html</code>中也要改成一样的, html中的代码 ：<code>var wsuri = &quot;ws://localhost:8080/shiming&quot;</code></p></li><li><code>x</code>目录自己创建一个，把<code>net</code>包剪切进去就可以</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言使用MySQL数据库</title>
      <link href="/2018/07/06/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2018/07/06/Go%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8MySQL%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<ul><li>本文主要介绍使用Go语言使用MySQL的搭建工作，适合移动端同学自己学习Go语言玩玩</li><li>前段时间撸了一个简单Spring-boot的Demo，最近学习了Go语言才发现，Go做起来更加的简单，我不推崇，不崇拜，但是我还得说一句，Go语言真好！！！<a id="more"></a><h4 id="一、搭建Go语言的环境"><a href="#一、搭建Go语言的环境" class="headerlink" title="一、搭建Go语言的环境"></a>一、搭建Go语言的环境</h4></li><li>安装Go的时候看到需要设置GOPATH变量，Go从1.1版本到1.7必须设置这个变量，而且不能和Go的安装目录一样，这个目录用来存放Go源码，Go的可运行文件，以及相应的编译之后的包文件。所以这个目录下面有三个子目录：<code>src、bin、pkg</code></li><li>从go 1.8开始，GOPATH环境变量现在有一个默认值，如果它没有被设置。在Windows上默认为%USERPROFILE%/go。</li><li>我自己设置的环境变量<br><img src="https://upload-images.jianshu.io/upload_images/5363507-1a32ce15cec746e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我自己设置的环境变量.png"></li><li><p>安装完成大概是这个效果<br><img src="https://upload-images.jianshu.io/upload_images/5363507-bf714c06911e1515.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>GOPATH 目录约定有三个子目录：</p><ul><li>src 存放源代码（比如：.go .c .h .s等）</li><li>pkg 编译后生成的文件（比如：.a）</li><li>bin 编译后生成的可执行文件<h4 id="二、Go开发工具"><a href="#二、Go开发工具" class="headerlink" title="二、Go开发工具"></a>二、Go开发工具</h4></li></ul></li><li><p>由于Go开发的工具巨多，作为一个菜鸟，目前不知道利弊，就当总结下资料，同时我自己使用的工具是<code>IDEA</code>，当然不是免费版，去网上搞个秘钥直接破解，因为<code>IDEA</code>真的很强大，这就不多提了，建议如果还在使用的<code>Android Studio</code>写安卓程序的小伙伴，可以试试使用<code>IDEA</code>，都差不多</p></li><li><p>1、LiteIDE<br>LiteIDE是一款专门为Go语言开发的跨平台轻量级集成开发环境（IDE），由visualfc编写。</p><ul><li>LiteIDE安装</li><li>下载地址 <a href="http://sourceforge.net/projects/liteide/files" target="_blank" rel="noopener">http://sourceforge.net/projects/liteide/files</a></li><li>源码地址 <a href="https://github.com/visualfc/liteide" target="_blank" rel="noopener">https://github.com/visualfc/liteide</a></li></ul></li><li>2、Sublime Text<br> 参考这个博客地址 <a href="http://blog.jobbole.com/88648/" target="_blank" rel="noopener">http://blog.jobbole.com/88648/</a></li><li>3、Visual Studio Code<br>  vscode是微软基于Electron和web技术构建的开源编辑器, 是一款很强大的编辑器。开源地址:<a href="https://github.com/Microsoft/vscode" target="_blank" rel="noopener">https://github.com/Microsoft/vscode</a></li><li>4、Eclipse<br>Eclipse！但是我好久都没用了，哈哈！！！ </li><li>5 、IntelliJ IDEA<br>idea是通过一个插件来支持go语言的高亮语法,代码提示和重构实现。虽然开发Go语言社区免费版就可以了，但是还是建议搞个正式版（具体百度，嘿嘿），如果不行就使用社区免费版！我自己就是使用的<code>IDEA</code><br>具体的步骤如下，就好像install个插件！<br><img src="https://upload-images.jianshu.io/upload_images/5363507-1f9bd04303496354.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><h4 id="三、搭建数据库，mysql-navicat"><a href="#三、搭建数据库，mysql-navicat" class="headerlink" title="三、搭建数据库，mysql + navicat"></a>三、搭建数据库，mysql + navicat</h4><ul><li>1 安装MySQL<br>我的安装包是公司的Java工程师发给我的，官网下载比较慢，文件为mysql-5.7.20-windx64.msi<br><img src="https://upload-images.jianshu.io/upload_images/5363507-42c90bc4a709bb52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><p>点击直接安装，在第二步Choosing a Setup Type的时候，选择Server only<br><img src="https://upload-images.jianshu.io/upload_images/5363507-31b6046bd9445715.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>然后一直Next，在输入数据库密码的时候输入App123，输入用户名的时候需要输入root，同时要把这两个记下来，后面连接数据库的时候需要用到 </p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-9fd5249356e29445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>2、用navicat操作数据库<br>navicat是个工具，可以直接到百度下载，然后连接数据库，输入你的密码和用户名即可<br><img src="https://upload-images.jianshu.io/upload_images/5363507-8ac63c8168ab91df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>新建一个数据库godbdemo，为什么叫godbdemo，因为在Go里面等下需要配置的数据库就叫它。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-e2a3340262a3a145.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>3、创建表userinfo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `userinfo` (</span><br><span class="line">`uid` INT(10) NOT NULL AUTO_INCREMENT,</span><br><span class="line">`username` VARCHAR(64) NULL DEFAULT NULL,</span><br><span class="line">`department` VARCHAR(64) NULL DEFAULT NULL,</span><br><span class="line">`created` DATE NULL DEFAULT NULL,</span><br><span class="line">PRIMARY KEY (`uid`)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul><p>使用Navicat Premium 创建数据库<br><img src="https://upload-images.jianshu.io/upload_images/5363507-365e288d8136449a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Navicat Premium 创建数据库1.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-d8bd1e8c611c3002.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Navicat Premium 创建数据库2.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-0d98a00f4b6f9475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用Navicat Premium 创建数据库3.png"></p><ul><li>ok，准备工作差不多了<h4 id="四、GitHub依赖的管理"><a href="#四、GitHub依赖的管理" class="headerlink" title="四、GitHub依赖的管理"></a>四、GitHub依赖的管理</h4></li><li>不可避免的我们会使用外部的依赖包包。go在这方面做的非常飘逸。go没有像java使用maven来管理依赖包、包版本，而是直接使用GOPATH来管理外部依赖。</li><li>Go官方没有提供数据库驱动，而是为开发数据库驱动定义了一些标准接口，开发者可以根据定义的接口来开发相应的数据库驱动，这样做有一个好处，只要是按照标准接口开发的代码， 以后需要迁移数据库时，不需要任何修改</li><li>1、MySQL驱动<br>我自己使用的是这个驱动<br><a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">https://github.com/go-sql-driver/mysql</a> 支持database/sql，全部采用go写。</li><li>主要理由：<ul><li>这个驱动比较新，维护的比较好</li><li>完全支持database/sql接口</li><li>支持keepalive，保持长连接,虽然<a href="http://www.mikespook.com/" target="_blank" rel="noopener">星星</a>fork的mymysql也支持keepalive，但不是线程安全的，这个从底层就支持了keepalive。</li></ul></li><li><p>2、使用<code>git</code>拉取代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ go get -u github.com/go-sql-driver/mysql</span><br></pre></td></tr></table></figure></li><li><p>最终的效果如下<br><img src="https://upload-images.jianshu.io/upload_images/5363507-8260346448e2e69b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="goPATh目录下的github目录的src目录.png"></p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-2dca9092efa06cb9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="goPATh目录下的github目录的pkg目录.png"></p><h4 id="5、代码实现"><a href="#5、代码实现" class="headerlink" title="5、代码实现"></a>5、代码实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;database/sql&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">_ &quot;github.com/go-sql-driver/mysql&quot;</span><br><span class="line">//其实这个就是Go设计的巧妙之处，我们在变量赋值的时候经常看到这个符号，它是用来忽略变量赋值的占位符，那么包引入用到这个符号也是相似的作用，这儿使用_的意思是引入后面的包名而不直接使用这个包中定义的函数，变量等资源。</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">//Go中支持MySQL的驱动目前比较多，有如下几种，有些是支持database/sql标准，而有些是采用了自己的实现接口,常用的有如下几种:</span><br><span class="line">//</span><br><span class="line">//https://github.com/go-sql-driver/mysql 支持database/sql，全部采用go写。</span><br><span class="line">//https://github.com/ziutek/mymysql 支持database/sql，也支持自定义的接口，全部采用go写。</span><br><span class="line">//https://github.com/Philio/GoMySQL 不支持database/sql，自定义接口，全部采用go写。</span><br><span class="line">//接下来的例子我主要以第一个驱动为例(我目前项目中也是采用它来驱动)，也推荐大家采用它，主要理由：</span><br><span class="line">//</span><br><span class="line">//这个驱动比较新，维护的比较好</span><br><span class="line">//完全支持database/sql接口</span><br><span class="line">//支持keepalive，保持长连接,虽然星星fork的mymysql也支持keepalive，但不是线程安全的，这个从底层就支持了keepalive。</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">//user@unix(/path/to/socket)/dbname?charset=utf8</span><br><span class="line">//user:password@tcp(localhost:5555)/dbname?charset=utf8</span><br><span class="line">//user:password@/dbname</span><br><span class="line">//user:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//spring.datasource.url =jdbc:mysql://localhost:3306/test</span><br><span class="line">//spring.datasource.username = root</span><br><span class="line">//#  注意密码的问题 ，数据的密码的</span><br><span class="line">//spring.datasource.password = App123</span><br><span class="line">    // sql.Open()函数用来打开一个注册过的数据库驱动，go-sql-driver中注册了mysql这个数据库驱动，第二个参数是DSN(Data Source Name)，它是go-sql-driver定义的一些数据库链接和配置信息   如上的图片</span><br><span class="line"></span><br><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:App123@tcp(localhost:3306)/godbdemo?charset=utf8&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">//插入数据 db.Prepare()函数用来返回准备要执行的sql操作，然后返回准备完毕的执行状态。</span><br><span class="line">stmt, err := db.Prepare(&quot;INSERT userinfo SET username=?,department=?,created=?&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">for i:=1;i&lt;100000 ;i++  &#123;</span><br><span class="line">//stmt.Exec()函数用来执行stmt准备好的SQL语句</span><br><span class="line">res, err := stmt.Exec(&quot;shiming&quot;, &quot;研发部门&quot;, &quot;20180706&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line">//shiming i== 9727 res=== &#123;0xc0420a0000 0xc0422f5000&#125;</span><br><span class="line">fmt.Println(&quot;shiming i==&quot;,i,&quot;res===&quot;,res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">res, err := stmt.Exec(&quot;shiming&quot;, &quot;研发部门&quot;, &quot;20180706&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">id, err := res.LastInsertId()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(id)</span><br><span class="line">//更新数据  传入的参数都是=?对应的数据，这样做的方式可以一定程度上防止SQL注入</span><br><span class="line">stmt, err = db.Prepare(&quot;update userinfo set username=? where uid=?&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">res, err = stmt.Exec(&quot;shimingupdate&quot;, id)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">affect, err := res.RowsAffected()</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">fmt.Println(affect)</span><br><span class="line"></span><br><span class="line">//查询数据  db.Query()函数用来直接执行Sql返回Rows结果。</span><br><span class="line">rows, err := db.Query(&quot;SELECT * FROM userinfo&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line"></span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">var uid int</span><br><span class="line">var username string</span><br><span class="line">var department string</span><br><span class="line">var created string</span><br><span class="line">err = rows.Scan(&amp;uid, &amp;username, &amp;department, &amp;created)</span><br><span class="line">checkErr(err)</span><br><span class="line">fmt.Println(uid)</span><br><span class="line">fmt.Println(username)</span><br><span class="line">fmt.Println(department)</span><br><span class="line">fmt.Println(created)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//删除数据</span><br><span class="line">//stmt, err = db.Prepare(&quot;delete from userinfo where uid=?&quot;)</span><br><span class="line">//checkErr(err)</span><br><span class="line">//</span><br><span class="line">//res, err = stmt.Exec(id)</span><br><span class="line">//checkErr(err)</span><br><span class="line">//</span><br><span class="line">//affect, err = res.RowsAffected()</span><br><span class="line">//checkErr(err)</span><br><span class="line">//</span><br><span class="line">//fmt.Println(affect)</span><br><span class="line"></span><br><span class="line">db.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func checkErr(err error) &#123;</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(err) //大概相当于  Java中的异常</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>sql.Open()</code>函数用来打开一个注册过的数据库驱动，<code>go-sql-driver</code>中注册了<code>mysql</code>这个数据库驱动，第二个参数是<code>DSN(Data Source Name)</code>，它是<code>go-sql-driver</code>定义的一些数据库链接和配置信息。它支持如下格式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user@unix(/path/to/socket)/dbname?charset=utf8</span><br><span class="line">user:password@tcp(localhost:5555)/dbname?charset=utf8</span><br><span class="line">user:password@/dbname</span><br><span class="line">user:password@tcp([de:ad:be:ef::ca:fe]:80)/dbname</span><br></pre></td></tr></table></figure></li></ul><p>在我的代码中是使用的是这种的方式<code>user:password@tcp(localhost:5555)/dbname?charset=utf8</code>,也就是这种的效果 <code>db, err := sql.Open(&quot;mysql&quot;, &quot;root:App123@tcp(localhost:3306)/godbdemo?charset=utf8&quot;)</code> 。</p><ul><li>其中的   <code>root</code>是数据库的用户名，  <code>App123</code>是数据库的密码。</li><li><p>几个关键的方法</p><ul><li>db.Prepare()函数用来返回准备要执行的sql操作，然后返回准备完毕的执行状态。</li><li>db.Query()函数用来直接执行Sql返回Rows结果。<ul><li>stmt.Exec()函数用来执行stmt准备好的SQL语句<h4 id="6、最终的效果如下"><a href="#6、最终的效果如下" class="headerlink" title="6、最终的效果如下"></a>6、最终的效果如下</h4>由于我的代码中有个循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for i:=1;i&lt;100000 ;i++  &#123;</span><br><span class="line">//stmt.Exec()函数用来执行stmt准备好的SQL语句</span><br><span class="line">res, err := stmt.Exec(&quot;shiming&quot;, &quot;研发部门&quot;, &quot;20180706&quot;)</span><br><span class="line">checkErr(err)</span><br><span class="line">//shiming i== 9727 res=== &#123;0xc0420a0000 0xc0422f5000&#125;</span><br><span class="line">fmt.Println(&quot;shiming i==&quot;,i,&quot;res===&quot;,res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>点击运行</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4f27432bdb554d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="最后，说明一点：以上的Demo是自己搭建玩玩，一定会有些差错，请大牛不要见怪哈"><a href="#最后，说明一点：以上的Demo是自己搭建玩玩，一定会有些差错，请大牛不要见怪哈" class="headerlink" title="最后，说明一点：以上的Demo是自己搭建玩玩，一定会有些差错，请大牛不要见怪哈~~~"></a>最后，说明一点：以上的<a href="https://github.com/Shimingli/GoDemo" target="_blank" rel="noopener">Demo</a>是自己搭建玩玩，一定会有些差错，请大牛不要见怪哈~~~</h4>]]></content>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Web的工作方式</title>
      <link href="/2018/06/14/Web%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/"/>
      <url>/2018/06/14/Web%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<ul><li>对于普通的上网，系统是这样做的：浏览器本身就是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应域名的对应的Ip地址，通过IP地址找到对应IP对应的服务器，要求建立TCP连接，等浏览器发送完HTTP Request包后，服务器接受到请求包之后才开始处理请求包，服务器调用自身服务，返回Http Response （响应包）：客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body）,等收到全部的内容随后断开与该服务器之间的TCP连接。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-8f5601da0c982aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用户访问一个Web站点的过程"><br><a id="more"></a></p><ul><li><p>Web服务器也被称为HTTP服务器，它通过HTTP协议与客户端通信（客户端通常指的是Web浏览器，手机的客户端也是浏览器实现的）</p></li><li><p>TCP/IP协议（来源于百度百科）：Transmission Control Protocol/Internet Protocol的简写，中译名为传输控制协议/<a href="https://baike.baidu.com/item/%E5%9B%A0%E7%89%B9%E7%BD%91" target="_blank" rel="noopener">因特网</a>互联协议，又名网络<a href="https://baike.baidu.com/item/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">通讯协议</a>，是Internet最基本的协议、Internet国际<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91" target="_blank" rel="noopener">互联网</a>络的基础，由<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B1%82/4329439" target="_blank" rel="noopener">网络层</a>的IP协议和<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536" target="_blank" rel="noopener">传输层</a>的TCP协议组成。TCP/IP 定义了电子设备如何连入<a href="https://baike.baidu.com/item/%E5%9B%A0%E7%89%B9%E7%BD%91/114119" target="_blank" rel="noopener">因特网</a>，以及数据如何在它们之间传输的标准。协议采用了4层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求。<a href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%97/10621346" target="_blank" rel="noopener">通俗</a>而言：TCP负责发现<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93/7078195" target="_blank" rel="noopener">传输</a>的问题，一有问题就发出信号，要求重新传输，直到所有<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/3204964" target="_blank" rel="noopener">数据安全</a>正确地传输到目的地。而IP是给<a href="https://baike.baidu.com/item/%E5%9B%A0%E7%89%B9%E7%BD%91/114119" target="_blank" rel="noopener">因特网</a>的每一台联网设备规定一个地址。</p></li><li><p>HTTP协议（来源于百度百科）：<a href="https://baike.baidu.com/item/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8535513" target="_blank" rel="noopener">超文本传输协议</a>（HTTP，HyperText Transfer Protocol)是<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91" target="_blank" rel="noopener">互联网</a>上应用最为广泛的一种<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/328636" target="_blank" rel="noopener">网络协议</a>。所有的<a href="https://baike.baidu.com/item/WWW" target="_blank" rel="noopener">WWW</a>文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收<a href="https://baike.baidu.com/item/HTML" target="_blank" rel="noopener">HTML</a>页面的方法。1960年美国人<a href="https://baike.baidu.com/item/Ted%20Nelson" target="_blank" rel="noopener">Ted Nelson</a>构思了一种通过<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338" target="_blank" rel="noopener">计算机</a>处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Ted Nelson组织协调万维网协会（World Wide Web Consortium）和<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%BD%9C%E5%B0%8F%E7%BB%84/6992977" target="_blank" rel="noopener">互联网工程工作小组</a>（Internet Engineering Task Force ）共同合作研究，最终发布了一系列的<a href="https://baike.baidu.com/item/RFC" target="_blank" rel="noopener">RFC</a>，其中著名的RFC 2616定义了HTTP 1.1。</p></li><li><p>Web服务器的工作的原理：</p><ul><li>客户端通过TCP/IP协议建立到服务器TCP连接</li><li>客户端想服务器发送HTTP协议请求包，请求服务器里的资源文档<ul><li>服务器向客户端发送发送HTTP协议应答包，如果请求的资源包含有动态语言的内容，那么服务器会调用动态语言的解析引擎负责处理动态内容，并将处理得到的数据返回给客户端</li><li>客户端与服务端断开，由客户端解释HTML文档，在客户端屏幕上渲染图形结果<br>###需要注意的是：客户端和服务器之间的通信是非持久连接的，也就是当服务器发送了应答后就与客户端断开连接了，等待下一次请求。</li></ul></li></ul></li></ul><p>##URL和DNS解析</p><ul><li>URL(Uniform Resource Locator)是“统一资源定位符”的英文缩写，用于描述一个网络上的资源</li><li>URL由三部分组成：资源类型、存放资源的主机域名、资源文件名。<ul><li>URL的一般语法格式为：(带方括号[]的为可选项)：scheme://host[:port#]/path/…/[?query-string][#anchor]<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">scheme://host[:port#]/path/.../[?query-string][#anchor]</span><br><span class="line">scheme         指定底层使用的协议(例如：http, https, ftp)</span><br><span class="line">host           HTTP服务器的IP地址或者域名</span><br><span class="line">port#          HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 http://www.cnblogs.com:8080/</span><br><span class="line">path           访问资源的路径</span><br><span class="line">query-string   发送给http服务器的数据</span><br><span class="line">anchor         锚</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>DNS解析</li><li>DNS(Domain Name System)是域名系统的英文缩写，是一种组织成域层次结构的计算机和网络服务命名的系统，它用于TCP/IP网络，它从事将主机名或者域名转换成为实际的IP地址的工作。NDS就是一位翻译官</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-965eb5144d95b3fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" DNS工作原理"></p><ul><li><p>更加详细的工作流程如下：</p><ul><li><p>1、在浏览器中输入’<a href="http://www.jianshu.com&#39;域名，操作系统会检查自己本地的hosts文件是否有这个网址映射的关系，如果有机会调用这个IP地址映射，完成域名解析（这里有个骚操作，在双十一的时候，把本地的hosts的文件指向你自己的静态页面，随便写个404的页面，告诉你女朋友说，服务器挂了，买不了，哈哈哈哈哈哈☺）" target="_blank" rel="noopener">www.jianshu.com&#39;域名，操作系统会检查自己本地的hosts文件是否有这个网址映射的关系，如果有机会调用这个IP地址映射，完成域名解析（这里有个骚操作，在双十一的时候，把本地的hosts的文件指向你自己的静态页面，随便写个404的页面，告诉你女朋友说，服务器挂了，买不了，哈哈哈哈哈哈☺）</a><br><img src="https://upload-images.jianshu.io/upload_images/5363507-c95e1b79e1c55956.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hosts"></p><ul><li>2、如果<code>hosts</code>没有这个域名的映射，就会查找本地的DNS解析器缓存，是否有这个网址映射的关系，如果有，直接返回，完成域名解析。</li><li><p>3、如果<code>hosts</code>于本地DNS解析器缓存都没有相应的网址映射关系，首先会找<code>TCP/IP</code>参数中设置的首选的DNS服务器（有时候我们翻墙就要改动这里），本地DNS服务器，此服务器收到查询时候，如果要查询的域名，它包含本地配置区域资源中，则返回解析结果给客户机，完成域名解析，这个解析具有权威性<br><img src="https://upload-images.jianshu.io/upload_images/5363507-24b3b29997ab7445.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS设置"></p></li><li><p>4、如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已经缓存了此网址的映射的关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性</p></li><li>5、如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器设置（是否设置了转发器）进行查询，如果没有使用转发模式，本地的DNS就把请求转发到根DNS服务器，根服务器收到请求了会去判断这个域名（.com）是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地服务收到服务器的IP信息了，将会联系负责<code>.com</code>的这台服务器。这台服务器负责<code>.com</code>域的服务器收到请求了，如果自己无法解析，它就会找一个管理<code>.com</code>域下一级DNS服务器地址(jianshu.com)给本地的DNS服务器。当本地的DNS服务器收到这个地址后，就会找<code>jianshu.com</code>,重复上面的动作，进行查询，直到找到<code>www.jianshu.com</code>这个地址。</li><li>6、如果用的转发的模式，此DNS服务器就会把这个请求转发至上一级DNS服务器，由上一级服务器进行解析，如果上一层服务器不能解析，或者是根DNS服务器吧请求转至上上级。不管本地DNS服务器用的是转发，还是根提示，左后都是把结果返回给本地DNS服务器，由此DNS服务器在返回给客户机<br><img src="https://upload-images.jianshu.io/upload_images/5363507-75332fcf7f5f1f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" DNS解析的整个流程"></li></ul></li></ul></li><li><p>所谓递归查询过程：就是 “查询的递交者” 更替,查询提交者不断的更变,</p></li><li><p>而迭代查询过程： 则是 “查询的递交者”不变。</p></li><li><p>举个例子来说，你想知道某个一起上法律课的女孩的电话，并且你偷偷拍了她的照片，回到寝室告诉一个很仗义的哥们儿，这个哥们儿二话没说，拍着胸脯告诉你，甭急，我替你查(此处完成了一次递归查询，即，问询者的角色更替)。然后他拿着照片问了学院大四学长，学长告诉他，这姑娘是xx系的；然后这哥们儿马不停蹄又问了xx系的办公室主任助理同学，助理同学说是xx系yy班的，然后很仗义的哥们儿去xx系yy班的班长那里取到了该女孩儿电话。(此处完成若干次迭代查询，即，问询者角色不变，但反复更替问询对象)最后，他把号码交到了你手里。完成整个查询过程。</p></li><li><p>通过上面的步骤，最终获取IP地址，也就是浏览器最后发起请求的时候基于IP来和服务器做信息交换的</p></li></ul><p>####HTTP协议详解 </p><ul><li>HTTP是一种让<code>Web服务器</code>与浏览器(客户端)通过<code>Internet发送与接收数据的协议</code>,它建立在<code>TCP协议</code>之上，一般采用<code>TCP的80端口</code>。</li><li>它是一个请求、响应协议–客户端发出一个请求，服务器响应这个请求。</li><li>在HTTP中，客户端总是通过建立一个连接与发送一个HTTP请求来发起一个事务。</li><li>服务器不能主动去与客户端联系，也不能给客户端发出一个回调连接。客户端与服务器端都可以提前中断一个连接。例如，当浏览器下载一个文件时，你可以通过点击“停止”键来中断文件的下载，关闭与服务器的HTTP连接。</li><li>HTTP协议是无状态的，同一个客户端的这次请求和上次请求是没有对应关系，对HTTP服务器来说，它并不知道这两个请求是否来自同一个客户端。为了解决这个问题， <code>Web程序</code>引入了<code>Cookie机制</code>来维护连接的可持续状态。</li><li><code>Cookie</code>意为“甜饼”，是由W3C组织提出，最早由Netscape社区发展的一种机制。目前Cookie已经成为标准，所有的主流浏览器如IE、Netscape、Firefox、Opera等都支持Cookie。由于HTTP是一种无状态的协议，服务器单从网络连接上无从知道客户身份。怎么办呢？就给客户端们颁发一个通行证吧，每人一个，无论谁访问都必须携带自己通行证。这样服务器就能从通行证上确认客户身份了。这就是Cookie的工作原理。<ul><li>HTTP协议是建立在TCP协议之上的，因此TCP攻击一样会影响HTTP的通讯，例如比较常见的一些攻击：<code>SYN Flood</code>是当前最流行的DoS（拒绝服务攻击）与DdoS（分布式拒绝服务攻击）的方式之一，这是一种利用<code>TCP协议</code>缺陷，发送大量伪造的TCP连接请求，从而使得被攻击方资源耗尽（CPU满负荷或内存不足）的攻击方式。</li></ul></li></ul><h4 id="HTTP请求包（浏览器信息）"><a href="#HTTP请求包（浏览器信息）" class="headerlink" title="HTTP请求包（浏览器信息）"></a>HTTP请求包（浏览器信息）</h4><ul><li><p>Request包的结构, Request包分为3部分，第一部分叫Request line（请求行）, 第二部分叫Request header（请求头）,第三部分是body（主体）。header和body之间有个空行，请求包的例子所示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET /domains/example/ HTTP/1.1//请求行: 请求方法 请求URI HTTP协议/协议版本</span><br><span class="line">Host：www.iana.org//服务端的主机名</span><br><span class="line">User-Agent：Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4//浏览器信息</span><br><span class="line">Accept：text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8//客户端能接收的MIME</span><br><span class="line">Accept-Encoding：gzip,deflate,sdch//是否支持流压缩</span><br><span class="line">Accept-Charset：UTF-8,*;q=0.5//客户端字符编码集</span><br><span class="line">//空行,用于分割请求头和消息体</span><br><span class="line">//消息体,请求资源参数,例如POST传递的参数</span><br></pre></td></tr></table></figure></li><li><p>抓取简书的首页的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Request URL:https://www.jianshu.com/</span><br><span class="line">Request Method:GET</span><br><span class="line">Status Code:304 Not Modified</span><br><span class="line">Remote Address:127.0.0.1:8888</span><br><span class="line">Response Headers</span><br><span class="line">view source</span><br><span class="line">Cache-Control:max-age=0, private, must-revalidate</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Content-Security-Policy:script-src &apos;self&apos; &apos;unsafe-inline&apos; &apos;unsafe-eval&apos; *.jianshu.com *.jianshu.io api.geetest.com static.geetest.com dn-staticdown.qbox.me zz.bdstatic.com *.google-analytics.com hm.baidu.com push.zhanzhang.baidu.com res.wx.qq.com qzonestyle.gtimg.cn as.alipayobjects.com ;style-src &apos;self&apos; &apos;unsafe-inline&apos; *.jianshu.com *.jianshu.io api.geetest.com static.geetest.com ;</span><br><span class="line">Date:Mon, 02 Jul 2018 09:10:04 GMT</span><br><span class="line">ETag:W/&quot;e5bf3f5c57dcac3addf979d6e74fa906&quot;</span><br><span class="line">Server:Tengine</span><br><span class="line">Set-Cookie:locale=zh-CN; path=/</span><br><span class="line">Strict-Transport-Security:max-age=31536000; includeSubDomains; preload</span><br><span class="line">X-Content-Type-Options:nosniff</span><br><span class="line">X-Dscp-Value:0</span><br><span class="line">X-Frame-Options:DENY</span><br><span class="line">X-Request-Id:01a51f5d-b6ea-45c2-91a7-5fdec3a8eb70</span><br><span class="line">X-Runtime:0.022833</span><br><span class="line">X-Via:1.1 PSfjfzdx2mj93:9 (Cdn Cache Server V2.0), 1.1 yangdianxin66:10 (Cdn Cache Server V2.0)</span><br><span class="line">X-XSS-Protection:1; mode=block</span><br><span class="line">Request Headers</span><br><span class="line">view source</span><br><span class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Encoding:gzip, deflate, sdch, br</span><br><span class="line">Accept-Language:zh-CN,zh;q=0.8</span><br><span class="line">Cache-Control:max-age=0</span><br><span class="line">Connection:keep-alive</span><br><span class="line">Cookie:__guid=163745081.662820947905634200.1526461023901.8958; signin_redirect=https%3A%2F%2Fwww.jianshu.com%2F; read_mode=day; default_font=font2; monitor_count=5; sensorsdata2015jssdkcross=%7B%22distinct_id%22%3A%22163682ac930acd-0e49b894cda713-6b1b1279-2073600-163682ac9319a0%22%2C%22%24device_id%22%3A%22163682ac930acd-0e49b894cda713-6b1b1279-2073600-163682ac9319a0%22%2C%22props%22%3A%7B%22%24latest_traffic_source_type%22%3A%22%E7%9B%B4%E6%8E%A5%E6%B5%81%E9%87%8F%22%2C%22%24latest_referrer%22%3A%22%22%2C%22%24latest_referrer_host%22%3A%22%22%2C%22%24latest_search_keyword%22%3A%22%E6%9C%AA%E5%8F%96%E5%88%B0%E5%80%BC_%E7%9B%B4%E6%8E%A5%E6%89%93%E5%BC%80%22%7D%7D; Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1528795394,1530514591; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1530522699; locale=zh-CN</span><br><span class="line">Host:www.jianshu.com</span><br><span class="line">If-None-Match:W/&quot;e5bf3f5c57dcac3addf979d6e74fa906&quot;</span><br><span class="line">Upgrade-Insecure-Requests:1</span><br><span class="line">User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36</span><br></pre></td></tr></table></figure></li><li><p>HTTP协议定义了很多与服务器交互的请求方法，最基本的有4种，分别是GET,POST,PUT,DELETE。</p></li><li>一个URL地址用于描述一个网络上的资源</li><li>而HTTP中的GET, POST, PUT, DELETE就对应着对这个资源的查，增，改，删4个操作。</li><li>最常见的就是GET和POST了。GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。</li></ul><h4 id="由于简书地址是https-我通过fiddler去抓一个不是http的，看起来比较好看"><a href="#由于简书地址是https-我通过fiddler去抓一个不是http的，看起来比较好看" class="headerlink" title="由于简书地址是https,我通过fiddler去抓一个不是http的，看起来比较好看"></a>由于简书地址是<code>https</code>,我通过fiddler去抓一个不是http的，看起来比较好看</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-ffe931a62ec9b6b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get请求"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-c1cbdc9b1689de16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="post请求"></p><ul><li>可以得出GET和POST的区别:<ul><li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456。POST方法是把提交的数据放在HTTP包的body中。<ul><li>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制。</li><li>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码。</li></ul></li></ul></li></ul><h4 id="HTTP响应包（服务器信息）"><a href="#HTTP响应包（服务器信息）" class="headerlink" title="HTTP响应包（服务器信息）"></a>HTTP响应包（服务器信息）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK//状态行</span><br><span class="line">Server: nginx/1.0.8//服务器使用的WEB软件名及版本</span><br><span class="line">Date:Date: Tue, 30 Oct 2012 04:14:25 GMT//发送时间</span><br><span class="line">Content-Type: text/html//服务器发送信息的类型</span><br><span class="line">Transfer-Encoding: chunked//表示发送HTTP包是分段发的</span><br><span class="line">Connection: keep-alive//保持连接状态</span><br><span class="line">Content-Length: 90//主体内容长度</span><br><span class="line">//空行 用来分割消息头和主体</span><br><span class="line">&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;... //消息体</span><br></pre></td></tr></table></figure><ul><li><p>获取新浪首页的数据如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 02 Jul 2018 09:21:33 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 576063</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Mon, 02 Jul 2018 09:20:01 GMT</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">X-Powered-By: shci_v1.03</span><br><span class="line">Expires: Mon, 02 Jul 2018 09:22:28 GMT</span><br><span class="line">Cache-Control: max-age=60</span><br><span class="line">Age: 4</span><br><span class="line">Via: http/1.1 ctc.ningbo.ha2ts4.97 (ApacheTrafficServer/6.2.1 [cHs f ]), http/1.1 ctc.xiamen.ha2ts4.41 (ApacheTrafficServer/6.2.1 [cHs f ])</span><br><span class="line">X-Via-Edge: 153052329372561c48b773cd64cde73000845</span><br><span class="line">X-Cache: HIT.41</span><br><span class="line">X-Via-CDN: f=edge,s=ctc.xiamen.ha2ts4.34.nb.sinaedge.com,c=119.139.196.97;f=Edge,s=ctc.xiamen.ha2ts4.41,c=222.76.214.34</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!-- [ published at 2018-07-02 17:20:00 ] --&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;新浪首页&lt;/title&gt;</span><br><span class="line">&lt;meta name=&quot;keywords&quot; content=&quot;新浪,新浪网,SINA,sina,sina.com.cn,新浪首页,门户,资讯&quot; /&gt;</span><br><span class="line">&lt;meta name=&quot;description&quot; content=&quot;新浪网为全球用户24小时提供全面及时的中文资讯，内容覆盖国内外突发新闻事件、体坛赛事、娱乐时尚、产业资讯、实用信息等，设有新闻、体育、娱乐、财经、科技、房产、汽车等30多个内容频道，同时开设博客、视频、论坛等自由互动交流空间。&quot; /&gt;</span><br><span class="line">    &lt;link rel=&quot;mask-icon&quot; sizes=&quot;any&quot; href=&quot;//www.sina.com.cn/favicon.svg&quot; color=&quot;red&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;stencil&quot; content=&quot;PGLS000022&quot; /&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p><code>Response</code>包中的第一行叫做状态行，由HTTP协议版本号、状态码、状态消息三部分组成</p></li><li>状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response。HTTP/1.1协议中定义了5类状态码，第一个数字定义了响应的类别<ul><li>1XX：提示信息-表示请求已被成功接收，继续处理</li><li>2XX：成功 。表示请求已被成功接收，理解，接收</li><li>3XX: 重定向：要完成请求必须进行更进一步的处理</li><li>4XX：客户端错误：请求语法错误或者是请求无法实现</li><li>5XX：服务器错误，服务器未能够实现合法的请求</li></ul></li><li><p>当输入的简书的地址为’htt://<a href="http://www.jianshu.com/&#39;的时候，状态码为`301`" target="_blank" rel="noopener">www.jianshu.com/&#39;的时候，状态码为`301`</a><br><img src="https://upload-images.jianshu.io/upload_images/5363507-cd19ecadfecd9e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>301 Moved Permanently<br>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址</p></li><li><p>使用网易云在听歌的时候<br><img src="https://upload-images.jianshu.io/upload_images/5363507-cfd00450a0861b7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>206 Partial Content<br>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载</p></li></ul><h4 id="HTTP协议是无状态的和Connection-keep-alive的区别"><a href="#HTTP协议是无状态的和Connection-keep-alive的区别" class="headerlink" title="HTTP协议是无状态的和Connection: keep-alive的区别"></a>HTTP协议是无状态的和Connection: keep-alive的区别</h4><ul><li>无状态是指协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。从另一方面讲，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。</li><li>HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（面对无连接）。</li><li>从HTTP/1.1起，默认都开启了Keep-Alive保持连接特性，简单地说，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的TCP连接。</li><li>Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同服务器软件（如Apache）中设置这个时间。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-760d4b35e0b2db65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一次请求的request和response"></p><ul><li>一次URL请求但是左边栏里面为什么会有那么多的资源请求？<ul><li>这个就是浏览器的一个功能，第一次请求url，服务器端返回的是<code>html</code>页面，然后浏览器开始渲染HTML：当解析到HTML DOM里面的图片连接，css脚本和js脚本的链接，浏览器就会自动发起一个请求静态资源的HTTP请求，获取相对应的静态资源，然后浏览器就会渲染出来，最终将所有资源整合、渲染，完整展现在我们面前的屏幕上。</li></ul></li><li>最后说明一点 ：网页优化方面有一项措施是减少HTTP请求次数，就是把尽量多的css和js资源合并在一起，目的是尽量减少网页请求静态资源的次数，提高网页加载速度，同时减缓服务器的压力。</li><li>鉴于本人的能力有限，如有错误还望指出，tks</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Web </tag>
            
            <tag> 工作方式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析:View的绘制流程</title>
      <link href="/2018/06/08/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
      <url>/2018/06/08/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-View%E7%9A%84%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<ul><li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 <h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2></li><li><code>View</code>是何时开始绘制的?<code>Activity</code>走了<code>onCreate</code>方法吗？这篇文章就是从程序的入口<code>ActivityThread</code>入口程序，去解释<code>View中的measure()方法</code>、<code>View中的layout</code>、<code>View中的draw</code>怎么开始调用的，非常有意思！虽然好多的技术文档，在半个月前已经做好了，这篇文章，对我自己来讲的话，是个很好的复习~~</li><li>为了更好地阐述着这篇文章，我这里就直接抛出结论了，为啥会这样的，在下篇文章会讲到，这里就记住一点，在<code>Activity onResume</code>后，调用了<code>View onAttachedToWindow</code> 才会开始<code>View measure</code><a id="more"></a><img src="https://upload-images.jianshu.io/upload_images/5363507-9c0147257f0e015b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的生命周期和View的生命周期.jpg"></li><li><p>为什么会这样子？先看<code>ActivityThread</code>类里面有个内部<code>private class H extends Handler</code>这就是系统的<code>Handler</code>，具体分析请看<a href="https://www.jianshu.com/p/a2c53e96cae6" target="_blank" rel="noopener">Android源码分析（Handler机制）</a>,里面有个<code>case RESUME_ACTIVITY</code>,获取焦点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case RESUME_ACTIVITY:</span><br><span class="line">              Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;);</span><br><span class="line">              SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">              handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true,</span><br><span class="line">                      args.argi3, &quot;RESUME_ACTIVITY&quot;);</span><br><span class="line">              Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"> break;</span><br></pre></td></tr></table></figure></li><li><p>handleResumeActivity()方法,这里只截取了关键的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line">        //在这里执行performResumeActivity的方法中会执行Activity的onResume()方法</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                            a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                            + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line">            final int forwardBit = isForward ?</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line">            boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">            if (!willBeVisible) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    throw e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //PhoneWindow在这里获取到</span><br><span class="line">            if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                //DecorView在这里获取到</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                //获取ViewManager对象，在这里getWindowManager()实质上获取的是ViewManager的子类对象WindowManager</span><br><span class="line">                // TODO: 2018/5/24 WindowManager</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                if (r.mPreserveWindow) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    r.mPreserveWindow = false;</span><br><span class="line">                    // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                    // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                    // the decor view we have to notify the view root that the</span><br><span class="line">                    // callbacks may have changed.</span><br><span class="line">                    //获取ViewRootImpl对象</span><br><span class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.notifyChildRebuilt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第一点分析得出<code>performResumeActivity()</code>肯定先于<code>wm.addView(decor, l);</code>执行的~这也是为啥我们 <code>Activity</code>先获取焦点了，才去绘制<code>View</code></p></li><li>performResumeActivity(),可以得出调用的是<code>r.activity.performResume();</code><br><img src="https://upload-images.jianshu.io/upload_images/5363507-c61528fcbe49a9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="performResumeActivity"></li><li><p>关于<code>r.activity.performResume();</code>；这里也可以，看出，在activity 中的fragment获取焦点要晚于activity，虽然这是常识。注意这个方法<code>mInstrumentation.callActivityOnResume(this);</code>;然后才会执行<code>onPostResume</code>;这也就是为什么，Activity先获取焦点，后执行<code>onPostResume()</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void performResume() &#123;</span><br><span class="line">       performRestart();</span><br><span class="line">       mInstrumentation.callActivityOnResume(this);</span><br><span class="line">       mCalled = false;</span><br><span class="line">      //这里也可以，看出，在activity 中的fragment获取焦点要晚于activity，虽然这是常识</span><br><span class="line">       mFragments.dispatchResume();</span><br><span class="line">       mFragments.execPendingActions();</span><br><span class="line">       onPostResume();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>关注这个方法<code>mInstrumentation.callActivityOnResume(this)</code>;果然不出所料，这里执行了<code>activity.onResume();</code>;<br><img src="https://upload-images.jianshu.io/upload_images/5363507-06a0a0bfd5bd0ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callActivityOnResume.png"></p></li><li><p>既然在上面知道了，activity 获取焦点，会在上面执行，那么View的绘制就会在下面的函数中进行。</p><ul><li>1、获取PhoneWindow；  <code>activity.getWindow()</code>,<code>Window</code>类的唯一子类<ul><li>2、获取<code>window.getDecorView()</code>;DecorView,PhoneWindow的内部类，<code>private final class DecorView extends FrameLayout</code> ，安卓的事件分发和它密切相关<a href="https://www.jianshu.com/p/f7e3a14daf51" target="_blank" rel="noopener">Android源码分析（事件传递）</a>,也就是从<code>Activity</code> 传递到 <code>ViewGroup</code>的过程~~</li><li>3、获取<code>ViewManager wm = a.getWindowManager();</code>，其实也就是<code>activity.getWindowManager()</code>,也就是获取的是<code>ViewManager</code>的子类对象<code>WindowManager</code>,这里的知道<code>WindowManager</code>其实也是一个接口.<br><img src="https://upload-images.jianshu.io/upload_images/5363507-14b4c1d369701373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li><li>4、  <code>wm.addView(decor, l);</code>,也就是到这里来了，<code>WindowManager.addView(decor,l)</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//PhoneWindow在这里获取到</span><br><span class="line">           if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">               r.window = r.activity.getWindow();</span><br><span class="line">               //DecorView在这里获取到</span><br><span class="line">               View decor = r.window.getDecorView();</span><br><span class="line">               decor.setVisibility(View.INVISIBLE);</span><br><span class="line">               //获取ViewManager对象，在这里getWindowManager()实质上获取的是ViewManager的子类对象WindowManager</span><br><span class="line">               // TODO: 2018/5/24 WindowManager</span><br><span class="line">               ViewManager wm = a.getWindowManager();</span><br><span class="line">               WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">               a.mDecor = decor;</span><br><span class="line">               l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">               l.softInputMode |= forwardBit;</span><br><span class="line">               if (r.mPreserveWindow) &#123;</span><br><span class="line">                   a.mWindowAdded = true;</span><br><span class="line">                   r.mPreserveWindow = false;</span><br><span class="line">                   // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                   // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                   // the decor view we have to notify the view root that the</span><br><span class="line">                   // callbacks may have changed.</span><br><span class="line">                   //获取ViewRootImpl对象</span><br><span class="line">                   ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                   if (impl != null) &#123;</span><br><span class="line">                       impl.notifyChildRebuilt();</span><br><span class="line">                   &#125;</span><br><span class="line">               if (!a.mWindowAdded) &#123;</span><br><span class="line">                       a.mWindowAdded = true;</span><br><span class="line">                       //在这里WindowManager将DecorView添加到PhoneWindow中</span><br><span class="line">                       wm.addView(decor, l);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>分析到这里来了，会通过<code>WindowManager.addView(decor,l)</code>.我们需要去找<code>WindowManager</code>的实现。<code>WindowManagerImpl</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class WindowManagerImpl implements WindowManager &#123;</span><br><span class="line">    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">   @Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>去寻找<code>WindowManagerGlobal</code>的<code>addView()</code>方法。这里有个单利模式,在源码好多地方使用的单利模式都是这样，并没有进行双重判断，在老牌的图片加载框架<code>ImageLoader</code>也是这样获取单利对象，如果想了解更多设计模式的姿势，可以看这片文章<a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static WindowManagerGlobal getInstance() &#123;</span><br><span class="line">      synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">          if (sDefaultWindowManager == null) &#123;</span><br><span class="line">              sDefaultWindowManager = new WindowManagerGlobal();</span><br><span class="line">          &#125;</span><br><span class="line">          return sDefaultWindowManager;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>在这里！就是<code>WindowManagerGlobal.addView()</code>的关键的方法，我做了两个注释，一个是<code>view.setLayoutParams(wparams);</code>,这个方法非常有意思，最近在研究ViewGroup的源码，发现不论什么情况下，View或者是ViewGroup都会有两次测量，这里是根本的原因，我先给结论。<br>api26：执行2次onMeasure、1次onLayout、1次onDraw。<br>api25-24：执行2次onMeasure、2次onLayout、1次onDraw，<br>api23-21：执行3次onMeasure、2次onLayout、1次onDraw，<br>api19-16：执行2次onMeasure、2次onLayout、1次onDraw，<br>API等级24：Android 7.0 Nougat<br>API等级25：Android 7.1 Nougat<br>API等级26：Android 8.0 Oreo<br>API等级27：Android 8.1 Oreo<br>后续我会做一篇文章详细解释下，为什么会这样，这里不过多的解释了，自提一句，非常有意思的代码！以前还会有两次的layout，说明谷歌也在优化安卓 <code>framework</code>。todo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123;</span><br><span class="line">   ...</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">          //view setLLayoutParams()在这里</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    try &#123;</span><br><span class="line">              // TODO: 2018/6/4  这里呢？就是ViewRootImpl 调用的setView的方法，就在这里</span><br><span class="line">              root.setView(view, wparams, panelParentView);</span><br><span class="line">          &#125; catch (RuntimeException e) &#123;</span><br><span class="line">              // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">              if (index &gt;= 0) &#123;</span><br><span class="line">                  removeViewLocked(index, true);</span><br><span class="line">              &#125;</span><br><span class="line">              throw e;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li><li><p>ok，现在继续的关注这个方法<code>ViewRootImpl.setView(view, wparams, panelParentView)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">      synchronized (this) &#123;   try &#123;</span><br><span class="line">               // TODO: 2018/6/4 这里传入的attrs 决定了View 或者是ViewGroup是否会onMeasure 两次</span><br><span class="line">              mWindowAttributes.copyFrom(attrs);</span><br><span class="line">              &#125; catch (RemoteException e) &#123;</span><br><span class="line">                 </span><br><span class="line">                  // TODO: 2018/5/24 就会调动这里的来</span><br><span class="line">                  unscheduleTraversals();</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  if (restore) &#123;</span><br><span class="line">                      attrs.restore();</span><br><span class="line">                  &#125; if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                  </span><br><span class="line">                  // TODO: 2018/5/24 就会调动这里的来</span><br><span class="line">                  unscheduleTraversals();&#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure></li><li><p>unscheduleTraversals(),没有Activity获取焦点的时候，这个方法肯定会执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void unscheduleTraversals() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = false;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关注mTraversalRunnable对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          doTraversal();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>doTraversal()方法,Traversal翻译过来就是遍历的意思~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// TODO: 2018/5/24  到这里来了 ----&gt;     Traversal 遍历</span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = false;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        performTraversals();</span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析"><a href="#performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析" class="headerlink" title="performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析"></a><code>performTraversals</code>这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">     * 最终会调动到这里</span><br><span class="line">     * ViewRootImpl的performTraversals()方法完成具体的视图绘制流程</span><br><span class="line">     */</span><br><span class="line">    private void performTraversals() &#123;</span><br><span class="line">        // cache mView since it is used so much below...</span><br><span class="line">        //mView 就是DecorView根布局</span><br><span class="line">        final View host = mView;</span><br><span class="line"></span><br><span class="line">        if (DBG) &#123;</span><br><span class="line">            System.out.println(&quot;======================================&quot;);</span><br><span class="line">            System.out.println(&quot;performTraversals&quot;);</span><br><span class="line">            host.debug();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果host=null  或者是mAdded=false 直接就return了</span><br><span class="line">        if (host == null || !mAdded)</span><br><span class="line">            return;</span><br><span class="line">        //是否正在遍历</span><br><span class="line">        mIsInTraversal = true;</span><br><span class="line">        //是否马上需要绘制View</span><br><span class="line">        mWillDrawSoon = true;</span><br><span class="line">        boolean windowSizeMayChange = false;</span><br><span class="line">        boolean newSurface = false;</span><br><span class="line">        boolean surfaceChanged = false;</span><br><span class="line">        /**</span><br><span class="line">         * 这个WindowMananger 这里标记了 是否是需要 onMeasure 两次 哈哈</span><br><span class="line">         */</span><br><span class="line">        // TODO: 2018/6/4</span><br><span class="line">        WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">        /*</span><br><span class="line">        顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">         */</span><br><span class="line">        int desiredWindowWidth;</span><br><span class="line">        int desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">        final int viewVisibility = getHostVisibility();</span><br><span class="line">        final boolean viewVisibilityChanged = !mFirst</span><br><span class="line">                &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded);</span><br><span class="line">        final boolean viewUserVisibilityChanged = !mFirst &amp;&amp;</span><br><span class="line">                ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE));</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams params = null;</span><br><span class="line">        if (mWindowAttributesChanged) &#123;</span><br><span class="line">            mWindowAttributesChanged = false;</span><br><span class="line">            surfaceChanged = true;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line">        CompatibilityInfo compatibilityInfo =</span><br><span class="line">                mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">        if (compatibilityInfo.supportsScreen() == mLastInCompatMode) &#123;</span><br><span class="line">            params = lp;</span><br><span class="line">            mFullRedrawNeeded = true;</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line">            if (mLastInCompatMode) &#123;</span><br><span class="line">                params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                mLastInCompatMode = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                mLastInCompatMode = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChangesFlag = 0;</span><br><span class="line"></span><br><span class="line">        Rect frame = mWinFrame;</span><br><span class="line">        //在构造方法中mFirst已经设置为true，表示是否是第一次绘制DecorView</span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">            mFullRedrawNeeded = true;</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line"></span><br><span class="line">            final Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            // TODO: 2018/5/25 注意这个方法内部做了什么</span><br><span class="line">            /*</span><br><span class="line">             return lp.type == TYPE_STATUS_BAR_PANEL</span><br><span class="line">                || lp.type == TYPE_INPUT_METHOD</span><br><span class="line">                || lp.type == TYPE_VOLUME_OVERLAY;</span><br><span class="line">             */</span><br><span class="line">            // 如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">            //就是除了状态栏</span><br><span class="line">            if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">                Point size = new Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //否者顶层视图DecorView所需要的窗口的宽度和高度就是整个屏幕的宽度</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We used to use the following condition to choose 32 bits drawing caches:</span><br><span class="line">            // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888</span><br><span class="line">            // However, windows are now always 32 bits by default, so choose 32 bits</span><br><span class="line">            mAttachInfo.mUse32BitDrawingCache = true;</span><br><span class="line">            mAttachInfo.mHasWindowFocus = false;</span><br><span class="line">            mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mLastConfigurationFromResources.setTo(config);</span><br><span class="line">            mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">            // Set the layout direction if it has not been set before (inherit is the default)</span><br><span class="line">            if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">                host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">            &#125;</span><br><span class="line">            host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">            dispatchApplyInsets(host);</span><br><span class="line">            //Log.i(mTag, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            desiredWindowWidth = frame.width();</span><br><span class="line">            desiredWindowHeight = frame.height();</span><br><span class="line">            if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">                if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame);</span><br><span class="line">                mFullRedrawNeeded = true;</span><br><span class="line">                mLayoutRequested = true;</span><br><span class="line">                windowSizeMayChange = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (viewVisibilityChanged) &#123;</span><br><span class="line">            mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">            host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">            if (viewUserVisibilityChanged) &#123;</span><br><span class="line">                host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">            if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">                endDragResizing();</span><br><span class="line">                destroyHardwareResources();</span><br><span class="line">            &#125;</span><br><span class="line">            if (viewVisibility == View.GONE) &#123;</span><br><span class="line">                // After making a window gone, we will count it as being</span><br><span class="line">                // shown for the first time the next time it gets focus.</span><br><span class="line">                mHasHadWindowFocus = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Non-visible windows can&apos;t hold accessibility focus.</span><br><span class="line">        if (mAttachInfo.mWindowVisibility != View.VISIBLE) &#123;</span><br><span class="line">            host.clearAccessibilityFocus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Execute enqueued actions on every traversal in case a detached view enqueued an action</span><br><span class="line">        getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">        boolean insetsChanged = false;</span><br><span class="line"></span><br><span class="line">        boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        if (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">            final Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">            if (mFirst) &#123;</span><br><span class="line">                // make sure touch mode code executes by setting cached value</span><br><span class="line">                // to opposite of the added touch mode.</span><br><span class="line">                mAttachInfo.mInTouchMode = !mAddedTouchMode;</span><br><span class="line">                ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mVisibleInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                        || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                    windowSizeMayChange = true;</span><br><span class="line"></span><br><span class="line">                    if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                        // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">                        Point size = new Point();</span><br><span class="line">                        mDisplay.getRealSize(size);</span><br><span class="line">                        desiredWindowWidth = size.x;</span><br><span class="line">                        desiredWindowHeight = size.y;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Configuration config = res.getConfiguration();</span><br><span class="line">                        desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                        desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Ask host how big it wants to be</span><br><span class="line">            windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                    desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (collectViewAttributes()) &#123;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mAttachInfo.mForceReportNewAttributes) &#123;</span><br><span class="line">            mAttachInfo.mForceReportNewAttributes = false;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFirst || mAttachInfo.mViewVisibilityChanged) &#123;</span><br><span class="line">            mAttachInfo.mViewVisibilityChanged = false;</span><br><span class="line">            int resizeMode = mSoftInputMode &amp;</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;</span><br><span class="line">            // If we are in auto resize mode, then we need to determine</span><br><span class="line">            // what mode to use now.</span><br><span class="line">            if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">                final int N = mAttachInfo.mScrollContainers.size();</span><br><span class="line">                for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                    if (mAttachInfo.mScrollContainers.get(i).isShown()) &#123;</span><br><span class="line">                        resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (resizeMode == 0) &#123;</span><br><span class="line">                    resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((lp.softInputMode &amp;</span><br><span class="line">                        WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) &#123;</span><br><span class="line">                    lp.softInputMode = (lp.softInputMode &amp;</span><br><span class="line">                            ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) |</span><br><span class="line">                            resizeMode;</span><br><span class="line">                    params = lp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (params != null) &#123;</span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">                if (!PixelFormat.formatHasAlpha(params.format)) &#123;</span><br><span class="line">                    params.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mAttachInfo.mOverscanRequested = (params.flags</span><br><span class="line">                    &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mApplyInsetsRequested) &#123;</span><br><span class="line">            mApplyInsetsRequested = false;</span><br><span class="line">            mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">            dispatchApplyInsets(host);</span><br><span class="line">            if (mLayoutRequested) &#123;</span><br><span class="line">                // Short-circuit catching a new layout request here, so</span><br><span class="line">                // we don&apos;t need to go through two layout passes when things</span><br><span class="line">                // change due to fitting system windows, which can happen a lot.</span><br><span class="line">                windowSizeMayChange |= measureHierarchy(host, lp,</span><br><span class="line">                        mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (layoutRequested) &#123;</span><br><span class="line">            // Clear this now, so that if anything requests a layout in the</span><br><span class="line">            // rest of this function we will catch it and re-run a full</span><br><span class="line">            // layout pass.</span><br><span class="line">            mLayoutRequested = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">                &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())</span><br><span class="line">                || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)</span><br><span class="line">                || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));</span><br><span class="line">        windowShouldResize |= mDragResizing &amp;&amp; mResizeMode == RESIZE_MODE_FREEFORM;</span><br><span class="line"></span><br><span class="line">        // If the activity was just relaunched, it might have unfrozen the task bounds (while</span><br><span class="line">        // relaunching), so we need to force a call into window manager to pick up the latest</span><br><span class="line">        // bounds.</span><br><span class="line">        windowShouldResize |= mActivityRelaunched;</span><br><span class="line"></span><br><span class="line">        // Determine whether to compute insets.</span><br><span class="line">        // If there are no inset listeners remaining then we may still need to compute</span><br><span class="line">        // insets in case the old insets were non-empty and must be reset.</span><br><span class="line">        final boolean computesInternalInsets =</span><br><span class="line">                mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners()</span><br><span class="line">                        || mAttachInfo.mHasNonEmptyGivenInternalInsets;</span><br><span class="line"></span><br><span class="line">        boolean insetsPending = false;</span><br><span class="line">        int relayoutResult = 0;</span><br><span class="line">        boolean updatedConfiguration = false;</span><br><span class="line"></span><br><span class="line">        final int surfaceGenerationId = mSurface.getGenerationId();</span><br><span class="line"></span><br><span class="line">        final boolean isViewVisible = viewVisibility == View.VISIBLE;</span><br><span class="line">        final boolean windowRelayoutWasForced = mForceNextWindowRelayout;</span><br><span class="line">        if (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">                viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123;</span><br><span class="line">            mForceNextWindowRelayout = false;</span><br><span class="line"></span><br><span class="line">            if (isViewVisible) &#123;</span><br><span class="line">                // If this window is giving internal insets to the window</span><br><span class="line">                // manager, and it is being added or changing its visibility,</span><br><span class="line">                // then we want to first give the window manager &quot;fake&quot;</span><br><span class="line">                // insets to cause it to effectively ignore the content of</span><br><span class="line">                // the window during layout.  This avoids it briefly causing</span><br><span class="line">                // other windows to resize/move based on the raw frame of the</span><br><span class="line">                // window, waiting until we can finish laying out this window</span><br><span class="line">                // and get back to the window manager with the ultimately</span><br><span class="line">                // computed insets.</span><br><span class="line">                insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mSurfaceHolder != null) &#123;</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                mDrawingAllowed = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean hwInitialized = false;</span><br><span class="line">            boolean contentInsetsChanged = false;</span><br><span class="line">            boolean hadSurface = mSurface.isValid();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (DEBUG_LAYOUT) &#123;</span><br><span class="line">                    Log.i(mTag, &quot;host=w:&quot; + host.getMeasuredWidth() + &quot;, h:&quot; +</span><br><span class="line">                            host.getMeasuredHeight() + &quot;, params=&quot; + params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                    // relayoutWindow may decide to destroy mSurface. As that decision</span><br><span class="line">                    // happens in WindowManager service, we need to be defensive here</span><br><span class="line">                    // and stop using the surface in case it gets destroyed.</span><br><span class="line">                    if (mAttachInfo.mThreadedRenderer.pauseSurface(mSurface)) &#123;</span><br><span class="line">                        // Animations were running so we need to push a frame</span><br><span class="line">                        // to resume them</span><br><span class="line">                        mDirty.set(0, 0, mWidth, mHeight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</span><br><span class="line">                &#125;</span><br><span class="line">                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line"></span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;relayout: frame=&quot; + frame.toShortString()</span><br><span class="line">                        + &quot; overscan=&quot; + mPendingOverscanInsets.toShortString()</span><br><span class="line">                        + &quot; content=&quot; + mPendingContentInsets.toShortString()</span><br><span class="line">                        + &quot; visible=&quot; + mPendingVisibleInsets.toShortString()</span><br><span class="line">                        + &quot; visible=&quot; + mPendingStableInsets.toShortString()</span><br><span class="line">                        + &quot; outsets=&quot; + mPendingOutsets.toShortString()</span><br><span class="line">                        + &quot; surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">                final Configuration pendingMergedConfig =</span><br><span class="line">                        mPendingMergedConfiguration.getMergedConfiguration();</span><br><span class="line">                if (pendingMergedConfig.seq != 0) &#123;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Log.v(mTag, &quot;Visible with new config: &quot;</span><br><span class="line">                            + pendingMergedConfig);</span><br><span class="line">                    performConfigurationChange(mPendingMergedConfiguration, !mFirst,</span><br><span class="line">                            INVALID_DISPLAY /* same display */);</span><br><span class="line">                    pendingMergedConfig.seq = 0;</span><br><span class="line">                    updatedConfiguration = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final boolean overscanInsetsChanged = !mPendingOverscanInsets.equals(</span><br><span class="line">                        mAttachInfo.mOverscanInsets);</span><br><span class="line">                contentInsetsChanged = !mPendingContentInsets.equals(</span><br><span class="line">                        mAttachInfo.mContentInsets);</span><br><span class="line">                final boolean visibleInsetsChanged = !mPendingVisibleInsets.equals(</span><br><span class="line">                        mAttachInfo.mVisibleInsets);</span><br><span class="line">                final boolean stableInsetsChanged = !mPendingStableInsets.equals(</span><br><span class="line">                        mAttachInfo.mStableInsets);</span><br><span class="line">                final boolean outsetsChanged = !mPendingOutsets.equals(mAttachInfo.mOutsets);</span><br><span class="line">                final boolean surfaceSizeChanged = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;</span><br><span class="line">                final boolean alwaysConsumeNavBarChanged =</span><br><span class="line">                        mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">                if (contentInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Content insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mContentInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                if (overscanInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Overscan insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mOverscanInsets);</span><br><span class="line">                    // Need to relayout with content insets.</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stableInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mStableInsets.set(mPendingStableInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Decor insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mStableInsets);</span><br><span class="line">                    // Need to relayout with content insets.</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (alwaysConsumeNavBarChanged) &#123;</span><br><span class="line">                    mAttachInfo.mAlwaysConsumeNavBar = mPendingAlwaysConsumeNavBar;</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (contentInsetsChanged || mLastSystemUiVisibility !=</span><br><span class="line">                        mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested</span><br><span class="line">                        || mLastOverscanRequested != mAttachInfo.mOverscanRequested</span><br><span class="line">                        || outsetsChanged) &#123;</span><br><span class="line">                    mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">                    mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">                    mAttachInfo.mOutsets.set(mPendingOutsets);</span><br><span class="line">                    mApplyInsetsRequested = false;</span><br><span class="line">                    dispatchApplyInsets(host);</span><br><span class="line">                &#125;</span><br><span class="line">                if (visibleInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mVisibleInsets);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!hadSurface) &#123;</span><br><span class="line">                    if (mSurface.isValid()) &#123;</span><br><span class="line">                        // If we are creating a new surface, then we need to</span><br><span class="line">                        // completely redraw it.  Also, when we get to the</span><br><span class="line">                        // point of drawing it we will hold off and schedule</span><br><span class="line">                        // a new traversal instead.  This is so we can tell the</span><br><span class="line">                        // window manager about all of the windows being displayed</span><br><span class="line">                        // before actually drawing them, so it can display then</span><br><span class="line">                        // all at once.</span><br><span class="line">                        newSurface = true;</span><br><span class="line">                        mFullRedrawNeeded = true;</span><br><span class="line">                        mPreviousTransparentRegion.setEmpty();</span><br><span class="line"></span><br><span class="line">                        // Only initialize up-front if transparent regions are not</span><br><span class="line">                        // requested, otherwise defer to see if the entire window</span><br><span class="line">                        // will be transparent</span><br><span class="line">                        if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                hwInitialized = mAttachInfo.mThreadedRenderer.initialize(</span><br><span class="line">                                        mSurface);</span><br><span class="line">                                if (hwInitialized &amp;&amp; (host.mPrivateFlags</span><br><span class="line">                                        &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) &#123;</span><br><span class="line">                                    // Don&apos;t pre-allocate if transparent regions</span><br><span class="line">                                    // are requested as they may not be needed</span><br><span class="line">                                    mSurface.allocateBuffers();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                                handleOutOfResourcesException(e);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (!mSurface.isValid()) &#123;</span><br><span class="line">                    // If the surface has been removed, then reset the scroll</span><br><span class="line">                    // positions.</span><br><span class="line">                    if (mLastScrolledFocus != null) &#123;</span><br><span class="line">                        mLastScrolledFocus.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mScrollY = mCurScrollY = 0;</span><br><span class="line">                    if (mView instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                        ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (mScroller != null) &#123;</span><br><span class="line">                        mScroller.abortAnimation();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Our surface is gone</span><br><span class="line">                    if (mAttachInfo.mThreadedRenderer != null &amp;&amp;</span><br><span class="line">                            mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">                        mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if ((surfaceGenerationId != mSurface.getGenerationId()</span><br><span class="line">                        || surfaceSizeChanged || windowRelayoutWasForced)</span><br><span class="line">                        &amp;&amp; mSurfaceHolder == null</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                    mFullRedrawNeeded = true;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // Need to do updateSurface (which leads to CanvasContext::setSurface and</span><br><span class="line">                        // re-create the EGLSurface) if either the Surface changed (as indicated by</span><br><span class="line">                        // generation id), or WindowManager changed the surface size. The latter is</span><br><span class="line">                        // because on some chips, changing the consumer side&apos;s BufferQueue size may</span><br><span class="line">                        // not take effect immediately unless we create a new EGLSurface.</span><br><span class="line">                        // Note that frame size change doesn&apos;t always imply surface size change (eg.</span><br><span class="line">                        // drag resizing uses fullscreen surface), need to check surfaceSizeChanged</span><br><span class="line">                        // flag from WindowManager.</span><br><span class="line">                        mAttachInfo.mThreadedRenderer.updateSurface(mSurface);</span><br><span class="line">                    &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                        handleOutOfResourcesException(e);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final boolean freeformResizing = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;</span><br><span class="line">                final boolean dockedResizing = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;</span><br><span class="line">                final boolean dragResizing = freeformResizing || dockedResizing;</span><br><span class="line">                if (mDragResizing != dragResizing) &#123;</span><br><span class="line">                    if (dragResizing) &#123;</span><br><span class="line">                        mResizeMode = freeformResizing</span><br><span class="line">                                ? RESIZE_MODE_FREEFORM</span><br><span class="line">                                : RESIZE_MODE_DOCKED_DIVIDER;</span><br><span class="line">                        startDragResizing(mPendingBackDropFrame,</span><br><span class="line">                                mWinFrame.equals(mPendingBackDropFrame), mPendingVisibleInsets,</span><br><span class="line">                                mPendingStableInsets, mResizeMode);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // We shouldn&apos;t come here, but if we come we should end the resize.</span><br><span class="line">                        endDragResizing();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!USE_MT_RENDERER) &#123;</span><br><span class="line">                    if (dragResizing) &#123;</span><br><span class="line">                        mCanvasOffsetX = mWinFrame.left;</span><br><span class="line">                        mCanvasOffsetY = mWinFrame.top;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mCanvasOffsetX = mCanvasOffsetY = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DEBUG_ORIENTATION) Log.v(</span><br><span class="line">                    TAG, &quot;Relayout returned: frame=&quot; + frame + &quot;, surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">            mAttachInfo.mWindowTop = frame.top;</span><br><span class="line"></span><br><span class="line">            // !!FIXME!! This next section handles the case where we did not get the</span><br><span class="line">            // window size we asked for. We should avoid this by getting a maximum size from</span><br><span class="line">            // the window session beforehand.</span><br><span class="line">            if (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">                mWidth = frame.width();</span><br><span class="line">                mHeight = frame.height();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mSurfaceHolder != null) &#123;</span><br><span class="line">                // The app owns the surface; tell it about what is going on.</span><br><span class="line">                if (mSurface.isValid()) &#123;</span><br><span class="line">                    // XXX .copyFrom() doesn&apos;t work!</span><br><span class="line">                    //mSurfaceHolder.mSurface.copyFrom(mSurface);</span><br><span class="line">                    mSurfaceHolder.mSurface = mSurface;</span><br><span class="line">                &#125;</span><br><span class="line">                mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight);</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                if (mSurface.isValid()) &#123;</span><br><span class="line">                    if (!hadSurface) &#123;</span><br><span class="line">                        mSurfaceHolder.ungetCallbacks();</span><br><span class="line"></span><br><span class="line">                        mIsCreating = true;</span><br><span class="line">                        SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                        if (callbacks != null) &#123;</span><br><span class="line">                            for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                                c.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        surfaceChanged = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) &#123;</span><br><span class="line">                        SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                        if (callbacks != null) &#123;</span><br><span class="line">                            for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                                c.surfaceChanged(mSurfaceHolder, lp.format,</span><br><span class="line">                                        mWidth, mHeight);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIsCreating = false;</span><br><span class="line">                &#125; else if (hadSurface) &#123;</span><br><span class="line">                    mSurfaceHolder.ungetCallbacks();</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                    if (callbacks != null) &#123;</span><br><span class="line">                        for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceDestroyed(mSurfaceHolder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mSurfaceHolder.mSurface = new Surface();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final ThreadedRenderer threadedRenderer = mAttachInfo.mThreadedRenderer;</span><br><span class="line">            if (threadedRenderer != null &amp;&amp; threadedRenderer.isEnabled()) &#123;</span><br><span class="line">                if (hwInitialized</span><br><span class="line">                        || mWidth != threadedRenderer.getWidth()</span><br><span class="line">                        || mHeight != threadedRenderer.getHeight()</span><br><span class="line">                        || mNeedsRendererSetup) &#123;</span><br><span class="line">                    threadedRenderer.setup(mWidth, mHeight, mAttachInfo,</span><br><span class="line">                            mWindowAttributes.surfaceInsets);</span><br><span class="line">                    mNeedsRendererSetup = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                        updatedConfiguration) &#123;</span><br><span class="line">                    // TODO: 2018/5/25 //获得view宽高的测量规格，</span><br><span class="line">                    // TODO: 2018/5/25 mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高</span><br><span class="line">                    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth=&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight=&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight=&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                    // Ask host how big it wants to be</span><br><span class="line">                    // TODO: 2018/5/25  这里是第一步的  执行测量的操作</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    // Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    // We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    // needs be</span><br><span class="line">                    int width = host.getMeasuredWidth();</span><br><span class="line">                    int height = host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain = false;</span><br><span class="line">                    /**</span><br><span class="line">*指示额外空间的多少将被水平分配。</span><br><span class="line">*与这些LayOutPARAMs关联的视图。如果视图指定0</span><br><span class="line">*不应被拉伸。否则额外像素将被优先评估。</span><br><span class="line">*在所有重量大于0的视图中。</span><br><span class="line">*/                   // TODO: 2018/5/31  这里</span><br><span class="line">                    // WindowManager.LayoutParams=lp;</span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // TODO: 2018/5/31  我知道这里为啥执行两次</span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                                &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                                        + &quot; height=&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Not the first pass and no window/insets/visibility change but the window</span><br><span class="line">            // may have moved and we need check that and if so to update the left and right</span><br><span class="line">            // in the attach info. We translate only the window frame since on window move</span><br><span class="line">            // the window manager tells us only for the new frame but the insets are the</span><br><span class="line">            // same and we do not want to translate them more than once.</span><br><span class="line">            maybeHandleWindowMove(frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            // TODO: 2018/5/25  执行布局操作</span><br><span class="line">            performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">            // By this point all views have been sized and positioned</span><br><span class="line">            // We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">                // start out transparent</span><br><span class="line">                // TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded = true;</span><br><span class="line">                    // reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;======================================&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (computesInternalInsets) &#123;</span><br><span class="line">            // Clear the original insets.</span><br><span class="line">            final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets;</span><br><span class="line">            insets.reset();</span><br><span class="line"></span><br><span class="line">            // Compute new insets in place.</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">            mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty();</span><br><span class="line"></span><br><span class="line">            // Tell the window manager.</span><br><span class="line">            if (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">                mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">                // Translate insets to screen coordinates if needed.</span><br><span class="line">                final Rect contentInsets;</span><br><span class="line">                final Rect visibleInsets;</span><br><span class="line">                final Region touchableRegion;</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                    visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                    touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    contentInsets = insets.contentInsets;</span><br><span class="line">                    visibleInsets = insets.visibleInsets;</span><br><span class="line">                    touchableRegion = insets.touchableRegion;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                            contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFirst &amp;&amp; sAlwaysAssignFocus) &#123;</span><br><span class="line">            // handle first focus request</span><br><span class="line">            if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: mView.hasFocus()=&quot;</span><br><span class="line">                    + mView.hasFocus());</span><br><span class="line">            if (mView != null) &#123;</span><br><span class="line">                if (!mView.hasFocus()) &#123;</span><br><span class="line">                    mView.restoreDefaultFocus();</span><br><span class="line">                    if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: requested focused view=&quot;</span><br><span class="line">                            + mView.findFocus());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: existing focused view=&quot;</span><br><span class="line">                            + mView.findFocus());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">        if (regainedFocus) &#123;</span><br><span class="line">            mLostWindowFocus = false;</span><br><span class="line">        &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">            mLostWindowFocus = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (changedVisibility || regainedFocus) &#123;</span><br><span class="line">            // Toasts are presented as notifications - don&apos;t present them as windows as well</span><br><span class="line">            boolean isToast = (mWindowAttributes == null) ? false</span><br><span class="line">                    : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">            if (!isToast) &#123;</span><br><span class="line">                host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFirst = false;</span><br><span class="line">        mWillDrawSoon = false;</span><br><span class="line">        mNewSurfaceNeeded = false;</span><br><span class="line">        mActivityRelaunched = false;</span><br><span class="line">        mViewVisibility = viewVisibility;</span><br><span class="line">        mHadWindowFocus = hasWindowFocus;</span><br><span class="line"></span><br><span class="line">        if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">            final boolean imTarget = WindowManager.LayoutParams</span><br><span class="line">                    .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">            if (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">                mLastWasImTarget = imTarget;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">                if (imm != null &amp;&amp; imTarget) &#123;</span><br><span class="line">                    imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                    imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                            mWindowAttributes.softInputMode,</span><br><span class="line">                            !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Remember if we must report the next draw.</span><br><span class="line">        if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;</span><br><span class="line">            reportNextDraw();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO: 2018/5/25 执行绘制的操作</span><br><span class="line">            performDraw();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isViewVisible) &#123;</span><br><span class="line">                // Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">           //就是除了状态栏</span><br><span class="line">           if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">               // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">               Point size = new Point();</span><br><span class="line">               mDisplay.getRealSize(size);</span><br><span class="line">               desiredWindowWidth = size.x;</span><br><span class="line">               desiredWindowHeight = size.y;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //否者顶层视图DecorView所需要的窗口的宽度和高度就是整个屏幕的宽度</span><br><span class="line">               desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">               desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li><li><p>2、/获得view宽高的测量规格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 2018/5/25 //获得view宽高的测量规格，</span><br><span class="line"> // TODO: 2018/5/25 mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高</span><br><span class="line"> int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line"> int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br></pre></td></tr></table></figure></li><li><p>3、注意这个对象<code>WindowManager.LayoutParams lp</code> ,如果说<code>lp.horizontalWeight &gt; 0.0f</code>或者是<code>lp.verticalWeight &gt; 0.0f</code>,那么measureAgain =true；<code>horizontalWeight</code>这个标记大概是这个意思指示额外空间的多少将被水平分配。如果视图指定0不应被拉伸。否则额外像素将被优先评估。在所有重量大于0的视图中。一般都指示出还有多少的水平的空间将要被分配。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">      * 这个WindowMananger 这里标记了 是</span><br><span class="line">      */</span><br><span class="line">     // TODO: 2018/6/4</span><br><span class="line">     WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">           // TODO: 2018/5/25  这里是第一步的  执行测量的操作</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">       if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                     width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                     childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                             MeasureSpec.EXACTLY);</span><br><span class="line">                     measureAgain = true;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                     height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                     childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                             MeasureSpec.EXACTLY);</span><br><span class="line">                     measureAgain = true;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果这个measureAgain=true的话，就会再次调用<code>performMeasure()</code>,通过代码可以发现这就调用了两次<code>performMeasure</code>;</p><h4 id="其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。"><a href="#其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。" class="headerlink" title="其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。"></a>其实我这里犯了一个错误，不是这样的子，这个标记不一定是为<code>true</code>。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (measureAgain) &#123;</span><br><span class="line">                       if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                               &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                                       + &quot; height=&quot; + height);</span><br><span class="line">                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>4、关于<code>performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</code>方法,其实就是调用的是<code>mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code>,也就是View第一步是测量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">     if (mView == null) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">     try &#123;</span><br><span class="line">         mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>5、第一次绘制的时候，这个标记一定是<code>didLayout</code>一定是true，一定会走到这个方法里面去<code>performLayout(lp, mWidth, mHeight);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            // TODO: 2018/5/25  执行布局操作</span><br><span class="line">            performLayout(lp, mWidth, mHeight);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>关于<code>performLayout</code>这个方法，直接会调用<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</code>,也就是View的layout的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">                               int desiredWindowHeight) &#123;</span><br><span class="line">final View host = mView;</span><br><span class="line">  try &#123;</span><br><span class="line">            host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">           //测试层级</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><p>6、这两个标记也是<code>!cancelDraw &amp;&amp; !newSurface</code>为<code>true</code>,那么就会走到<code>performDraw();</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">         if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">             for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                 mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">             &#125;</span><br><span class="line">             mPendingTransitions.clear();</span><br><span class="line">         &#125;</span><br><span class="line">         // TODO: 2018/5/25 执行绘制的操作</span><br><span class="line">         performDraw();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>关于<code>performDraw();</code>方法,直接调用的是<code>draw(fullRedrawNeeded);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    private void performDraw() &#123;</span><br><span class="line">        mIsDrawing = true;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mIsDrawing = false;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>draw(fullRedrawNeeded);</code>,会调用到这里来<code>drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">      if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于这个方法<code>drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</code>。官方的解释为如果绘图成功，如果发生错误，则为false。返回false的，程序就发生了异常，也就是程序GG掉了，绘制失败，这里仅仅贴出关键的代码~~~，这样字，就调用到了<code>mView.draw(canvas);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">                                 boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">                canvas.translate(-xoff, -yoff);</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateCanvas(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);</span><br><span class="line">                attachInfo.mSetIgnoreDirtyState = false;</span><br><span class="line">                // TODO: 2018/5/25   调用了View里面的draw方法</span><br><span class="line">                mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">                drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                    // Only clear the flag if it was not set during the mView.draw() call</span><br><span class="line">                    attachInfo.mIgnoreDirtyState = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后做了两张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-9f68fbf91f7c7eac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的绘制流程（一）.jpg"></p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-07125ab1e5530813.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的绘制流程（二）ViewRootImpl.performTraversals.jpg"></p><ul><li>说明几点<ul><li>如果感兴趣的，一定要去打个断点看一下这个流程</li><li>限于作者水平有限，一定会存在有些错误，还望指出，谢谢</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
            <tag> 绘制 </tag>
            
            <tag> View </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析LayoutInflater</title>
      <link href="/2018/06/07/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LayoutInflater/"/>
      <url>/2018/06/07/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90LayoutInflater/</url>
      <content type="html"><![CDATA[<h3 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h3><ul><li>在这篇文章<a href="https://www.jianshu.com/p/d9d919608842" target="_blank" rel="noopener">Android源码分析(Activity.setContentView源码解析)</a>，分析得出，底层走的就是<code>LayoutInflater.from(this),inflate(),</code>如果<code>inflate()</code>传入的view的话，就调用两次<code>LayoutInflater.from(this),inflate(),</code>，如果是<code>inflate()</code>传入的resId（布局的id）的话，就调用三次<code>LayoutInflater.from(this),inflate(),</code>,具体请看上篇文章。<a id="more"></a></li><li><p>怎么使用,一共有三种的方式，主要看下这种方式<code>LayoutInflater inflater1 = getLayoutInflater();</code>,其实调用的就是Activity的getLayoutInflater()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> LayoutInflater inflater1 = getLayoutInflater();//调用Activity的getLayoutInflater()</span><br><span class="line">LayoutInflater inflater2 = LayoutInflater.from(this);</span><br><span class="line">LayoutInflater inflater3 = (LayoutInflater)this.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br></pre></td></tr></table></figure></li><li><p>Activity的getLayoutInflater()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Convenience for calling</span><br><span class="line">   * &#123;@link android.view.Window#getLayoutInflater&#125;.</span><br><span class="line">   */</span><br><span class="line">  @NonNull</span><br><span class="line">  public LayoutInflater getLayoutInflater() &#123;</span><br><span class="line">      return getWindow().getLayoutInflater();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过<a href="https://www.jianshu.com/p/f7e3a14daf51" target="_blank" rel="noopener">Android源码分析（事件传递）</a>这边文章，我们知道，<code>Window类</code>只有唯一的子类<code>PhoneWindow</code>。所以主要的是去看<code>PhoneWindow</code>类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public PhoneWindow(Context context) &#123;</span><br><span class="line">    super(context);</span><br><span class="line">     mLayoutInflater = LayoutInflater.from(context);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>LayoutInflater inflater2 = LayoutInflater.from(this);</code>的实现的方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * Obtains the LayoutInflater from the given context.</span><br><span class="line">    */</span><br><span class="line">   public static LayoutInflater from(Context context) &#123;</span><br><span class="line">       LayoutInflater LayoutInflater =</span><br><span class="line">               (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">       if (LayoutInflater == null) &#123;</span><br><span class="line">           throw new AssertionError(&quot;LayoutInflater not found.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       return LayoutInflater;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li>以上三种方法，最终还是调用了<code>context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</code>获取LayoutInflater实例对象。</li><li><p>inflate的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root) &#123;</span><br><span class="line">     return inflate(parser, root, root != null);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>到这里来<code>inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot)</code>,个人的对这个方法的理解是：把布局文件填充成View，如果传入的<code>root</code>不为<code>null</code>，并且<code>attachToRoot</code>为<code>true</code>,就把view填充到root上，相反就不添加上来！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">     final Resources res = getContext().getResources();</span><br><span class="line">     if (DEBUG) &#123;</span><br><span class="line">         Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;</span><br><span class="line">                 + Integer.toHexString(resource) + &quot;)&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     //这里通过底层的方法，得到一个XmlResourceParser对象</span><br><span class="line">     final XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">     try &#123;</span><br><span class="line">         return inflate(parser, root, attachToRoot);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         parser.close();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inflate(parser, root, attachToRoot)</code>，特别关心这个方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) &#123;</span><br><span class="line">       synchronized (mConstructorArgs) &#123;</span><br><span class="line">           //底层的方法，不知道原理</span><br><span class="line">           Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);</span><br><span class="line">           // TODO: 2018/6/5  我没有搞明白 为啥整个值在这里做什么的， 在这个方法里面都没有使用</span><br><span class="line">           // from传入的Context</span><br><span class="line">           final Context inflaterContext = mContext;</span><br><span class="line">           // 判断parser是否是AttributeSet，如果不是则用XmlPullAttributes去包装一下。</span><br><span class="line">           final AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">           // 保存之前的Context</span><br><span class="line">           Context lastContext = (Context) mConstructorArgs[0];</span><br><span class="line">           // 赋值为传入的Context</span><br><span class="line">           mConstructorArgs[0] = inflaterContext;</span><br><span class="line">           // 默认返回的是传入的Parent</span><br><span class="line">           View result = root;</span><br><span class="line">           try &#123;</span><br><span class="line">               // Look for the root node.</span><br><span class="line">               int type;// 迭代xml中的所有元素，挨个解析</span><br><span class="line">               while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                       type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                   // Empty</span><br><span class="line">               &#125;</span><br><span class="line">              // //如果没找到有效的开始标签则抛出InflateException</span><br><span class="line">               if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                   throw new InflateException(parser.getPositionDescription()</span><br><span class="line">                           + &quot;: No start tag found!&quot;);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               final String name = parser.getName();</span><br><span class="line"></span><br><span class="line">               if (DEBUG) &#123;</span><br><span class="line">                   System.out.println(&quot;**************************&quot;);</span><br><span class="line">                   System.out.println(&quot;Creating root view: &quot;</span><br><span class="line">                           + name);</span><br><span class="line">                   System.out.println(&quot;**************************&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               //// 如果根节点是“merge”标签</span><br><span class="line">               if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                   // 根节点为空或者不添加到根节点上，则抛出异常。</span><br><span class="line">                   // 因为“merge”标签必须是要被添加到父节点上的，不能独立存在。</span><br><span class="line">                   if (root == null || !attachToRoot) &#123;</span><br><span class="line">                       throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                               + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line">                   // 递归实例化root（也就是传入Parent）下所有的View</span><br><span class="line">                   // 如果xml中的节点是merge节点，则调用rInflate()--方法  // 递归实例化根节点的子View</span><br><span class="line">                   rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                   // Temp is the root view that was found in the xml</span><br><span class="line">                   //通过View的父View，View的名称、attrs属性实例化View（内部调用onCreateView()和createView()）。</span><br><span class="line">                   // TODO: 2018/6/6  // 实例化根节点的View </span><br><span class="line">                   final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                   ViewGroup.LayoutParams params = null;</span><br><span class="line"></span><br><span class="line">                   if (root != null) &#123;</span><br><span class="line">                       if (DEBUG) &#123;</span><br><span class="line">                           System.out.println(&quot;Creating params from root: &quot; +</span><br><span class="line">                                   root);</span><br><span class="line">                       &#125;</span><br><span class="line">                       // Create layout params that match root, if supplied</span><br><span class="line">                       params = root.generateLayoutParams(attrs);</span><br><span class="line">                       if (!attachToRoot) &#123;</span><br><span class="line">                           // Set the layout params for temp if we are not</span><br><span class="line">                           // attaching. (If we are, we use addView, below)</span><br><span class="line">                           temp.setLayoutParams(params);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   if (DEBUG) &#123;</span><br><span class="line">                       System.out.println(&quot;-----&gt; start inflating children&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   // Inflate all children under temp against its context.</span><br><span class="line">                   // 递归实例化跟节点的子View</span><br><span class="line">                   rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">                   if (DEBUG) &#123;</span><br><span class="line">                       System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   // We are supposed to attach all the views we found (int temp)</span><br><span class="line">                   // to root. Do that now.\</span><br><span class="line"></span><br><span class="line">                   if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                       root.addView(temp, params); // TODO: 2018/6/6      返回父View</span><br><span class="line">                   &#125;</span><br><span class="line">              </span><br><span class="line">                   // Decide whether to return the root that was passed in or the</span><br><span class="line">                   // top view found in xml.</span><br><span class="line">                   // TODO: 2018/6/6  父View是空或者不把填充的View添加到父View)</span><br><span class="line">                   if (root == null || !attachToRoot) &#123;</span><br><span class="line">                       result = temp;  // TODO: 2018/6/6 返回根节点View </span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">           &#125; catch (XmlPullParserException e) &#123;</span><br><span class="line">               final InflateException ie = new InflateException(e.getMessage(), e);</span><br><span class="line">               ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">               throw ie;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               final InflateException ie = new InflateException(parser.getPositionDescription()</span><br><span class="line">                       + &quot;: &quot; + e.getMessage(), e);</span><br><span class="line">               ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">               throw ie;</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               // Don&apos;t retain static reference on context.</span><br><span class="line">               //不要在上下文中保留静态引用。</span><br><span class="line">               // 把这之前保存的Context从新放回全局变量中。</span><br><span class="line">               mConstructorArgs[0] = lastContext;</span><br><span class="line">               mConstructorArgs[1] = null;</span><br><span class="line"></span><br><span class="line">               Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>注意其中有个判断<code>TAG_MERGE.equals(name))</code> ,这里就是merge标签的开始，以下的问题，都带着这个疑问往下面看。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                  // 根节点为空或者不添加到根节点上，则抛出异常。</span><br><span class="line">                  // 因为“merge”标签必须是要被添加到父节点上的，不能独立存在。</span><br><span class="line">                  if (root == null || !attachToRoot) &#123;</span><br><span class="line">                      throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;</span><br><span class="line">                              + &quot;ViewGroup root and attachToRoot=true&quot;);</span><br><span class="line">                  &#125;</span><br><span class="line">                  // 递归实例化root（也就是传入Parent）下所有的View</span><br><span class="line">                  // 如果xml中的节点是merge节点，则调用rInflate()--方法  // 递归实例化根节点的子View</span><br><span class="line">                  rInflate(parser, root, inflaterContext, attrs, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解析到<code>merge</code>标签的话，就会进入到这个方法<code>rInflate(parser, root, inflaterContext, attrs, false);</code>:递归实例化根节点的子View,在这里说明一点的是这个方法传入的<code>root</code>会不会为<code>null</code>.这篇文章说过<a href="https://www.jianshu.com/p/d9d919608842" target="_blank" rel="noopener">Android源码分析（Activity.setContentView源码解析）</a>,肯定不会为null，一般是我们自己去使用的时候，有可能为null，具体的差别可以参考这篇文章<a href="https://blog.csdn.net/lmj623565791/article/details/38171465" target="_blank" rel="noopener">Android LayoutInflater深度解析 给你带来全新的认识</a></p></li><li><p>关于<code>rInflate(parser, root, inflaterContext, attrs, false);</code>方法：递归方法用于降序XML层次结构并实例化视图，实例化它们的子节点，然后调用<code>onFinishInflate(),</code>, 完成填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">void rInflate(XmlPullParser parser, View parent, Context context,</span><br><span class="line">           AttributeSet attrs, boolean finishInflate) throws XmlPullParserException, IOException &#123;</span><br><span class="line"></span><br><span class="line">       final int depth = parser.getDepth();</span><br><span class="line">       int type;</span><br><span class="line">       boolean pendingRequestFocus = false;</span><br><span class="line">       // 迭代xml中的所有元素，挨个解析</span><br><span class="line">       while (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">           if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">               continue;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           final String name = parser.getName();</span><br><span class="line">           //1、解析请求焦点 ，这个控件一直有焦点 requestFocus</span><br><span class="line">           if (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">               pendingRequestFocus = true;</span><br><span class="line">               consumeChildElements(parser);</span><br><span class="line">           &#125; else if (TAG_TAG.equals(name)) &#123;</span><br><span class="line">               //在包含的视图上设置键标记。</span><br><span class="line">               parseViewTag(parser, parent, attrs);</span><br><span class="line">           &#125; else if (TAG_INCLUDE.equals(name)) &#123;// 如果xml中的节点是include节点，则调用parseInclude方法</span><br><span class="line">               if (parser.getDepth() == 0) &#123;</span><br><span class="line">                   throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">               //解析include标签</span><br><span class="line">               parseInclude(parser, context, parent, attrs);</span><br><span class="line">           &#125; else if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">               // TODO: 2018/5/23 merge  作为布局里面的元素 会报错的哦 ，注意哦</span><br><span class="line">               //想象下 两个merge 标签重合在一起</span><br><span class="line">               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // TODO: 2018/5/23 其实就是如果是merge标签，</span><br><span class="line">               // TODO: 2018/5/23  那么直接将其中的子元素添加到merge标签parent中，这样就保证了不会引入额外的层级。</span><br><span class="line">               // 1、我们的例子会进入这里  // 通过View的名称实例化View</span><br><span class="line">               final View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">               // 2、获取merge标签的parent</span><br><span class="line">               final ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">               // 3、获取布局参数</span><br><span class="line">               final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">               // 4、递归解析每个子元素</span><br><span class="line">               rInflateChildren(parser, view, attrs, true);</span><br><span class="line">               // 5、将子元素直接添加到merge标签的parent view中</span><br><span class="line">               viewGroup.addView(view, params);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (pendingRequestFocus) &#123;</span><br><span class="line">           parent.restoreDefaultFocus();</span><br><span class="line">       &#125;</span><br><span class="line">       /**</span><br><span class="line">        * onFinishInflate() View 中的一个空实现，标记完全填充完成了</span><br><span class="line">        * The method onFinishInflate() will be called after all children have been added.</span><br><span class="line">        * 以后是所有的孩子调用完成了，之后就调用这个方法</span><br><span class="line">        */</span><br><span class="line">       if (finishInflate) &#123;</span><br><span class="line">           parent.onFinishInflate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>通过对上面的方法分析，还打了断点，打断点注意一点，用模拟器，基本上手机厂商都改了<code>frameWork</code>层的代码，打出来是乱的。代码会走到这里来,看代码的分析，就把新的View，通过<code>ViewGroup.addView()</code>进去了，这也是merge便签的原理：<code>merge标签可以自动消除当一个布局插入到另一个布局时产生的多余的View Group，也可用于替换FrameLayout</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 2018/5/23 其实就是如果是merge标签，</span><br><span class="line"> // TODO: 2018/5/23  那么直接将其中的子元素添加到merge标签parent中，这样就保证了不会引入额外的层级。</span><br><span class="line"> // 1、我们的例子会进入这里  // 通过View的名称实例化View</span><br><span class="line"> final View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line"> // 2、获取merge标签的parent</span><br><span class="line"> final ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line"> // 3、获取布局参数</span><br><span class="line"> final ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line"> // 4、递归解析每个子元素</span><br><span class="line"> rInflateChildren(parser, view, attrs, true);</span><br><span class="line"> // 5、将子元素直接添加到merge标签的parent view中</span><br><span class="line"> viewGroup.addView(view, params);</span><br></pre></td></tr></table></figure></li><li><p><code>merge</code>的原理我们清楚了，分析另外一条线，没有<code>merge</code>标签,就会走到else的方法来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 如果根节点是“merge”标签</span><br><span class="line">if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">   </span><br><span class="line">&#125; else &#123;</span><br><span class="line">    final View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line">    ViewGroup.LayoutParams params = null;</span><br><span class="line">    if (root != null) &#123;</span><br><span class="line">             params = root.generateLayoutParams(attrs);</span><br><span class="line">        if (!attachToRoot) &#123;</span><br><span class="line">            temp.setLayoutParams(params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 递归实例化跟节点的子View start inflating children</span><br><span class="line">    rInflateChildren(parser, temp, attrs, true);</span><br><span class="line"></span><br><span class="line">    if (DEBUG) &#123;</span><br><span class="line">        System.out.println(&quot;-----&gt; done inflating children&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    if (root != null &amp;&amp; attachToRoot) &#123;</span><br><span class="line">        root.addView(temp, params); // TODO: 2018/6/6      返回父View</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line">    // Decide whether to return the root that was passed in or the</span><br><span class="line">    // top view found in xml.</span><br><span class="line">    // TODO: 2018/6/6  父View是空或者不把填充的View添加到父View)</span><br><span class="line">    if (root == null || !attachToRoot) &#123;</span><br><span class="line">        result = temp;  // TODO: 2018/6/6 返回根节点View </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>1、这个方法<code>createViewFromTag(View parent, String name, Context context, AttributeSet attrs)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private View createViewFromTag(View parent, String name, Context context, AttributeSet attrs) &#123;</span><br><span class="line">       return createViewFromTag(parent, name, context, attrs, false);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>最终调用的是这个方法<code>createViewFromTag(parent, name, context, attrs, false);</code>这个方法</p></li><li>，什么时候会走到下面来，<code>name.equals(&quot;view&quot;)</code>成立的情况，我记得以前我为了在布局中加了一根线就是这样写的，写快了，写成小写的了<code>view</code>，应该写成大写<code>View</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;view</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;/&gt;</span><br></pre></td></tr></table></figure></li></ul><p>小写的view：我自己打的断点发现，如果根标签是view的，注意是小写的，view，这个name会为null ，接着下面就会出现空指针的异常—&gt; 我很聪明 很牛逼<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,</span><br><span class="line">           boolean ignoreThemeAttr) &#123;</span><br><span class="line">       if (name.equals(&quot;view&quot;)) &#123;</span><br><span class="line">         //根据我的断点的话，只要进来的话，这个那么就会为null</span><br><span class="line">           name = attrs.getAttributeValue(null, &quot;class&quot;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Apply a theme wrapper, if allowed and one is specified.</span><br><span class="line">//如果允许的话，应用一个主题包装器，并指定一个。</span><br><span class="line">if (!ignoreThemeAttr) &#123;</span><br><span class="line">    final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">    final int themeResId = ta.getResourceId(0, 0);</span><br><span class="line">    if (themeResId != 0) &#123;</span><br><span class="line">        context = new ContextThemeWrapper(context, themeResId);</span><br><span class="line">    &#125;</span><br><span class="line">    ta.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name ==null，就会抛出<code>ava.lang.NullPointerException: Attempt to invoke virtual method &#39;boolean java.lang.String.equals(java.lang.Object)&#39; on a null object reference</code>,也就是这个原因，所以写代码还是要仔细，仔细！！</p><p>在这里有个很有意思的布局，开发中很少使用到，而且也不清楚，作者为啥写，姑且这样理解<code>Let&#39;s party like it&#39;s 1995! 写这个代码的哥们，在1995年经历了一件很开心的事情</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//如果有这个标签的话，就出现这个布局，闪动的布局</span><br><span class="line">if (name.equals(TAG_1995)) &#123;</span><br><span class="line">    // Let&apos;s party like it&apos;s 1995! 写这个代码的哥们，在1995年经历了一件很开心的事情</span><br><span class="line">    return new BlinkLayout(context, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>BlinkLayout</code>使用的方式，blink 翻译过来会一闪一闪的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;blink</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot; &gt;</span><br><span class="line">       &lt;TextView</span><br><span class="line">           android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">           android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">           android:background=&quot;@android:color/holo_blue_bright&quot;</span><br><span class="line">           android:text=&quot;blink单词也是这个意思.闪烁频率500毫秒&quot; /&gt;</span><br><span class="line">   &lt;/blink&gt;</span><br></pre></td></tr></table></figure></p><p><code>BlinkLayout</code>代码如下,  <code>BLINK_DELAY</code> 这个是闪动的时间间隔，如果开发中需要，改动这个时间就行了，感觉这个布局也没啥用！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">public  class BlinkLayout extends FrameLayout &#123;</span><br><span class="line">    private static final int MESSAGE_BLINK = 0x42;</span><br><span class="line">    private static final int BLINK_DELAY = 500;</span><br><span class="line">    private boolean mBlink;</span><br><span class="line">    private boolean mBlinkState;</span><br><span class="line">    private final Handler mHandler;</span><br><span class="line"></span><br><span class="line">    public BlinkLayout(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        // TODO: 2018/5/22 对handler  源码比较熟悉的话，这里就是Handler另外的一种使用的方法</span><br><span class="line">        mHandler = new Handler(new Handler.Callback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean handleMessage(Message msg) &#123;</span><br><span class="line">                if (msg.what == MESSAGE_BLINK) &#123;</span><br><span class="line">                    if (mBlink) &#123;</span><br><span class="line">                        mBlinkState = !mBlinkState;</span><br><span class="line">                        makeBlink();</span><br><span class="line">                    &#125;</span><br><span class="line">                    //invalidate()是用来刷新View的，必须是在UI线程中进行工作。</span><br><span class="line">                    // 比如在修改某个view的显示时，调用invalidate()才能看到重新绘制的界面</span><br><span class="line">                    invalidate();</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void makeBlink() &#123;</span><br><span class="line">        Message message = mHandler.obtainMessage(MESSAGE_BLINK);</span><br><span class="line">        mHandler.sendMessageDelayed(message, BLINK_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onAttachedToWindow() &#123;</span><br><span class="line">        super.onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">        mBlink = true;</span><br><span class="line">        mBlinkState = true;</span><br><span class="line"></span><br><span class="line">        makeBlink();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDetachedFromWindow() &#123;</span><br><span class="line">        super.onDetachedFromWindow();</span><br><span class="line"></span><br><span class="line">        mBlink = false;</span><br><span class="line">        mBlinkState = true;</span><br><span class="line"></span><br><span class="line">        mHandler.removeMessages(MESSAGE_BLINK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">        //根据这个状态是否去dispatchDraw</span><br><span class="line">        if (mBlinkState) &#123;</span><br><span class="line">            super.dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是后续的代码，通过工厂创建了view。去定位过，在<code>public class Activity extends ContextThemeWrapper implements LayoutInflater.Factory2</code>,很多的地方，如果需要研究的，还需要更深层的源码理解，这里就先mark下，只需要知道view是通过工厂来得到的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">    try &#123;</span><br><span class="line">        View view;</span><br><span class="line">        if (mFactory2 != null) &#123;</span><br><span class="line">            //各个工厂先onCreateView()</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; else if (mFactory != null) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            view = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null &amp;&amp; mPrivateFactory != null) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            final Object lastContext = mConstructorArgs[0];</span><br><span class="line">            mConstructorArgs[0] = context;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (-1 == name.indexOf(&apos;.&apos;)) &#123;</span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    view = createView(name, null, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                mConstructorArgs[0] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return view;</span><br><span class="line">    &#125; catch (InflateException e) &#123;</span><br><span class="line">        throw e;</span><br><span class="line"></span><br><span class="line">    &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">        final InflateException ie = new InflateException(attrs.getPositionDescription()</span><br><span class="line">                + &quot;: Error inflating class &quot; + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        throw ie;</span><br><span class="line"></span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        final InflateException ie = new InflateException(attrs.getPositionDescription()</span><br><span class="line">                + &quot;: Error inflating class &quot; + name, e);</span><br><span class="line">        ie.setStackTrace(EMPTY_STACK_TRACE);</span><br><span class="line">        throw ie;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>2、关于这个方法<code>rInflateChildren(parser, temp, attrs, true);</code>:递归实例化跟节点的子View.其实调用的还是这个方法<code>rInflate(parser, root, inflaterContext, attrs, false);</code>,文章的前部分贴出了这部分的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final void rInflateChildren(XmlPullParser parser, View parent, AttributeSet attrs,</span><br><span class="line">        boolean finishInflate) throws XmlPullParserException, IOException &#123;</span><br><span class="line">    rInflate(parser, parent, parent.getContext(), attrs, finishInflate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>主要是为了分析几个Tag<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static final String TAG_MERGE = &quot;merge&quot;;</span><br><span class="line">    private static final String TAG_INCLUDE = &quot;include&quot;;</span><br><span class="line">    private static final String TAG_1995 = &quot;blink&quot;;</span><br><span class="line">    private static final String TAG_REQUEST_FOCUS = &quot;requestFocus&quot;;</span><br><span class="line">    private static final String TAG_TAG = &quot;tag&quot;;</span><br><span class="line">    private static final String ATTR_LAYOUT = &quot;layout&quot;;</span><br></pre></td></tr></table></figure></p><p>requestFocus:解析请求焦点 ，这个控件一直有焦点 <code>requestFocus</code>,一般作用于 <code>EditText</code>,需要长期获取焦点的控件，但是真正的实现的方法，我们都是代码去实现了，很少这样使用，这里就说明一下，有这样的使用的方法！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">               pendingRequestFocus = true;</span><br><span class="line">               consumeChildElements(parser);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;EditText</span><br><span class="line">     android:id=&quot;@+id/text&quot;</span><br><span class="line">     android:layout_width=&quot;match_parent&quot;</span><br><span class="line">     android:layout_height=&quot;wrap_content&quot; &gt;</span><br><span class="line">     &lt;!-- 当前控件处于焦点状态 --&gt;</span><br><span class="line">     &lt;requestFocus /&gt;</span><br><span class="line"> &lt;/EditText&gt;</span><br></pre></td></tr></table></figure><p>tag：在包含的视图上设置键标记,其实就是给view设置上了一个tag标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (TAG_TAG.equals(name)) &#123;</span><br><span class="line">                //在包含的视图上设置键标记。</span><br><span class="line">                parseViewTag(parser, parent, attrs);</span><br><span class="line">    &#125; </span><br><span class="line"> final int key = ta.getResourceId(R.styleable.ViewTag_id, 0);</span><br><span class="line">   final CharSequence value = ta.getText(R.styleable.ViewTag_value);</span><br><span class="line">   view.setTag(key, value);</span><br></pre></td></tr></table></figure></p><p>merge:在这里如果解析到了<code>merge</code>标签的话，这里就直接抛出异常了，必须是根元素！两种情况下，一种是套用了两个merge标签，或者是一个ViewGruop标签嵌套了一个merge，都会抛出异常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">               // TODO: 2018/5/23 merge  作为布局里面的元素 会报错的哦 ，注意哦</span><br><span class="line">               //想象下 两个merge 标签重合在一起</span><br><span class="line">               throw new InflateException(&quot;&lt;merge /&gt; must be the root element&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>include:标签，在这里如果<code>include</code>作为了一个根元素，也会抛出异常，当然，如果在代码中见到别人那么用的话，建议自己去面壁思过会！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (TAG_INCLUDE.equals(name)) &#123;// 如果xml中的节点是include节点，则调用parseInclude方法</span><br><span class="line">                if (parser.getDepth() == 0) &#123;</span><br><span class="line">                    throw new InflateException(&quot;&lt;include /&gt; cannot be the root element&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                //解析include标签</span><br><span class="line">                parseInclude(parser, context, parent, attrs);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> <code>parseInclude(parser, context, parent, attrs);</code>,这个方法也就是<code>include</code>必须走的方法，搞明白的话，就可以搞明白原理，而且在特殊的情况下，<code>include</code>标签会和 <code>merge</code> 标签一起使用。这个方法也可以解释<code>include</code>标签的原理！</p><ul><li><p>可以从这里可以看到，<code>include</code>只能在<code>ViewGroup</code>中使用，在 ‘View’中使用的话，会报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">private void parseInclude(XmlPullParser parser, Context context, View parent,</span><br><span class="line">         AttributeSet attrs) throws XmlPullParserException, IOException &#123;</span><br><span class="line">     int type;</span><br><span class="line">if (parent instanceof ViewGroup) &#123;</span><br><span class="line">         // Apply a theme wrapper, if requested. This is sort of a weird</span><br><span class="line">         // edge case, since developers think the &lt;include&gt; overwrites</span><br><span class="line">         // values in the AttributeSet of the included View. So, if the</span><br><span class="line">         // included View has a theme attribute, we&apos;ll need to ignore it.</span><br><span class="line">         //如果VIEW视图有一个主题属性，我们需要忽略它。</span><br><span class="line">         final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">         final int themeResId = ta.getResourceId(0, 0);</span><br><span class="line">         final boolean hasThemeOverride = themeResId != 0;</span><br><span class="line">         if (hasThemeOverride) &#123;</span><br><span class="line">             context = new ContextThemeWrapper(context, themeResId);</span><br><span class="line">         &#125;</span><br><span class="line">         ta.recycle();</span><br><span class="line"></span><br><span class="line">         //如果布局指向主题属性，我们必须</span><br><span class="line">         //按摩该值以从中获取资源标识符。</span><br><span class="line">         int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);</span><br><span class="line">         if (layout == 0) &#123;</span><br><span class="line">             final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);</span><br><span class="line">             // TODO: 2018/6/6 include标签中没有设置layout属性，会抛出异常</span><br><span class="line">             if (value == null || value.length() &lt;= 0) &#123;//</span><br><span class="line">                 throw new InflateException(&quot;You must specify a layout in the&quot;</span><br><span class="line">                         + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);</span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             // Attempt to resolve the &quot;?attr/name&quot; string to an attribute</span><br><span class="line">             // within the default (e.g. application) package.</span><br><span class="line">             layout = context.getResources().getIdentifier(</span><br><span class="line">                     value.substring(1), &quot;attr&quot;, context.getPackageName());</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         // The layout might be referencing a theme attribute.</span><br><span class="line">         if (mTempValue == null) &#123;</span><br><span class="line">             mTempValue = new TypedValue();</span><br><span class="line">         &#125;</span><br><span class="line">         if (layout != 0 &amp;&amp; context.getTheme().resolveAttribute(layout, mTempValue, true)) &#123;</span><br><span class="line">             layout = mTempValue.resourceId;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         if (layout == 0) &#123;</span><br><span class="line">             final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);</span><br><span class="line">             throw new InflateException(&quot;You must specify a valid layout &quot;</span><br><span class="line">                     + &quot;reference. The layout ID &quot; + value + &quot; is not valid.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             final XmlResourceParser childParser = context.getResources().getLayout(layout);</span><br><span class="line"></span><br><span class="line">             try &#123;// 获取属性集，即在include标签中设置的属性</span><br><span class="line">                 final AttributeSet childAttrs = Xml.asAttributeSet(childParser);</span><br><span class="line"></span><br><span class="line">                 while ((type = childParser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                         type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                     // Empty.</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 if (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">                     throw new InflateException(childParser.getPositionDescription() +</span><br><span class="line">                             &quot;: No start tag found!&quot;);</span><br><span class="line">                 &#125;</span><br><span class="line">                // 1、解析include中的第一个元素</span><br><span class="line">                 final String childName = childParser.getName();</span><br><span class="line">                // 如果第一个元素是merge标签，那么调用rInflate函数解析</span><br><span class="line">                 if (TAG_MERGE.equals(childName)) &#123;</span><br><span class="line">                     // The &lt;merge&gt; tag doesn&apos;t support android:theme, so</span><br><span class="line">                     // nothing special to do here.</span><br><span class="line">                     rInflate(childParser, parent, context, childAttrs, false);</span><br><span class="line">                 &#125; else &#123;</span><br><span class="line">                     //2、我们例子中的情况会走到这一步,首先根据include的属性集创建被include进来的xml布局的根view</span><br><span class="line">                     // 这里的根view对应为my_title_layout.xml中的RelativeLayout</span><br><span class="line">                     final View view = createViewFromTag(parent, childName,</span><br><span class="line">                             context, childAttrs, hasThemeOverride);</span><br><span class="line">                     final ViewGroup group = (ViewGroup) parent;</span><br><span class="line"></span><br><span class="line">                     final TypedArray a = context.obtainStyledAttributes(</span><br><span class="line">                             attrs, R.styleable.Include);</span><br><span class="line">                     //这里就是设置的&lt;include&gt;布局设置的id ,如果include设置了这个id ，那么这个id就不等于 View.No_ID=-1</span><br><span class="line">                     final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);</span><br><span class="line">                     final int visibility = a.getInt(R.styleable.Include_visibility, -1);</span><br><span class="line">                     a.recycle();</span><br><span class="line"></span><br><span class="line">                     // We try to load the layout params set in the &lt;include /&gt; tag.</span><br><span class="line">                     // If the parent can&apos;t generate layout params (ex. missing width</span><br><span class="line">                     // or height for the framework ViewGroups, though this is not</span><br><span class="line">                     // necessarily true of all ViewGroups) then we expect it to throw</span><br><span class="line">                     // a runtime exception.</span><br><span class="line">                     // We catch this exception and set localParams accordingly: true</span><br><span class="line">                     // means we successfully loaded layout params from the &lt;include&gt;</span><br><span class="line">                     // tag, false means we need to rely on the included layout params.</span><br><span class="line">                     ViewGroup.LayoutParams params = null;</span><br><span class="line">                     try &#123;</span><br><span class="line">                         // 获3、取布局属性</span><br><span class="line">                         params = group.generateLayoutParams(attrs);</span><br><span class="line">                     &#125; catch (RuntimeException e) &#123;</span><br><span class="line">                         // Ignore, just fail over to child attrs.</span><br><span class="line">                     &#125;</span><br><span class="line">                     // 被inlcude进来的根view设置布局参数</span><br><span class="line">                     if (params == null) &#123;</span><br><span class="line">                         params = group.generateLayoutParams(childAttrs);</span><br><span class="line">                     &#125;</span><br><span class="line">                     view.setLayoutParams(params);</span><br><span class="line">                      // 4、Inflate all children. 解析所有子控件</span><br><span class="line">                     // Inflate all children.</span><br><span class="line">                     rInflateChildren(childParser, view, childAttrs, true);</span><br><span class="line"></span><br><span class="line">                     if (id != View.NO_ID) &#123;</span><br><span class="line">                      // 5、将include中设置的id设置给根view,因此实际上my_title_layout.xml中</span><br><span class="line">                       // 的RelativeLayout的id会变成include标签中的id，include不设置id，那么也可以通过relative的找到.</span><br><span class="line">                         view.setId(id);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     switch (visibility) &#123;</span><br><span class="line">                         case 0:</span><br><span class="line">                             view.setVisibility(View.VISIBLE);</span><br><span class="line">                             break;</span><br><span class="line">                         case 1:</span><br><span class="line">                             view.setVisibility(View.INVISIBLE);</span><br><span class="line">                             break;</span><br><span class="line">                         case 2:</span><br><span class="line">                             view.setVisibility(View.GONE);</span><br><span class="line">                             break;</span><br><span class="line">                     &#125;</span><br><span class="line">                     // 6、将根view添加到父控件中</span><br><span class="line">                     group.addView(view);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; finally &#123;</span><br><span class="line">                 childParser.close();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         throw new InflateException(&quot;&lt;include /&gt; can only be used inside of a ViewGroup&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     //默认的可见性使得LayoutInflater_Delegate代表可以调用它。</span><br><span class="line">     LayoutInflater.consumeChildElements(parser);</span><br></pre></td></tr></table></figure></li><li><p>分段分析上面的那段代码，<br>1、如果VIEW视图有一个主题属性，我们需要忽略它。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//如果VIEW视图有一个主题属性，我们需要忽略它。</span><br><span class="line">final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);</span><br><span class="line">final int themeResId = ta.getResourceId(0, 0);</span><br><span class="line">final boolean hasThemeOverride = themeResId != 0;</span><br><span class="line">if (hasThemeOverride) &#123;</span><br><span class="line">    context = new ContextThemeWrapper(context, themeResId);</span><br><span class="line">&#125;</span><br><span class="line">ta.recycle();</span><br></pre></td></tr></table></figure></li></ul><p>2、如果布局指向主题属性，我们必须从该值以从中获取资源标识符！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//如果布局指向主题属性，我们必须</span><br><span class="line">//按摩该值以从中获取资源标识符。</span><br><span class="line">int layout = attrs.getAttributeResourceValue(null, ATTR_LAYOUT, 0);</span><br></pre></td></tr></table></figure></p><p>3、在这里出现<code>value == null || value.length() &lt;= 0</code>的话，就会抛出异常，也就是说<code>include</code>标签中没有设置<code>layout</code>属性，会抛出异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">if (layout == 0) &#123;</span><br><span class="line">    final String value = attrs.getAttributeValue(null, ATTR_LAYOUT);</span><br><span class="line">    // TODO: 2018/6/6 include标签中没有设置layout属性，会抛出异常</span><br><span class="line">    if (value == null || value.length() &lt;= 0) &#123;//</span><br><span class="line">        throw new InflateException(&quot;You must specify a layout in the&quot;</span><br><span class="line">                + &quot; include tag: &lt;include layout=\&quot;@layout/layoutID\&quot; /&gt;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    // Attempt to resolve the &quot;?attr/name&quot; string to an attribute</span><br><span class="line">    // within the default (e.g. application) package.</span><br><span class="line">    layout = context.getResources().getIdentifier(</span><br><span class="line">            value.substring(1), &quot;attr&quot;, context.getPackageName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、解析<code>include</code>中的第一个元素,如果这里第一个<code>childeName</code>是<code>merge</code>,那么就是 <code>include</code>和<code>merge</code> 一起使用的情况，调用的方法是<code>rInflate(childParser, parent, context, childAttrs, false);</code>和上面一样，不会生成多余的层级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1、解析include中的第一个元素</span><br><span class="line"> final String childName = childParser.getName();</span><br><span class="line">// 如果第一个元素是merge标签，那么调用rInflate函数解析</span><br><span class="line"> if (TAG_MERGE.equals(childName)) &#123;</span><br><span class="line">     // The &lt;merge&gt; tag doesn&apos;t support android:theme, so</span><br><span class="line">     // nothing special to do here.</span><br><span class="line">     rInflate(childParser, parent, context, childAttrs, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>4、首先根据include的属性集创建被include进来的xml布局的根view,这个<code>view</code>其实就<code>include</code> 进来的根<code>ViewGroup</code>,因为在前面已经把<code>merge</code>的情况过滤掉了，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">   //2、我们例子中的情况会走到这一步,首先根据include的属性集创建被include进来的xml布局的根view</span><br><span class="line">   final View view = createViewFromTag(parent, childName,</span><br><span class="line">           context, childAttrs, hasThemeOverride);</span><br></pre></td></tr></table></figure></p><p>5、特别关心这个<code>final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);</code>函数，其实就是给<code>include</code>标签设是否设置了<code>id</code>,就好像下面的布局一样，如果设置了这个<code>android:id=&quot;@+id/my_title_ly&quot;</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;include</span><br><span class="line">    android:id=&quot;@+id/my_title_ly&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    layout=&quot;@layout/my_include_layout&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>这个是上面得<code>include</code>的布局<code>my_include_layout</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:id=&quot;@+id/my_title_parent_id&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot; &gt;</span><br><span class="line">   ....</span><br><span class="line">&lt;/RelativeLayout&gt;</span><br></pre></td></tr></table></figure></p><p>下面的这段代码就会执行，这也就解释了：安卓<code>include</code>标签的找不到id的问题,因为你在<code>include</code>设置了这个<code>id</code>属性，那么你找这个<code>my_title_parent_id</code>这个id，<code>findViewById(R.id.my_title_parent_id)</code>肯定也会找出来为null！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">                        final int id = a.getResourceId(R.styleable.Include_id, View.NO_ID);</span><br><span class="line">                        if (id != View.NO_ID) &#123;</span><br><span class="line">                         // 5、将include中设置的id设置给根view,因此实际上my_title_layout.xml中</span><br><span class="line">                          // 的RelativeLayout的id会变成include标签中的id，include不设置id，那么也可以通过relative的找到.</span><br><span class="line">                            view.setId(id);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 为什么<code>findViewById(R.id.my_title_parent_id)</code>会找出来为null,简单叙述下就是在<code>Activity</code>中调用方法其实是<code>Window</code>的<code>findViewById</code>,<code>getDecorView().findViewById(id)</code>,也就是<code>PhoneWindow</code>里面的<code>DecorView</code>的<code>findViewById</code>,也就是<code>View</code>的<code>findViewById</code>;可以看这边文章<a href="https://www.jianshu.com/p/f7e3a14daf51" target="_blank" rel="noopener">Android源码分析（事件传递）</a>涉及到这几个类了。如下面的方法，这个View 有id，找id的话就会走<code>findViewTraversal</code>这个方法，找的id和<code>setId</code>不一样的话，就会返回null，这就是找不到 <code>id</code>的原因。这个原因和<code>ViewStub</code>标签中设置了<code>inflatedId</code>一样的效果，下篇文章会讲到，非常有意思！已经写好<a href="https://www.jianshu.com/p/63a066e7a5a9" target="_blank" rel="noopener">Android源码分析(ViewStub源码解析)</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> public final &lt;T extends View&gt; T findViewById(@IdRes int id) &#123;</span><br><span class="line">    if (id == NO_ID) &#123;</span><br><span class="line">         return null;</span><br><span class="line">   &#125;</span><br><span class="line">    return findViewTraversal(id);</span><br><span class="line"> &#125;</span><br><span class="line">protected &lt;T extends View&gt; T findViewTraversal(@IdRes int id) &#123;</span><br><span class="line">   if (id == mID) &#123;</span><br><span class="line">        return (T) this;</span><br><span class="line">   &#125;</span><br><span class="line">   return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>View中设置<code>id</code>的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public void setId(@IdRes int id) &#123;</span><br><span class="line">   mID = id;</span><br><span class="line">    if (mID == View.NO_ID &amp;&amp; mLabelForId != View.NO_ID) &#123;</span><br><span class="line">         mID = generateViewId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6、关于<code>final int visibility = a.getInt(R.styleable.Include_visibility, -1);</code>这行代码，也就是说我们设置了<code>include</code>标签’visibility’其实也就是设置<code>layout</code>的<code>visibility</code>的属性！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">final int visibility = a.getInt(R.styleable.Include_visibility, -1);</span><br><span class="line">  switch (visibility) &#123;</span><br><span class="line">                          case 0:</span><br><span class="line">                              view.setVisibility(View.VISIBLE);</span><br><span class="line">                              break;</span><br><span class="line">                          case 1:</span><br><span class="line">                              view.setVisibility(View.INVISIBLE);</span><br><span class="line">                              break;</span><br><span class="line">                          case 2:</span><br><span class="line">                              view.setVisibility(View.GONE);</span><br><span class="line">                              break;</span><br><span class="line">                      &#125;</span><br></pre></td></tr></table></figure><p>7、将根view添加到父控件中,最后都会走到这里来，只不过使用了<code>merge</code>是不会产生多余的层级的，但是使用的时候有场景的要求！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">group.addView(view);</span><br></pre></td></tr></table></figure></p><ul><li><p>最后做了一张图，谢谢<br><img src="https://upload-images.jianshu.io/upload_images/5363507-3328730701d08022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="LayoutInflater.from(this).inflate(resId,null);代码解析.png"></p></li><li><p>说明几点</p><ul><li>布局转化为View，关键方法就是<code>LayoutInflater.from(this),inflate()</code></li><li><code>PhoneWindow</code>这个类很关键</li><li>如果需要打断点，建议使用模拟器，手机的厂商基本上改动过<code>framework</code>的代码，打出来不准确</li><li><code>merge</code>原理就是通过<code>addView(view)</code>,从而减少了层级<ul><li><code>BlinkLayout</code>这个是<code>LayoutInflater</code>的内部类，感觉是谷歌工程师皮了一下</li></ul></li><li><code>include</code>只能在ViewGroup中使用，在 ‘View’结点中使用的话，会报错</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
            <tag> LayoutInflater </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析ViewStub源码解析</title>
      <link href="/2018/06/07/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90ViewStub%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/06/07/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90ViewStub%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2><ul><li><code>ViewStub</code>是一种不可见的并且大小为0的试图，它可以延迟到运行时才填充<code>inflate</code> 布局资源，当<code>Viewstub</code>设为可见或者是<code>inflate</code>的时候，就会填充布局资源，这个布局和普通的试图就基本上没有任何区别，比如说，加载网络失败，或者是一个比较消耗性能的功能，需要用户去点击才可以加载!从而这样更加的节约了性能。对安卓布局很友好！<a id="more"></a></li><li><p><code>ViewStub</code>用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ViewStub</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">    android:layout_gravity=&quot;center&quot;</span><br><span class="line">    android:inflatedId=&quot;@+id/view_stub_inflateid&quot;</span><br><span class="line">    android:id=&quot;@+id/view_stub&quot;</span><br><span class="line">    android:layout=&quot;@layout/view_stub_imageview&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>这篇文章<a href="https://www.jianshu.com/p/82b76e0cb41e" target="_blank" rel="noopener">安卓代码、图片、布局、网络和电量优化</a>说如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点  —–2018.6.7修正这个说法，以前我说的是错误的，根本上的原因是ViewStub设置了 inflateid ，这才是更本身的原因</p></li><li><p>在这里记住一点，如果在 <code>ViewStub</code>标签中设置了<code>android:inflatedId=&quot;@+id/view_stub_inflateid&quot;</code>,在<code>layout</code>布局中的根布局在设置<code>android:id=&quot;@+id/view_stub_layout&quot;</code>,这个<code>id</code>永远找出来都是为null的，原因会在下面说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:id=&quot;@+id/view_stub_layout&quot;</span><br><span class="line">    android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点  -----2018.6.7修正这个说法，以前我说的是错误的，根本上的原因是ViewStub设置了 inflateid ，这才是更本身的原因&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:id=&quot;@+id/imageview&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></li><li><p>在<code>activity</code>或者是<code>fragment</code>中的使用,<code>mViewStub.getParent()==null</code>就是说明没有被填充，需要填充，如果填充了，那么它的<code>parent</code>不会为null，具体的骚操作，后续我介绍<code>View</code>的绘制流程的时候在详细说明。</p></li><li><p>第一种使用的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> mViewStub = findViewById(R.id.view_stub);</span><br><span class="line"> if (null!=mViewStub.getParent())&#123;</span><br><span class="line"> View inflate = mViewStub.inflate();</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式:<code>mViewStub.setVisibility(View.VISIBLE);</code>和<code>inflate()</code>方法一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> mViewStub = findViewById(R.id.view_stub);</span><br><span class="line"> if (null!=mViewStub.getParent())&#123;</span><br><span class="line">   mViewStub.setVisibility(View.VISIBLE);</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第三种方式,<code>my_title_parent_id</code>是<code>layout</code>的根布局的<code>id</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   mViewStub = findViewById(R.id.view_stub);</span><br><span class="line"> // 成员变量commLv2为空则代表未加载 commLv2 的id为ViewStub中的根布局的id</span><br><span class="line"> View commLv2=findViewById(R.id.my_title_parent_id);</span><br><span class="line">if ( commLv2 == null ) &#123;</span><br><span class="line">   // 加载评论列表布局, 并且获取评论ListView,inflate函数直接返回ListView对象</span><br><span class="line">     commLv2 = (View)mViewStub.inflate();</span><br><span class="line">   &#125; else &#123;</span><br><span class="line">      // ViewStub已经加载</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ViewStub</code>构造方法,注意获取了几个值<code>mInflatedId</code>就是<code>android:inflatedId=&quot;@+id/find_view_stub&quot;</code>这个值， <code>mLayoutResource</code>就是<code>layout</code>的resId，ViewStub的  <code>mID</code>id。可以看出<code>ViewStub</code>是<code>View</code>的子类.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public final class ViewStub extends View &#123;</span><br><span class="line"> public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        final TypedArray a = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.ViewStub, defStyleAttr, defStyleRes);</span><br><span class="line">        // TODO: 2018/5/23  ViewStub 中设置的标签id 如果设置了 这里就一定有值 mInflatedId！=NO_Id</span><br><span class="line">        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</span><br><span class="line">        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0);</span><br><span class="line">        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</span><br><span class="line">        a.recycle();</span><br><span class="line">        //不可见</span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">        // 设置不绘制</span><br><span class="line">        setWillNotDraw(true);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在构造方法中:同时注意不可见 <code>setVisibility(GONE);</code> ,设置不绘制<code>setWillNotDraw(true);</code>,同时通过下面的方法看出，ViewStub 是一个大小为0的视图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">     // 宽高都为0   onMeasure的时候 宽高都为0</span><br><span class="line">     setMeasuredDimension(0, 0);</span><br><span class="line"> &#125;</span><br><span class="line"> //todo 为啥这个控件 是个大小为0的控件 ，那是因为他妈的这里更不就没有画</span><br><span class="line"> @Override</span><br><span class="line"> public void draw(Canvas canvas) &#123;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>inflate()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public View inflate() &#123;</span><br><span class="line">      // 1、获取ViewStub的parent view，也是目标布局根元素的parent view</span><br><span class="line">      final ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">      if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) &#123;</span><br><span class="line">          if (mLayoutResource != 0) &#123;</span><br><span class="line">              final ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">              /// 2、加载目标布局  牛逼的方法</span><br><span class="line">              final View view = inflateViewNoAdd(parent);</span><br><span class="line">              // 3、将ViewStub自身从parent中移除</span><br><span class="line">              replaceSelfWithView(view, parent);</span><br><span class="line"></span><br><span class="line">              mInflatedViewRef = new WeakReference&lt;&gt;(view);</span><br><span class="line">              if (mInflateListener != null) &#123;</span><br><span class="line">                  mInflateListener.onInflate(this, view);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              return view;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              // TODO: 2018/5/23 必须设置布局的文件</span><br><span class="line">              throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          // TODO: 2018/5/23 iewParent instanceof ViewGroup 不属于的话，就好比在一个TextView创建一个ViewStub直接爆炸</span><br><span class="line">          throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>第一点，ViewStup也只能在ViewGroup中使用，不能在View中去使用，要不然会抛出异常<code>IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;);</code></p></li><li>第二点，也必须设置<code>layout</code>属性，要不然也会抛出异常<code>throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;);</code>;</li></ul><ul><li><p>关于方法<code>inflateViewNoAdd(parent);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private View inflateViewNoAdd(ViewGroup parent) &#123;</span><br><span class="line">     final LayoutInflater factory;</span><br><span class="line">     if (mInflater != null) &#123;</span><br><span class="line">         factory = mInflater;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         factory = LayoutInflater.from(mContext);</span><br><span class="line">     &#125;</span><br><span class="line">     final View view = factory.inflate(mLayoutResource, parent, false);</span><br><span class="line">     //和 LayoutInflater一个道理，设置了，ViewStub 引用进来的根布局的id找出来为null  非常有些意思</span><br><span class="line">     if (mInflatedId != NO_ID) &#123;</span><br><span class="line">         view.setId(mInflatedId);</span><br><span class="line">     &#125;</span><br><span class="line">     return view;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>第一点，底层调用的还是<code>LayoutInflater.from(mContext).inflate(mLayoutResource, parent, false);</code>,<a href="https://www.jianshu.com/p/38c6a9842efc" target="_blank" rel="noopener">Android源码分析（LayoutInflater.from(this).inflate(resId,null);源码解析）</a>,这里不做过多的说明</p></li><li><p>第二点，又看到这个方法，似曾相识，对，这也是为什么<code>ViewStub</code>找不到根布局id的原因，因为<code>mInflatedId != NO_ID</code>,就会<code>view.setId(mInflatedId);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  if (mInflatedId != NO_ID) &#123;</span><br><span class="line">        view.setId(mInflatedId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将ViewStub自身从parent中移除<code>replaceSelfWithView(view, parent);</code>,具体的原因，这里不做分析，因为有点小复杂，这里就大概明白就行，对于理解这个ViewStub不困难，哈哈</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void replaceSelfWithView(View view, ViewGroup parent) &#123;</span><br><span class="line">    final int index = parent.indexOfChild(this);</span><br><span class="line">    // 3、将ViewStub自身从parent中移除</span><br><span class="line">    parent.removeViewInLayout(this);</span><br><span class="line"></span><br><span class="line">    final ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">    if (layoutParams != null) &#123;</span><br><span class="line">        // 4、将目标布局的根元素添加到parent中，有参数</span><br><span class="line">        parent.addView(view, index, layoutParams);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">       // 5、将目标布局的根元素添加到parent中</span><br><span class="line">        parent.addView(view, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这里使用到了弱引用，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不论当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用，为了更好地释放内存，<a href="https://www.jianshu.com/p/82b76e0cb41e" target="_blank" rel="noopener">安卓代码、图片、布局、网络和电量优化</a>这篇文章有很好的解释，而且这个<code>mInflatedViewRef</code>只在这里初始化，如果说没有调用<code>inflate</code>的方法的话，这个对象一定为<code>null</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//更好的释放内存</span><br><span class="line"> private WeakReference&lt;View&gt; mInflatedViewRef;</span><br><span class="line"> mInflatedViewRef = new WeakReference&lt;&gt;(view);</span><br><span class="line">               if (mInflateListener != null) &#123;</span><br><span class="line">              mInflateListener.onInflate(this, view)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>为啥<code>setVisibility（View.VISIBLE）</code>等同于<code>inflate</code>,原因是<code>ViewStub</code>进行了重写。可以看出代码的逻辑，只要没有调用过，<code>inflate()</code>方法，<code>setVisibility(VISIBLE )</code> 和<code>setVisibility(INVISIBLE)</code>这个两个参数走的方法一样，只不过，一个看不到，实际上的位置已经确定了（INVISIBLE）。但是如果调用多次的话<code>setVisibility()</code>记得也得判断下<code>null!=mViewStub.getParent()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    @android.view.RemotableViewMethod(asyncImpl = &quot;setVisibilityAsync&quot;)</span><br><span class="line">    public void setVisibility(int visibility) &#123;</span><br><span class="line">        // TODO: 2018/5/23  弱引用的使用</span><br><span class="line">        //如果已经加载过则只设置Visibility属性</span><br><span class="line">        if (mInflatedViewRef != null) &#123;</span><br><span class="line">            View view = mInflatedViewRef.get();</span><br><span class="line">            if (view != null) &#123;</span><br><span class="line">                view.setVisibility(visibility);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果未加载,这加载目标布局</span><br><span class="line">            super.setVisibility(visibility);</span><br><span class="line">            if (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">                inflate();// 调用inflate来加载目标布局</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>贴出全部的代码，有空的话，可以研究下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br></pre></td><td class="code"><pre><span class="line">@RemoteView</span><br><span class="line">public final class ViewStub extends View &#123;</span><br><span class="line">    private int mInflatedId;</span><br><span class="line">    private int mLayoutResource;</span><br><span class="line">    // TODO: 2018/5/23 弱引用：弱引用是比软引用更弱的一种的引用的类型，</span><br><span class="line">    // 只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，</span><br><span class="line">    // 不敢当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用</span><br><span class="line"></span><br><span class="line">    //更好的释放内存</span><br><span class="line">    private WeakReference&lt;View&gt; mInflatedViewRef;</span><br><span class="line"></span><br><span class="line">    private LayoutInflater mInflater;</span><br><span class="line">    private OnInflateListener mInflateListener;</span><br><span class="line"></span><br><span class="line">    public ViewStub(Context context) &#123;</span><br><span class="line">        this(context, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Creates a new ViewStub with the specified layout resource.</span><br><span class="line">     *</span><br><span class="line">     * @param context The application&apos;s environment.</span><br><span class="line">     * @param layoutResource The reference to a layout resource that will be inflated.</span><br><span class="line">     */</span><br><span class="line">    public ViewStub(Context context, @LayoutRes int layoutResource) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line"></span><br><span class="line">        mLayoutResource = layoutResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewStub(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewStub(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        this(context, attrs, defStyleAttr, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ViewStub(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;</span><br><span class="line">        super(context);</span><br><span class="line"></span><br><span class="line">        final TypedArray a = context.obtainStyledAttributes(attrs,</span><br><span class="line">                R.styleable.ViewStub, defStyleAttr, defStyleRes);</span><br><span class="line">        // TODO: 2018/5/23  ViewStub 中设置的标签id 如果设置了 这里就一定有值 mInflatedId！=NO_Id</span><br><span class="line">        mInflatedId = a.getResourceId(R.styleable.ViewStub_inflatedId, NO_ID);</span><br><span class="line">        mLayoutResource = a.getResourceId(R.styleable.ViewStub_layout, 0);</span><br><span class="line">        mID = a.getResourceId(R.styleable.ViewStub_id, NO_ID);</span><br><span class="line">        a.recycle();</span><br><span class="line">        //不可见</span><br><span class="line">        setVisibility(GONE);</span><br><span class="line">        // 设置不绘制</span><br><span class="line">        setWillNotDraw(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the id taken by the inflated view. If the inflated id is</span><br><span class="line">     * &#123;@link View#NO_ID&#125;, the inflated view keeps its original id.</span><br><span class="line">     *</span><br><span class="line">     * @return A positive integer used to identify the inflated view or</span><br><span class="line">     *         &#123;@link #NO_ID&#125; if the inflated view should keep its id.</span><br><span class="line">     *</span><br><span class="line">     * @see #setInflatedId(int)</span><br><span class="line">     * @attr ref android.R.styleable#ViewStub_inflatedId</span><br><span class="line">     */</span><br><span class="line">    @IdRes</span><br><span class="line">    public int getInflatedId() &#123;</span><br><span class="line">        return mInflatedId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Defines the id taken by the inflated view. If the inflated id is</span><br><span class="line">     * &#123;@link View#NO_ID&#125;, the inflated view keeps its original id.</span><br><span class="line">     *</span><br><span class="line">     * @param inflatedId A positive integer used to identify the inflated view or</span><br><span class="line">     *                   &#123;@link #NO_ID&#125; if the inflated view should keep its id.</span><br><span class="line">     *</span><br><span class="line">     * @see #getInflatedId()</span><br><span class="line">     * @attr ref android.R.styleable#ViewStub_inflatedId</span><br><span class="line">     */</span><br><span class="line">    @android.view.RemotableViewMethod(asyncImpl = &quot;setInflatedIdAsync&quot;)</span><br><span class="line">    public void setInflatedId(@IdRes int inflatedId) &#123;</span><br><span class="line">        mInflatedId = inflatedId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @hide **/</span><br><span class="line">    public Runnable setInflatedIdAsync(@IdRes int inflatedId) &#123;</span><br><span class="line">        mInflatedId = inflatedId;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the layout resource that will be used by &#123;@link #setVisibility(int)&#125; or</span><br><span class="line">     * &#123;@link #inflate()&#125; to replace this StubbedView</span><br><span class="line">     * in its parent by another view.</span><br><span class="line">     *</span><br><span class="line">     * @return The layout resource identifier used to inflate the new View.</span><br><span class="line">     *</span><br><span class="line">     * @see #setLayoutResource(int)</span><br><span class="line">     * @see #setVisibility(int)</span><br><span class="line">     * @see #inflate()</span><br><span class="line">     * @attr ref android.R.styleable#ViewStub_layout</span><br><span class="line">     */</span><br><span class="line">    @LayoutRes</span><br><span class="line">    public int getLayoutResource() &#123;</span><br><span class="line">        return mLayoutResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Specifies the layout resource to inflate when this StubbedView becomes visible or invisible</span><br><span class="line">     * or when &#123;@link #inflate()&#125; is invoked. The View created by inflating the layout resource is</span><br><span class="line">     * used to replace this StubbedView in its parent.</span><br><span class="line">     *</span><br><span class="line">     * @param layoutResource A valid layout resource identifier (different from 0.)</span><br><span class="line">     *</span><br><span class="line">     * @see #getLayoutResource()</span><br><span class="line">     * @see #setVisibility(int)</span><br><span class="line">     * @see #inflate()</span><br><span class="line">     * @attr ref android.R.styleable#ViewStub_layout</span><br><span class="line">     */</span><br><span class="line">    @android.view.RemotableViewMethod(asyncImpl = &quot;setLayoutResourceAsync&quot;)</span><br><span class="line">    public void setLayoutResource(@LayoutRes int layoutResource) &#123;</span><br><span class="line">        mLayoutResource = layoutResource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @hide **/</span><br><span class="line">    public Runnable setLayoutResourceAsync(@LayoutRes int layoutResource) &#123;</span><br><span class="line">        mLayoutResource = layoutResource;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Set &#123;@link LayoutInflater&#125; to use in &#123;@link #inflate()&#125;, or &#123;@code null&#125;</span><br><span class="line">     * to use the default.</span><br><span class="line">     */</span><br><span class="line">    public void setLayoutInflater(LayoutInflater inflater) &#123;</span><br><span class="line">        mInflater = inflater;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get current &#123;@link LayoutInflater&#125; used in &#123;@link #inflate()&#125;.</span><br><span class="line">     */</span><br><span class="line">    public LayoutInflater getLayoutInflater() &#123;</span><br><span class="line">        return mInflater;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        // 宽高都为0   onMeasure的时候 宽高都为0</span><br><span class="line">        setMeasuredDimension(0, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    //todo 为啥这个控件 是个大小为0的控件 ，那是因为他妈的这里更不就没有画</span><br><span class="line">    @Override</span><br><span class="line">    public void draw(Canvas canvas) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void dispatchDraw(Canvas canvas) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * When visibility is set to &#123;@link #VISIBLE&#125; or &#123;@link #INVISIBLE&#125;,</span><br><span class="line">     * &#123;@link #inflate()&#125; is invoked and this StubbedView is replaced in its parent</span><br><span class="line">     * by the inflated layout resource. After that calls to this function are passed</span><br><span class="line">     * through to the inflated view.</span><br><span class="line">     *</span><br><span class="line">     * @param visibility One of &#123;@link #VISIBLE&#125;, &#123;@link #INVISIBLE&#125;, or &#123;@link #GONE&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @see #inflate()</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    @android.view.RemotableViewMethod(asyncImpl = &quot;setVisibilityAsync&quot;)</span><br><span class="line">    public void setVisibility(int visibility) &#123;</span><br><span class="line">        // TODO: 2018/5/23  弱引用的使用</span><br><span class="line">        //如果已经加载过则只设置Visibility属性</span><br><span class="line">        if (mInflatedViewRef != null) &#123;</span><br><span class="line">            View view = mInflatedViewRef.get();</span><br><span class="line">            if (view != null) &#123;</span><br><span class="line">                view.setVisibility(visibility);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new IllegalStateException(&quot;setVisibility called on un-referenced view&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 如果未加载,这加载目标布局</span><br><span class="line">            super.setVisibility(visibility);</span><br><span class="line">            if (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">                inflate();// 调用inflate来加载目标布局</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @hide **/</span><br><span class="line">    public Runnable setVisibilityAsync(int visibility) &#123;</span><br><span class="line">        if (visibility == VISIBLE || visibility == INVISIBLE) &#123;</span><br><span class="line">            ViewGroup parent = (ViewGroup) getParent();</span><br><span class="line">            return new ViewReplaceRunnable(inflateViewNoAdd(parent));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private View inflateViewNoAdd(ViewGroup parent) &#123;</span><br><span class="line">        final LayoutInflater factory;</span><br><span class="line">        if (mInflater != null) &#123;</span><br><span class="line">            factory = mInflater;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            factory = LayoutInflater.from(mContext);</span><br><span class="line">        &#125;</span><br><span class="line">        final View view = factory.inflate(mLayoutResource, parent, false);</span><br><span class="line">        //和 LayoutInflater一个道理，设置了，ViewStub 引用进来的根布局的id找出来为null  非常有些意思</span><br><span class="line">        if (mInflatedId != NO_ID) &#123;</span><br><span class="line">            view.setId(mInflatedId);</span><br><span class="line">        &#125;</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // TODO: 2018/5/23 关注他</span><br><span class="line">    private void replaceSelfWithView(View view, ViewGroup parent) &#123;</span><br><span class="line">        final int index = parent.indexOfChild(this);</span><br><span class="line">        // 3、将ViewStub自身从parent中移除</span><br><span class="line">        parent.removeViewInLayout(this);</span><br><span class="line"></span><br><span class="line">        final ViewGroup.LayoutParams layoutParams = getLayoutParams();</span><br><span class="line">        if (layoutParams != null) &#123;</span><br><span class="line">            // 4、将目标布局的根元素添加到parent中，有参数</span><br><span class="line">            parent.addView(view, index, layoutParams);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           // 5、将目标布局的根元素添加到parent中</span><br><span class="line">            parent.addView(view, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inflates the layout resource identified by &#123;@link #getLayoutResource()&#125;</span><br><span class="line">     * and replaces this StubbedView in its parent by the inflated layout resource.</span><br><span class="line">     *</span><br><span class="line">     * @return The inflated layout resource.</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public View inflate() &#123;</span><br><span class="line">        // 1、获取ViewStub的parent view，也是目标布局根元素的parent view</span><br><span class="line">        final ViewParent viewParent = getParent();</span><br><span class="line"></span><br><span class="line">        if (viewParent != null &amp;&amp; viewParent instanceof ViewGroup) &#123;</span><br><span class="line">            if (mLayoutResource != 0) &#123;</span><br><span class="line">                final ViewGroup parent = (ViewGroup) viewParent;</span><br><span class="line">                /// 2、加载目标布局  牛逼的方法</span><br><span class="line">                final View view = inflateViewNoAdd(parent);</span><br><span class="line">                // 3、将ViewStub自身从parent中移除</span><br><span class="line">                replaceSelfWithView(view, parent);</span><br><span class="line"></span><br><span class="line">                mInflatedViewRef = new WeakReference&lt;&gt;(view);</span><br><span class="line">                if (mInflateListener != null) &#123;</span><br><span class="line">                    mInflateListener.onInflate(this, view);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                return view;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // TODO: 2018/5/23 必须设置布局的文件</span><br><span class="line">                throw new IllegalArgumentException(&quot;ViewStub must have a valid layoutResource&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // TODO: 2018/5/23 iewParent instanceof ViewGroup 不属于的话，就好比在一个TextView创建一个ViewStub直接爆炸</span><br><span class="line">            throw new IllegalStateException(&quot;ViewStub must have a non-null ViewGroup viewParent&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Specifies the inflate listener to be notified after this ViewStub successfully</span><br><span class="line">     * inflated its layout resource.</span><br><span class="line">     *</span><br><span class="line">     * @param inflateListener The OnInflateListener to notify of successful inflation.</span><br><span class="line">     *</span><br><span class="line">     * @see ViewStub.OnInflateListener</span><br><span class="line">     */</span><br><span class="line">    public void setOnInflateListener(OnInflateListener inflateListener) &#123;</span><br><span class="line">        mInflateListener = inflateListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Listener used to receive a notification after a ViewStub has successfully</span><br><span class="line">     * inflated its layout resource.</span><br><span class="line">     *</span><br><span class="line">     * @see ViewStub#setOnInflateListener(ViewStub.OnInflateListener)</span><br><span class="line">     */</span><br><span class="line">    public static interface OnInflateListener &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Invoked after a ViewStub successfully inflated its layout resource.</span><br><span class="line">         * This method is invoked after the inflated view was added to the</span><br><span class="line">         * hierarchy but before the layout pass.</span><br><span class="line">         *</span><br><span class="line">         * @param stub The ViewStub that initiated the inflation.</span><br><span class="line">         * @param inflated The inflated View.</span><br><span class="line">         */</span><br><span class="line">        void onInflate(ViewStub stub, View inflated);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** @hide **/</span><br><span class="line">    public class ViewReplaceRunnable implements Runnable &#123;</span><br><span class="line">        public final View view;</span><br><span class="line"></span><br><span class="line">        ViewReplaceRunnable(View view) &#123;</span><br><span class="line">            this.view = view;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            replaceSelfWithView(view, (ViewGroup) getParent());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最后做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-f369f9eecac1b239.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ViewStub源码解析.jpg"></p></li><li>说明一下<ul><li><code>ViewStub</code>的原理很简单！好吧，这个有点皮</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
            <tag> ViewStub </tag>
            
            <tag> 绘制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析（Activity.setContentView源码解析）</title>
      <link href="/2018/05/29/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Activity-setContentView%E6%BA%90%E7%A0%81%E6%9E%90/"/>
      <url>/2018/05/29/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Activity-setContentView%E6%BA%90%E7%A0%81%E6%9E%90/</url>
      <content type="html"><![CDATA[<h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2><ul><li>为什么要写这篇文章？其实是给这个LayoutInflater类铺垫的，要解释这个LayoutInflater源码，就必须知道到底怎么调用的，包括include、merge、ViewStub和原理，如何自己撸一个大小为0的View，我们最能够接触到的地方都是这个方法。<a id="more"></a></li><li><p>调用的是AppCompatActivity的setContentView（）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">    getDelegate().setContentView(layoutResID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意下getDelegate（）方法中的AppCompatDelegate.create(this,this)，传入的是this，也就是Activity的本身，这里不会讲到，但是在讲到View的绘制流程，需要明白初始化传入的是什么</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@NonNull</span><br><span class="line">  public AppCompatDelegate getDelegate() &#123;</span><br><span class="line">      if (mDelegate == null) &#123;</span><br><span class="line">          mDelegate = AppCompatDelegate.create(this, this);</span><br><span class="line">      &#125;</span><br><span class="line">      return mDelegate;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>去找实现的类，AppCompatDelegateImplV9<br><img src="https://upload-images.jianshu.io/upload_images/5363507-3b2398a0279d9f2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void setContentView(View v) &#123;</span><br><span class="line">      ensureSubDecor();</span><br><span class="line">      ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">      contentParent.removeAllViews();</span><br><span class="line">      contentParent.addView(v);</span><br><span class="line">      mOriginalWindowCallback.onContentChanged();</span><br><span class="line">  &#125;</span><br><span class="line">  @Override</span><br><span class="line">  public void setContentView(View v, ViewGroup.LayoutParams lp) &#123;</span><br><span class="line">      ensureSubDecor();</span><br><span class="line">      ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">      contentParent.removeAllViews();</span><br><span class="line">      contentParent.addView(v, lp);</span><br><span class="line">      mOriginalWindowCallback.onContentChanged();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>其中这种方法在实际的使用过程中，是最常见方法，核心的方法会调用到 LayoutInflater.from(mContext).inflate(resId, contentParent);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void setContentView(int resId) &#123;</span><br><span class="line">    ensureSubDecor();</span><br><span class="line">    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">    contentParent.removeAllViews();</span><br><span class="line">    LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">    mOriginalWindowCallback.onContentChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ensureSubDecor();不管使用哪种的setContentView都会调用这个方法</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void ensureSubDecor() &#123;</span><br><span class="line">     if (!mSubDecorInstalled) &#123;</span><br><span class="line">         // TODO: 2018/5/23 关键的方法</span><br><span class="line">         mSubDecor = createSubDecor();</span><br><span class="line"></span><br><span class="line">         // If a title was set before we installed the decor, propagate it now</span><br><span class="line">         // TODO: 2018/5/23 2、如果我们在布局前安装了一个标题，现在就把它传播出去。</span><br><span class="line">         CharSequence title = getTitle();</span><br><span class="line">         if (!TextUtils.isEmpty(title)) &#123;</span><br><span class="line">             onTitleChanged(title);</span><br><span class="line">         &#125;</span><br><span class="line">         // TODO: 2018/5/23  3、适配尺寸在设备上，一些参数的初始化</span><br><span class="line">         applyFixedSizeWindow();</span><br><span class="line">         // TODO: 2018/5/23 4、空实现，我也不知道做啥的</span><br><span class="line">         onSubDecorInstalled(mSubDecor);</span><br><span class="line"></span><br><span class="line">         mSubDecorInstalled = true;</span><br><span class="line"></span><br><span class="line">         // Invalidate if the panel menu hasn&apos;t been created before this.</span><br><span class="line">         // Panel menu invalidation is deferred avoiding application onCreateOptionsMenu</span><br><span class="line">         // being called in the middle of onCreate or similar.</span><br><span class="line">         // A pending invalidation will typically be resolved before the posted message</span><br><span class="line">         // would run normally in order to satisfy instance state restoration.</span><br><span class="line">         // TODO: 2018/5/23 5、目前我也不知道做啥的，需要详细的研究</span><br><span class="line">         PanelFeatureState st = getPanelState(FEATURE_OPTIONS_PANEL, false);</span><br><span class="line">         if (!isDestroyed() &amp;&amp; (st == null || st.menu == null)) &#123;</span><br><span class="line">             invalidatePanelMenu(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>关于标记mSubDecorInstalled，可以这样的理解，当已经给Activity设置了一个layout，在设置的就会报错，这个标记就是来做这个的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// true if we have installed a window sub-decor layout.</span><br><span class="line">  private boolean mSubDecorInstalled;</span><br></pre></td></tr></table></figure></p><ul><li>关于createSubDecor（）方法，这也是最关键的方法在setContentview的过程中<br>createSubDecor()方法的解析</li><li><p>1、获取系统的TypedArray,系统主题，而且哇，找不到的话，抛出异常的同时，而且释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//1、获取系统的TypedArray</span><br><span class="line">       TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">       //2、系统主题，而且哇，找不到的话，抛出异常的同时，而且释放</span><br><span class="line">       if (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123;</span><br><span class="line">           a.recycle();</span><br><span class="line">           throw new IllegalStateException(</span><br><span class="line">                   &quot;You need to use a Theme.AppCompat theme (or descendant) with this activity.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">  if (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, false)) &#123;</span><br><span class="line">           requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">       &#125; else if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, false)) &#123;</span><br><span class="line">           // Don&apos;t allow an action bar if there is no title.</span><br><span class="line">           requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">       &#125;</span><br><span class="line">       if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, false)) &#123;</span><br><span class="line">           requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">       &#125;</span><br><span class="line">       if (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, false)) &#123;</span><br><span class="line">           requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>2、读取一个系统的属性android:windowIsFloating，记得释放recycle（），要不然这比消耗性能的很  mIsFloating表示浮在屏幕上的，如果在这里使用了，整个layout就会在 屏幕中心，相当于浮在屏幕上，所以这个只适用于dialog，Activity也可以是Dialog的样子.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, false);</span><br><span class="line">    a.recycle();</span><br></pre></td></tr></table></figure></li><li><p>3、调用了 mWindow.getDecorView();通过代码可以发现，PhoneWindow( Window的唯一的子类)，这个方法其实就是准备好根布局，这个根布局是DecorView，一个FrameLayout，他是把一个垂直方向的LinearLayout。addView到DecorView中，当然涉及到好多初始化，和系统的设置的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">      getDelegate().setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br><span class="line">    //todo 这里传入的是this，就是Activity的本身</span><br><span class="line">        @NonNull</span><br><span class="line">  public AppCompatDelegate getDelegate() &#123;</span><br><span class="line">      if (mDelegate == null) &#123;</span><br><span class="line">          mDelegate = AppCompatDelegate.create(this, this);</span><br><span class="line">      &#125;</span><br><span class="line">      return mDelegate;</span><br><span class="line">  &#125;</span><br><span class="line">   //todo 这里就是本身了 PhoneWindow  Window的唯一的子类</span><br><span class="line">     public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123;</span><br><span class="line">      return create(activity, activity.getWindow(), callback);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">     private static AppCompatDelegate create(Context context, Window window,</span><br><span class="line">          AppCompatCallback callback) &#123;</span><br><span class="line">      if (Build.VERSION.SDK_INT &gt;= 24) &#123;</span><br><span class="line">          return new AppCompatDelegateImplN(context, window, callback);</span><br><span class="line">      &#125; else if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">          return new AppCompatDelegateImplV23(context, window, callback);</span><br><span class="line">      &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">          return new AppCompatDelegateImplV14(context, window, callback);</span><br><span class="line">      &#125; else if (Build.VERSION.SDK_INT &gt;= 11) &#123;</span><br><span class="line">          return new AppCompatDelegateImplV11(context, window, callback);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">    //  todo V9 基类的第二层 就在这里</span><br><span class="line">          return new AppCompatDelegateImplV9(context, window, callback);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>####我们着重来关心下这个方法 mWindow.getDecorView();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mWindow.getDecorView();</span><br></pre></td></tr></table></figure></p><p>其实就是调用的是PhoneWindow的getDecorView<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public final View getDecorView() &#123;</span><br><span class="line">     if (mDecor == null) &#123;</span><br><span class="line">         installDecor();</span><br><span class="line">     &#125;</span><br><span class="line">     return mDecor;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>###关于PhoneWindow中的installDecor()；这个方法特别有意思，如果看到这个来了，你可以知道一下挖出好多源码级的东西</p><ul><li><p>获取DecorView，然后他是一个FrameLayout–&gt; new DecorView(getContext(), -1);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void installDecor() &#123;</span><br><span class="line">       if (mDecor == null) &#123;</span><br><span class="line">           //获取DecorView，然后他是一个FrameLayout</span><br><span class="line">           mDecor = generateDecor();</span><br><span class="line">           mDecor.setIsRootNamespace(true);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>其实这里就是给DecorView设置其他的系统属性，这两行代码是generateLayout的里面的</p></li><li><p>系统的第一种根布局com.android.internal.R.layout.screen_title：LinearLayout 布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">&lt;!--  Popout bar for action modes  --&gt;</span><br><span class="line"> &lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot;/&gt;</span><br><span class="line">&lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?android:attr/windowTitleSize&quot; style=&quot;?android:attr/windowTitleBackgroundStyle&quot;&gt;</span><br><span class="line"> &lt;TextView android:id=&quot;@android:id/title&quot; style=&quot;?android:attr/windowTitleStyle&quot; android:background=&quot;@null&quot; android:fadingEdge=&quot;horizontal&quot; android:gravity=&quot;center_vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line"> &lt;/FrameLayout&gt;</span><br><span class="line"> &lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dip&quot; android:layout_weight=&quot;1&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot;/&gt;</span><br><span class="line"> &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></li><li><p>系统的第一种根布局com.android.internal.R.layout.screen_simple_title：LinearLayout 布局</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:orientation=&quot;vertical&quot;&gt;</span><br><span class="line">&lt;ViewStub android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:theme=&quot;?attr/actionBarTheme&quot;/&gt;</span><br><span class="line">&lt;FrameLayout android:id=&quot;@android:id/content&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:foregroundInsidePadding=&quot;false&quot; android:foregroundGravity=&quot;fill_horizontal|top&quot; android:foreground=&quot;?android:attr/windowContentOverlay&quot;/&gt;</span><br><span class="line"> &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p>通过两种根布局的对比，其实其他的布局也差不多是这样子的。也可以得出Activity的根布局是个LinearLayout  并且方向是vertical的.，在把这个根布局加到DecorView中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> View in = mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">decor.addView(in, new ViewGroup.LayoutParams(FILL_PARENT, FILL_PARENT));</span><br></pre></td></tr></table></figure></p><p>然后呢，DecorView.addView（）到布局中，这里就做到了设备的适配的，而不是在底层设置好一个布局就行了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (mContentParent == null) &#123;</span><br><span class="line">    mContentParent = generateLayout(mDecor);</span><br></pre></td></tr></table></figure></p><ul><li><p>mTitleView = (TextView)findViewById(com.android.internal.R.id.title);当看到这一行代码的时候，我有点疑惑title好像一定找的到似的，没有注意到下面的代码。通过源码发现在View.findViewById()找不到会返回null，这里也判断了找不到这个title的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">        //这里我有疑惑，看样子这个id。title好像一定找的到似的</span><br><span class="line">        //麻痹，老子去找源码在View.findViewById()找不到会返回null</span><br><span class="line">        //这里的意思就是我找的到这个titleView我就设置title过去，或者是没有titile设置不可见</span><br><span class="line">        mTitleView = (TextView)findViewById(com.android.internal.R.id.title);</span><br><span class="line">        if (mTitleView != null) &#123;</span><br><span class="line">            if ((getLocalFeatures() &amp; (1 &lt;&lt; FEATURE_NO_TITLE)) != 0) &#123;</span><br><span class="line">                View titleContainer = findViewById(com.android.internal.R.id.title_container);</span><br><span class="line">                if (titleContainer != null) &#123;</span><br><span class="line">                    titleContainer.setVisibility(View.GONE);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mTitleView.setVisibility(View.GONE);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mContentParent instanceof FrameLayout) &#123;</span><br><span class="line">                    ((FrameLayout)mContentParent).setForeground(null);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                mTitleView.setText(mTitle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>4关键的还是LayoutInflater这个类,说明Activity.setContentView最后也会调用到这里来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final LayoutInflater inflater = LayoutInflater.from(mContext);</span><br></pre></td></tr></table></figure></li><li><p>5、一些设置:dialog式的Activity  Window.FEATURE_NO_TITLE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">if (!mWindowNoTitle) &#123;</span><br><span class="line">          if (mIsFloating) &#123;</span><br><span class="line">              subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                      R.layout.abc_dialog_title_material, null);</span><br><span class="line">              mHasActionBar = mOverlayActionBar = false;</span><br><span class="line">          &#125; else if (mHasActionBar) &#123;</span><br><span class="line">              //第六步：这需要一些解释。因为我们不能使用Android：主题属性pre-L，我手动的创建一个布局</span><br><span class="line">              // 填充器使用theme指向actionBar的主题，同时也找到了subDecor  ---》</span><br><span class="line">              // 现在使用主题上下文膨胀视图并将其设置为内容视图。</span><br><span class="line">              TypedValue outValue = new TypedValue();</span><br><span class="line">              mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, true);</span><br><span class="line"></span><br><span class="line">              Context themedContext;</span><br><span class="line">              if (outValue.resourceId != 0) &#123;</span><br><span class="line">                  themedContext = new ContextThemeWrapper(mContext, outValue.resourceId);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  themedContext = mContext;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Now inflate the view using the themed context and set it as the content view</span><br><span class="line">              subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                      .inflate(R.layout.abc_screen_toolbar, null);</span><br><span class="line"></span><br><span class="line">              mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                      .findViewById(R.id.decor_content_parent);</span><br><span class="line">              mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line"></span><br><span class="line">              /**</span><br><span class="line">               * Propagate features to DecorContentParent</span><br><span class="line">               */</span><br><span class="line">              if (mOverlayActionBar) &#123;</span><br><span class="line">                  mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">              &#125;</span><br><span class="line">              if (mFeatureProgress) &#123;</span><br><span class="line">                  mDecorContentParent.initFeature(Window.FEATURE_PROGRESS);</span><br><span class="line">              &#125;</span><br><span class="line">              if (mFeatureIndeterminateProgress) &#123;</span><br><span class="line">                  mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //第七步：如果设置了Window.FEATURE_NO_TITLE---》mWindowNoTitle==true</span><br><span class="line">          // 走到这个循环中，也是会设置初始化这个subDecor</span><br><span class="line">          if (mOverlayActionMode) &#123;</span><br><span class="line">              subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                      R.layout.abc_screen_simple_overlay_action_mode, null);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null);</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure></li><li><p>6 、对高版本适配:实现 Android 5.0 以上的插图效果的,可以明确的看到安卓5.0是个分界点，是不是在开发的过程中，安卓5.0上提供了好多系统的风格，这也是谷歌工程师Design的开始<br>Android 7.0    24    N<br>Android 6.0    23    M<br>Android 5.1    22    LOLLIPOP_MR1<br>Android 5.0    21    LOLLIPOP<br>Android 4.4W    20    KITKAT_WATCH<br>Android 4.4    19    KITKAT<br>Android 4.3    18    JELLY_BEAN_MR2<br>Android 4.2、4.2.2    17    JELLY_BEAN_MR1 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//第八步对高版本适配：ViewCompat.setOnApplyWindowInsetsListener()</span><br><span class="line"> // 原来就是为了实现 Android 5.0 以上的插图效果的。</span><br><span class="line"> if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">     // If we&apos;re running on L or above, we can rely on ViewCompat&apos;s</span><br><span class="line">     // setOnApplyWindowInsetsListener</span><br><span class="line">     ViewCompat.setOnApplyWindowInsetsListener(subDecor,</span><br><span class="line">             new OnApplyWindowInsetsListener() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public WindowInsetsCompat onApplyWindowInsets(View v,</span><br><span class="line">                         WindowInsetsCompat insets) &#123;</span><br><span class="line">                     final int top = insets.getSystemWindowInsetTop();</span><br><span class="line">                     final int newTop = updateStatusGuard(top);</span><br><span class="line"></span><br><span class="line">                     if (top != newTop) &#123;</span><br><span class="line">                         insets = insets.replaceSystemWindowInsets(</span><br><span class="line">                                 insets.getSystemWindowInsetLeft(),</span><br><span class="line">                                 newTop,</span><br><span class="line">                                 insets.getSystemWindowInsetRight(),</span><br><span class="line">                                 insets.getSystemWindowInsetBottom());</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     // Now apply the insets on our view</span><br><span class="line">                     return ViewCompat.onApplyWindowInsets(v, insets);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     // Else, we need to use our own FitWindowsViewGroup handling</span><br><span class="line">     ((FitWindowsViewGroup) subDecor).setOnFitSystemWindowsListener(</span><br><span class="line">             new FitWindowsViewGroup.OnFitSystemWindowsListener() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void onFitSystemWindows(Rect insets) &#123;</span><br><span class="line">                     insets.top = updateStatusGuard(insets.top);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>7  mWindow.setContentView(subDecor);方法，底层还是调用的PhoneWindow的setContentVeiw的方法:通过前面我们的分析PhoneWindow.getDecorView()的方法会提前在AppCompatDelegateImplV9.createSubDecor()方法中调用，所以这里mContentParent 不会为null.</p><ul><li>关键方法，一定走到这里来了，后续分析inflate的源码   mLayoutInflater.inflate(layoutResID, mContentParent)</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void setContentView(int layoutResID) &#123;</span><br><span class="line">      //通过前面我们的分析PhoneWindow.getDecorView()的方法会提前在AppCompatDelegateImplV9.createSubDecor()方法中调用，所以这里mContentParent 不会为null</span><br><span class="line">      if (mContentParent == null) &#123;</span><br><span class="line">          installDecor();</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //会走到这里来</span><br><span class="line">          mContentParent.removeAllViews();</span><br><span class="line">      &#125;</span><br><span class="line">      // TODO: 2018/5/29  关键方法，一定走到这里来了，后续分析inflate的源码 </span><br><span class="line">      mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">      final Callback cb = getCallback();</span><br><span class="line">      if (cb != null) &#123;</span><br><span class="line">          cb.onContentChanged();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>###createSubDecor()方法的代码如下，如果要深入理解的话，还是建议自己走源码一遍，这样理解的更加的透彻，哈哈~~</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br></pre></td><td class="code"><pre><span class="line"> private ViewGroup createSubDecor() &#123;</span><br><span class="line">        //1、获取系统的TypedArray</span><br><span class="line">        TypedArray a = mContext.obtainStyledAttributes(R.styleable.AppCompatTheme);</span><br><span class="line">        //2、系统主题，而且哇，找不到的话，抛出异常的同时，而且释放</span><br><span class="line">        if (!a.hasValue(R.styleable.AppCompatTheme_windowActionBar)) &#123;</span><br><span class="line">            a.recycle();</span><br><span class="line">            throw new IllegalStateException(</span><br><span class="line">                    &quot;You need to use a Theme.AppCompat theme (or descendant) with this activity.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (a.getBoolean(R.styleable.AppCompatTheme_windowNoTitle, false)) &#123;</span><br><span class="line">            requestWindowFeature(Window.FEATURE_NO_TITLE);</span><br><span class="line">        &#125; else if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBar, false)) &#123;</span><br><span class="line">            // Don&apos;t allow an action bar if there is no title.</span><br><span class="line">            requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.getBoolean(R.styleable.AppCompatTheme_windowActionBarOverlay, false)) &#123;</span><br><span class="line">            requestWindowFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">        &#125;</span><br><span class="line">        if (a.getBoolean(R.styleable.AppCompatTheme_windowActionModeOverlay, false)) &#123;</span><br><span class="line">            requestWindowFeature(FEATURE_ACTION_MODE_OVERLAY);</span><br><span class="line">        &#125;</span><br><span class="line">        /*</span><br><span class="line">        第二步，读取一个系统的属性android:windowIsFloating，记得释放recycle（），</span><br><span class="line">        要不然这比消耗性能的很  mIsFloating表示浮在屏幕上的，如果在这里使用了，</span><br><span class="line">        整个layout就会在 屏幕中心，相当于浮在屏幕上，所以这个只适用于dialog，Activity也可以是Dialog的样子</span><br><span class="line">         */</span><br><span class="line">        // TODO: 2018/5/23  大概相当于一个 dialog式的Activity</span><br><span class="line">        mIsFloating = a.getBoolean(R.styleable.AppCompatTheme_android_windowIsFloating, false);</span><br><span class="line">        a.recycle();</span><br><span class="line"></span><br><span class="line">        // Now let&apos;s make sure that the Window has installed its decor by retrieving it</span><br><span class="line">        /*</span><br><span class="line">     @Override</span><br><span class="line">      public void setContentView(@LayoutRes int layoutResID) &#123;</span><br><span class="line">        getDelegate().setContentView(layoutResID);</span><br><span class="line">      &#125;</span><br><span class="line">      todo 这里传入的是this，就是Activity的本身</span><br><span class="line">          @NonNull</span><br><span class="line">    public AppCompatDelegate getDelegate() &#123;</span><br><span class="line">        if (mDelegate == null) &#123;</span><br><span class="line">            mDelegate = AppCompatDelegate.create(this, this);</span><br><span class="line">        &#125;</span><br><span class="line">        return mDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">     todo 这里就是本身了 PhoneWindow  Window的唯一的子类</span><br><span class="line">       public static AppCompatDelegate create(Activity activity, AppCompatCallback callback) &#123;</span><br><span class="line">        return create(activity, activity.getWindow(), callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">       private static AppCompatDelegate create(Context context, Window window,</span><br><span class="line">            AppCompatCallback callback) &#123;</span><br><span class="line">        if (Build.VERSION.SDK_INT &gt;= 24) &#123;</span><br><span class="line">            return new AppCompatDelegateImplN(context, window, callback);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 23) &#123;</span><br><span class="line">            return new AppCompatDelegateImplV23(context, window, callback);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 14) &#123;</span><br><span class="line">            return new AppCompatDelegateImplV14(context, window, callback);</span><br><span class="line">        &#125; else if (Build.VERSION.SDK_INT &gt;= 11) &#123;</span><br><span class="line">            return new AppCompatDelegateImplV11(context, window, callback);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">        todo V9 基类的第二层 就在这里</span><br><span class="line">            return new AppCompatDelegateImplV9(context, window, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">         */</span><br><span class="line">        // TODO: 2018/5/23  这个就是一个PhoneWindow的类</span><br><span class="line">        mWindow.getDecorView();</span><br><span class="line">        //关键的还是inflate这个类</span><br><span class="line">        final LayoutInflater inflater = LayoutInflater.from(mContext);</span><br><span class="line">        ViewGroup subDecor = null;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        if (!mWindowNoTitle) &#123;</span><br><span class="line">            if (mIsFloating) &#123;</span><br><span class="line">                // If we&apos;re floating, inflate the dialog title decor</span><br><span class="line">//                第五步，dialog式的Activity  Window.FEATURE_NO_TITLE</span><br><span class="line">// 设置为false的话，就是不设置，一般都会走到下面的那个循环中，请看第六步</span><br><span class="line">                subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                        R.layout.abc_dialog_title_material, null);</span><br><span class="line"></span><br><span class="line">                // Floating windows can never have an action bar, reset the flags</span><br><span class="line">                mHasActionBar = mOverlayActionBar = false;</span><br><span class="line">            &#125; else if (mHasActionBar) &#123;</span><br><span class="line">                /**</span><br><span class="line">                 * This needs some explanation. As we can not use the android:theme attribute</span><br><span class="line">                 * pre-L, we emulate it by manually creating a LayoutInflater using a</span><br><span class="line">                 * ContextThemeWrapper pointing to actionBarTheme.</span><br><span class="line">                 */</span><br><span class="line">                //第六步：这需要一些解释。因为我们不能使用Android：主题属性pre-L，我手动的创建一个布局</span><br><span class="line">                // 填充器使用theme指向actionBar的主题，同时也找到了subDecor  ---》</span><br><span class="line">                // 现在使用主题上下文膨胀视图并将其设置为内容视图。</span><br><span class="line">                TypedValue outValue = new TypedValue();</span><br><span class="line">                mContext.getTheme().resolveAttribute(R.attr.actionBarTheme, outValue, true);</span><br><span class="line"></span><br><span class="line">                Context themedContext;</span><br><span class="line">                if (outValue.resourceId != 0) &#123;</span><br><span class="line">                    themedContext = new ContextThemeWrapper(mContext, outValue.resourceId);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    themedContext = mContext;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // Now inflate the view using the themed context and set it as the content view</span><br><span class="line">                subDecor = (ViewGroup) LayoutInflater.from(themedContext)</span><br><span class="line">                        .inflate(R.layout.abc_screen_toolbar, null);</span><br><span class="line"></span><br><span class="line">                mDecorContentParent = (DecorContentParent) subDecor</span><br><span class="line">                        .findViewById(R.id.decor_content_parent);</span><br><span class="line">                mDecorContentParent.setWindowCallback(getWindowCallback());</span><br><span class="line"></span><br><span class="line">                /**</span><br><span class="line">                 * Propagate features to DecorContentParent</span><br><span class="line">                 */</span><br><span class="line">                if (mOverlayActionBar) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(FEATURE_SUPPORT_ACTION_BAR_OVERLAY);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mFeatureProgress) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(Window.FEATURE_PROGRESS);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mFeatureIndeterminateProgress) &#123;</span><br><span class="line">                    mDecorContentParent.initFeature(Window.FEATURE_INDETERMINATE_PROGRESS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //第七步：如果设置了Window.FEATURE_NO_TITLE---》mWindowNoTitle==true</span><br><span class="line">            // 走到这个循环中，也是会设置初始化这个subDecor</span><br><span class="line">            if (mOverlayActionMode) &#123;</span><br><span class="line">                subDecor = (ViewGroup) inflater.inflate(</span><br><span class="line">                        R.layout.abc_screen_simple_overlay_action_mode, null);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                subDecor = (ViewGroup) inflater.inflate(R.layout.abc_screen_simple, null);</span><br><span class="line">            &#125;</span><br><span class="line">           //第八步对高版本适配：ViewCompat.setOnApplyWindowInsetsListener()</span><br><span class="line">            // 原来就是为了实现 Android 5.0 以上的插图效果的。</span><br><span class="line">            if (Build.VERSION.SDK_INT &gt;= 21) &#123;</span><br><span class="line">                // If we&apos;re running on L or above, we can rely on ViewCompat&apos;s</span><br><span class="line">                // setOnApplyWindowInsetsListener</span><br><span class="line"></span><br><span class="line">                /*</span><br><span class="line">Android 7.024N平台亮点</span><br><span class="line">Android 6.023M平台亮点</span><br><span class="line">Android 5.122LOLLIPOP_MR1平台亮点</span><br><span class="line">Android 5.021LOLLIPOP</span><br><span class="line">Android 4.4W20KITKAT_WATCH仅限 KitKat for Wearables</span><br><span class="line">Android 4.419KITKAT平台亮点</span><br><span class="line">Android 4.318JELLY_BEAN_MR2平台亮点</span><br><span class="line">Android 4.2、4.2.217JELLY_BEAN_MR1平台亮点</span><br><span class="line">                 */</span><br><span class="line">                ViewCompat.setOnApplyWindowInsetsListener(subDecor,</span><br><span class="line">                        new OnApplyWindowInsetsListener() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public WindowInsetsCompat onApplyWindowInsets(View v,</span><br><span class="line">                                    WindowInsetsCompat insets) &#123;</span><br><span class="line">                                final int top = insets.getSystemWindowInsetTop();</span><br><span class="line">                                final int newTop = updateStatusGuard(top);</span><br><span class="line"></span><br><span class="line">                                if (top != newTop) &#123;</span><br><span class="line">                                    insets = insets.replaceSystemWindowInsets(</span><br><span class="line">                                            insets.getSystemWindowInsetLeft(),</span><br><span class="line">                                            newTop,</span><br><span class="line">                                            insets.getSystemWindowInsetRight(),</span><br><span class="line">                                            insets.getSystemWindowInsetBottom());</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                // Now apply the insets on our view</span><br><span class="line">                                return ViewCompat.onApplyWindowInsets(v, insets);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // Else, we need to use our own FitWindowsViewGroup handling</span><br><span class="line">                ((FitWindowsViewGroup) subDecor).setOnFitSystemWindowsListener(</span><br><span class="line">                        new FitWindowsViewGroup.OnFitSystemWindowsListener() &#123;</span><br><span class="line">                            @Override</span><br><span class="line">                            public void onFitSystemWindows(Rect insets) &#123;</span><br><span class="line">                                insets.top = updateStatusGuard(insets.top);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (subDecor == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">                    &quot;AppCompat does not support the current theme features: &#123; &quot;</span><br><span class="line">                            + &quot;windowActionBar: &quot; + mHasActionBar</span><br><span class="line">                            + &quot;, windowActionBarOverlay: &quot;+ mOverlayActionBar</span><br><span class="line">                            + &quot;, android:windowIsFloating: &quot; + mIsFloating</span><br><span class="line">                            + &quot;, windowActionModeOverlay: &quot; + mOverlayActionMode</span><br><span class="line">                            + &quot;, windowNoTitle: &quot; + mWindowNoTitle</span><br><span class="line">                            + &quot; &#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mDecorContentParent == null) &#123;</span><br><span class="line">            mTitleView = (TextView) subDecor.findViewById(R.id.title);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make the decor optionally fit system windows, like the window&apos;s decor</span><br><span class="line">        ViewUtils.makeOptionalFitsSystemWindows(subDecor);</span><br><span class="line"></span><br><span class="line">        final ContentFrameLayout contentView = (ContentFrameLayout) subDecor.findViewById(</span><br><span class="line">                R.id.action_bar_activity_content);</span><br><span class="line"></span><br><span class="line">        final ViewGroup windowContentView = (ViewGroup) mWindow.findViewById(android.R.id.content);</span><br><span class="line">        if (windowContentView != null) &#123;</span><br><span class="line">            // There might be Views already added to the Window&apos;s content view so we need to</span><br><span class="line">            // migrate them to our content view</span><br><span class="line">            while (windowContentView.getChildCount() &gt; 0) &#123;</span><br><span class="line">                final View child = windowContentView.getChildAt(0);</span><br><span class="line">                windowContentView.removeViewAt(0);</span><br><span class="line">                contentView.addView(child);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Change our content FrameLayout to use the android.R.id.content id.</span><br><span class="line">            // Useful for fragments.</span><br><span class="line">            windowContentView.setId(View.NO_ID);</span><br><span class="line">            contentView.setId(android.R.id.content);</span><br><span class="line"></span><br><span class="line">            // The decorContent may have a foreground drawable set (windowContentOverlay).</span><br><span class="line">            // Remove this as we handle it ourselves</span><br><span class="line">            if (windowContentView instanceof FrameLayout) &#123;</span><br><span class="line">                ((FrameLayout) windowContentView).setForeground(null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Now set the Window&apos;s content view with the decor</span><br><span class="line">        mWindow.setContentView(subDecor);</span><br><span class="line"></span><br><span class="line">        contentView.setAttachListener(new ContentFrameLayout.OnAttachListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onAttachedFromWindow() &#123;&#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onDetachedFromWindow() &#123;</span><br><span class="line">                dismissPopups();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        return subDecor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>最后做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-3f154f2c0c8949eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity.setContentView源码解析.jpg"></li><li><p>说明几点</p><ul><li>1、关键方法：<code>mWindow.getDecorView();</code>的解释，第一步得到DecorView，同时把DecorView根据系统的属性，就是App设置的属性，同时也设置了DecorView.addView(view) ,这里面的view，有很多种，有dialog，<code>com.android.internal.R.layout.screen_title</code>  <code>com.android.internal.R.layout.screen_simple</code>  这些系统的根布局，特点基本上是一个LinearLayout 方向为垂直方法的布局。总结就是得到一个DecorView，并且里面addView（view）了。</li><li><p>2、关键方法<code>mWindow.setContentView(subDecor);</code> PhoneWindow的类里面的<code>setContentView</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void setContentView(int layoutResID) &#123;</span><br><span class="line">       //通过前面我们的分析PhoneWindow.getDecorView()的方法会提前在AppCompatDelegateImplV9.createSubDecor()方法中调用，所以这里mContentParent 不会为null</span><br><span class="line">       if (mContentParent == null) &#123;</span><br><span class="line">           installDecor();</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           //会走到这里来</span><br><span class="line">           mContentParent.removeAllViews();</span><br><span class="line">       &#125;</span><br><span class="line">       // TODO: 2018/5/29  关键方法，一定走到这里来了，后续分析inflate的源码</span><br><span class="line">       mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">       final Callback cb = getCallback();</span><br><span class="line">       if (cb != null) &#123;</span><br><span class="line">           cb.onContentChanged();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>3、Activity.setContentView(resId)底层走的方法是  <code>LayoutInflater.from(mContext).inflate(resId, contentParent);</code>这个方法调用了三次，</p><ul><li>第一次调用的时候是在<code>PhoneWindon</code>的<code>generateLayout(DecorView decor)</code>方法，通过<code>getDecorView()</code>这个方法调用的，目的是把，安卓底层提供的布局和decorView相结合<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  View in = mLayoutInflater.inflate(layoutResource, null);</span><br><span class="line">decor.addView(in, new ViewGroup.LayoutParams(FILL_PARENT, FILL_PARENT));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第二次调用的时候<code>mWindow.setContentView(subDecor);</code>也在PhoneWindon中，具体代码可以看总结的第二点，主要是subDecor的来源,随便找了一个来源的地方，可以看到是v7包下的<code>FitWindowsFragmeLayout</code>,这就解释了，为什么我们没有使用到这个布局，但是打断点可以断进来的原因，如果有心情的小伙伴可以对一个ViewGroup的 <code>onMeasure</code>方法进行断点，可以发现好多有趣的事情，如果断点的得当的话，你可以明白<code>api26：执行2次onMeasure、1次onLayout、1次onDraw</code> ,后续会写篇文章来详细介绍下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.v7.widget.FitWindowsFrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/action_bar_root&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt;</span><br><span class="line">&lt;include layout=&quot;@layout/abc_screen_content_include&quot;/&gt;</span><br><span class="line">&lt;android.support.v7.widget.ViewStubCompat android:id=&quot;@+id/action_mode_bar_stub&quot; android:inflatedId=&quot;@+id/action_mode_bar&quot; android:layout=&quot;@layout/abc_action_mode_bar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt;</span><br><span class="line">&lt;/android.support.v7.widget.FitWindowsFrameLayout&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>第三次调用，就是通过<code>AppCompatDelegateImplV9.setContentView</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void setContentView(int resId) &#123;</span><br><span class="line">     ensureSubDecor();</span><br><span class="line">     ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);</span><br><span class="line">     contentParent.removeAllViews();</span><br><span class="line">     // TODO: 2018/5/23 关键的方法</span><br><span class="line">     LayoutInflater.from(mContext).inflate(resId, contentParent);</span><br><span class="line">     mOriginalWindowCallback.onContentChanged();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><p>4、Activity.setContentView(view)底层就走了两次<code>LayoutInflater.from(mContext).inflate()</code>,因为这个方法内部没有调用，代码如下,更不没有调用，这个非常有意思，</p><pre><code>@Overridepublic void setContentView(View v) {    ensureSubDecor();    ViewGroup contentParent = (ViewGroup) mSubDecor.findViewById(android.R.id.content);    contentParent.removeAllViews();    contentParent.addView(v);    mOriginalWindowCallback.onContentChanged();}</code></pre></li><li><p>5、说明Activity根布局是PhoneWindow的DecorView，DecorView继承FrameLayout，只不过通过开发者设置的一些属性，通过DecorView.addView(resId)方法，加载到DecorView中是LinearLayout布局，同时是垂直方向，<code>网上说Activity的根布局是LinearLayout的全都是瞎扯</code>（哈哈，也有可能版本不一样，我这是基于安卓8.0）</p></li><li>随便copy了一张图加以说明，可以看到，根布局是FrameLayout！<br><img src="https://upload-images.jianshu.io/upload_images/5363507-9df8b669f6fc9174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li><li>6、关于PhoneWindow  Window的唯一子类，个人建议一定要去看下源码，在安卓事件传递，如何从Activity传递到ViewGroup的，也和这个类有关，具体可看这篇文章<a href="https://www.jianshu.com/p/f7e3a14daf51" target="_blank" rel="noopener">Android源码分析(事件传递)</a></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android源码 </tag>
            
            <tag> setContentView源码解析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析（Handler机制）</title>
      <link href="/2018/05/26/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Handler%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
      <url>/2018/05/26/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88Handler%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2><h4 id="关键类ActivityThread、Handler、Looper、Message、MessageQueue"><a href="#关键类ActivityThread、Handler、Looper、Message、MessageQueue" class="headerlink" title="关键类ActivityThread、Handler、Looper、Message、MessageQueue"></a>关键类ActivityThread、Handler、Looper、Message、MessageQueue</h4><ul><li>ActivityThread中的流程：应用程序入口是在ActivityThread的main方法中，程序启动，底层去调用C/C++去调用main方法<a id="more"></a></li><li><p>ActivityThread中的main的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> /*</span><br><span class="line">将当前线程初始化为一个活套，将其标记为</span><br><span class="line">*应用程序的主要活套。应用程序的主要套接字</span><br><span class="line">*是由Android环境创建的，所以您永远不需要</span><br><span class="line">*自己调用这个函数</span><br><span class="line"> */</span><br><span class="line"> public static void main(String[] args) &#123;</span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line">        ActivityThread thread = new ActivityThread();</span><br><span class="line">        thread.attach(false);</span><br><span class="line">        if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125;</span><br><span class="line">        //if(false)&#123;&#125;之类的语句，这种写法是方便调试的，通过一个标志就可以控制某些代码是否执行，比如说是否输出一些系统的Log</span><br><span class="line">        if (false) &#123; myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); &#125;</span><br><span class="line">        Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Looper.prepareMainLooper();方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">////Looper的prepare方法，并且关联到主线程</span><br><span class="line">public static void prepareMainLooper() &#123;</span><br><span class="line">    //Only one Looper may be created per thread&quot;</span><br><span class="line">    // false意思不允许我们程序员退出（面向我们开发者），因为这是在主线程里面</span><br><span class="line">    // TODO: 2018/5/17   </span><br><span class="line">    prepare(false);</span><br><span class="line">    synchronized (Looper.class) &#123;</span><br><span class="line">        if (sMainLooper != null) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        //把Looper设置为主线程的Looper</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于prepare（false）方法： Only one Looper may be created per thread 也就是说，一个线程只有一个Looper对象，要不然会抛出异常</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>关于ThreadLocal的set方法，可以找到ThreadLocal的构造函数，底层的实现是一个Entry的数组.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;();</span><br><span class="line">//1、ThreadLocal的set方法</span><br><span class="line"> public void set(T value) &#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       if (map != null)</span><br><span class="line">           map.set(this, value);</span><br><span class="line">       else</span><br><span class="line">           createMap(t, value);</span><br><span class="line">   &#125;</span><br><span class="line">//2、ThreadLocal的createMap方法</span><br><span class="line"> void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">       t.threadLocals = new ThreadLocalMap(this, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>ThreadLocalMap的构造函数里面有一个长度为16的Entry的数组，当然这个机制和HashMap差不多，也有扩容机制,就是当容器装不下了，在此的基础上增加一倍的长度，同时把原来的数据copy到新的Entry数组中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//3、ThreadLocal的构造函数</span><br><span class="line">    ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">           table = new Entry[INITIAL_CAPACITY];</span><br><span class="line">           int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</span><br><span class="line">           table[i] = new Entry(firstKey, firstValue);</span><br><span class="line">           size = 1;</span><br><span class="line">           setThreshold(INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>ThreadLocalMap的（扩容机制）Double the capacity of the table.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * Double the capacity of the table.</span><br><span class="line">   */</span><br><span class="line">  private void resize() &#123;</span><br><span class="line">      Entry[] oldTab = table;</span><br><span class="line">      int oldLen = oldTab.length;</span><br><span class="line">      int newLen = oldLen * 2;</span><br><span class="line">      Entry[] newTab = new Entry[newLen];</span><br><span class="line">      int count = 0;</span><br><span class="line"></span><br><span class="line">      for (int j = 0; j &lt; oldLen; ++j) &#123;</span><br><span class="line">          Entry e = oldTab[j];</span><br><span class="line">          if (e != null) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">              if (k == null) &#123;</span><br><span class="line">                  e.value = null; // Help the GC</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  int h = k.threadLocalHashCode &amp; (newLen - 1);</span><br><span class="line">                  while (newTab[h] != null)</span><br><span class="line">                      h = nextIndex(h, newLen);</span><br><span class="line">                  newTab[h] = e;</span><br><span class="line">                  count++;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      setThreshold(newLen);</span><br><span class="line">      size = count;</span><br><span class="line">      table = newTab;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><ul><li>同时关注Entry的类，可以发现这是WeakReference的子类，关系到了弱引用：弱引用是比软引用更弱的一种的引用的类型，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不敢当前空间是否不足，都会对弱引用对象进行回收，不太明白的可以看我另外一篇文章 <a href="https://www.jianshu.com/p/82b76e0cb41e" target="_blank" rel="noopener">安卓代码、图片、布局、网络和电量优化</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">          /** The value associated with this ThreadLocal. */</span><br><span class="line">          Object value;</span><br><span class="line">          Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">              super(k);</span><br><span class="line">              value = v;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="为什么我要提起它？？？可能我理解的不太准确，肯定不太准确，在我现在工作中，维护和开发一个硬件的应用早餐机（用户通过App预定早餐，第二天早上去机器上取早餐），就像蜂巢的快递柜一样，取早餐的机器，在深圳工作的大佬，可能也许看见过我们的机器，PLC、安卓、物联网这篇文章有详细的介绍。在测试过程中，由于App常驻在前台，有几率导致App直接挂掉，通过日志发现是内存不足，直接kill了这个App，我想这里可能就是这个原因，这个一个弱应用，只要虚拟机扫描导致这里了，我不管你了，我直接把你回收掉。仅仅是个人的理解，同时我们安卓的开发板也不太稳定，如果在这一点有见解的大佬，欢迎讨论，谢谢了"><a href="#为什么我要提起它？？？可能我理解的不太准确，肯定不太准确，在我现在工作中，维护和开发一个硬件的应用早餐机（用户通过App预定早餐，第二天早上去机器上取早餐），就像蜂巢的快递柜一样，取早餐的机器，在深圳工作的大佬，可能也许看见过我们的机器，PLC、安卓、物联网这篇文章有详细的介绍。在测试过程中，由于App常驻在前台，有几率导致App直接挂掉，通过日志发现是内存不足，直接kill了这个App，我想这里可能就是这个原因，这个一个弱应用，只要虚拟机扫描导致这里了，我不管你了，我直接把你回收掉。仅仅是个人的理解，同时我们安卓的开发板也不太稳定，如果在这一点有见解的大佬，欢迎讨论，谢谢了" class="headerlink" title="为什么我要提起它？？？可能我理解的不太准确，肯定不太准确，在我现在工作中，维护和开发一个硬件的应用早餐机（用户通过App预定早餐，第二天早上去机器上取早餐），就像蜂巢的快递柜一样，取早餐的机器，在深圳工作的大佬，可能也许看见过我们的机器，PLC、安卓、物联网这篇文章有详细的介绍。在测试过程中，由于App常驻在前台，有几率导致App直接挂掉，通过日志发现是内存不足，直接kill了这个App，我想这里可能就是这个原因，这个一个弱应用，只要虚拟机扫描导致这里了，我不管你了，我直接把你回收掉。仅仅是个人的理解，同时我们安卓的开发板也不太稳定，如果在这一点有见解的大佬，欢迎讨论，谢谢了"></a>为什么我要提起它？？？可能我理解的不太准确，肯定不太准确，在我现在工作中，维护和开发一个硬件的应用早餐机（用户通过App预定早餐，第二天早上去机器上取早餐），就像蜂巢的快递柜一样，取早餐的机器，在深圳工作的大佬，可能也许看见过我们的机器，<a href="https://www.jianshu.com/p/82b88ac8e329" target="_blank" rel="noopener">PLC、安卓、物联网</a>这篇文章有详细的介绍。在测试过程中，由于App常驻在前台，有几率导致App直接挂掉，通过日志发现是内存不足，直接kill了这个App，我想这里可能就是这个原因，这个一个弱应用，只要虚拟机扫描导致这里了，我不管你了，我直接把你回收掉。仅仅是个人的理解，同时我们安卓的开发板也不太稳定，如果在这一点有见解的大佬，欢迎讨论，谢谢了</h2><ul><li><p>Looper.loop();根据我们的常识知道，如果程序没有死循环的话，执行完main函数（比如构建视图等等代码）以后就会立马退出了。之所以我们的APP能够一直运行着，就是因为Looper.loop()里面是一个死循环</p><ul><li>1、 首先拿到Looper对象（me），如果当前的线程没有Looper，那么就会抛出异常， // TODO: 2018/5/17   在子线程中创建handler的话，需要looper也要准备好 ，要不然会报错。这就是为什么在子线程里面创建Handler如果不手动创建和启动Looper会报错的原因<ul><li>这个Looper对象就是通过sThreadLocal.get();细心的话可以发现前面已经sThreadLocal.set()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static @Nullable Looper myLooper() &#123;</span><br><span class="line">     return sThreadLocal.get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>2、然后拿到Looper的成员变量MessageQueue，在MessageQueue里面不断地去取消息，关于MessageQueue的next方法如下：如果这个msg为null的，这个结束掉这个</li><li>3、msg.target.dispatchMessage(msg)就是处理消息，紧接着在loop方法的最后调用了msg.recycleUnchecked()这就是回收了Message。</li><li>4、我们平时写Handler的时候不需要我们手动回收，因为谷歌的工程师已经有考虑到这方面的问题了。消息是在Handler分发处理之后就会被自动回收的：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">    final Looper me = myLooper();</span><br><span class="line">    if (me == null) &#123;</span><br><span class="line">        // TODO: 2018/5/17   在子线程中创建handler的话，需要looper也要准备好 ，要不然会报错</span><br><span class="line">        // 1、 首先拿到Looper对象（me），如果当前的线程没有Looper，那么就会抛出异常，</span><br><span class="line">        // 这就是为什么在子线程里面创建Handler如果不手动创建和启动Looper会报错的原因</span><br><span class="line">        throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    final MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">    // Make sure the identity of this thread is that of the local process,</span><br><span class="line">    // and keep track of what that identity token actually is.</span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    final long ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    for (; ; ) &#123;</span><br><span class="line">        // TODO: 2018/5/17   Message</span><br><span class="line">       // 2、然后拿到Looper的成员变量MessageQueue，在MessageQueue里面不断地去取消息，关于MessageQueue的next方法如下：</span><br><span class="line">        Message msg = queue.next(); // might block</span><br><span class="line">        if (msg == null) &#123;</span><br><span class="line">            // No message indicates that the message queue is quitting.</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // This must be in a local variable, in case a UI event sets the logger</span><br><span class="line">        final Printer logging = me.mLogging;</span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; +</span><br><span class="line">                    msg.callback + &quot;: &quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line"></span><br><span class="line">        final long traceTag = me.mTraceTag;</span><br><span class="line">        if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        final long start = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        final long end;</span><br><span class="line">      //  msg.target.dispatchMessage(msg)就是处理消息，紧接着在loop方法的最后调用了msg.recycleUnchecked()这就是回收了Message。</span><br><span class="line">        // TODO: 2018/5/17</span><br><span class="line">        处理消息</span><br><span class="line">        try &#123;</span><br><span class="line">            处理消息</span><br><span class="line">            // TODO: 2018/5/17  msg中的target 就是handler的本体的对象  ，直接去handler中发送这个对象</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">            end = (slowDispatchThresholdMs == 0) ? 0 : SystemClock.uptimeMillis();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (traceTag != 0) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slowDispatchThresholdMs &gt; 0) &#123;</span><br><span class="line">            final long time = end - start;</span><br><span class="line">            if (time &gt; slowDispatchThresholdMs) &#123;</span><br><span class="line">                Slog.w(TAG, &quot;Dispatch took &quot; + time + &quot;ms on &quot;</span><br><span class="line">                        + Thread.currentThread().getName() + &quot;, h=&quot; +</span><br><span class="line">                        msg.target + &quot; cb=&quot; + msg.callback + &quot; msg=&quot; + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (logging != null) &#123;</span><br><span class="line">            logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Make sure that during the course of dispatching the</span><br><span class="line">        // identity of the thread wasn&apos;t corrupted.</span><br><span class="line">        final long newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        if (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, &quot;Thread identity changed from 0x&quot;</span><br><span class="line">                    + Long.toHexString(ident) + &quot; to 0x&quot;</span><br><span class="line">                    + Long.toHexString(newIdent) + &quot; while dispatching to &quot;</span><br><span class="line">                    + msg.target.getClass().getName() + &quot; &quot;</span><br><span class="line">                    + msg.callback + &quot; what=&quot; + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line">        // TODO: 2018/5/17</span><br><span class="line">        我们平时写Handler的时候不需要我们手动回收，因为谷歌的工程师已经有考虑到这方面的问题了。消息是在Handler分发处理之后就会被自动回收的：</span><br><span class="line">        msg.recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于Message类<br>1、对象是实现了Parcelable接口的，因为Message消息可能需要跨进程通信，这时候就需要进程序列化以及反序列化操作了。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class Message implements Parcelable Message</span><br></pre></td></tr></table></figure></li></ul><p>2、obtain()得到Message对象，其中的设计模式享元模式：我见过最好的Demo,理解：采用一个共享类避免大量拥有相同的内容的“小类的开销”<br>享元模式德优缺点：优点在于大幅度的降低内存中对象的数量，但是，它做到这一点代价优点高，享元模式使得系统更加复杂为了使对象可以共享，需要将一些状态外部化，这使得一些程序逻辑更加的复杂享元模式将享元对象的状态外部化，而读取外部状态使得运行的时间稍微变长，更多的Demo可以看这篇文章<a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public static Message obtain() &#123;</span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPool != null) &#123;</span><br><span class="line">               Message m = sPool;</span><br><span class="line">               sPool = m.next;</span><br><span class="line">               m.next = null;</span><br><span class="line">               m.flags = 0; // clear in-use flag</span><br><span class="line">               sPoolSize--;</span><br><span class="line">               return m;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return new Message();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>3、消息的回收机制方法一:这个方法调用的时机是在MessageQueueen中。MessageQueueen.queueMessage(Message msg, long when)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public void recycle() &#123;</span><br><span class="line">    if (isInUse()) &#123;</span><br><span class="line">        if (gCheckRecycle) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;This message cannot be recycled because it &quot;</span><br><span class="line">                    + &quot;is still in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、消息的回收机制方法二:调用的地方是在  Looper.loop();谷歌的工程师帮我们调用，所以我们在开发过程中，没有去调用这个消息回收，哈哈，向谷歌致敬，同时这个方法也会在recycle中调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">void recycleUnchecked() &#123;</span><br><span class="line">       // Mark the message as in use while it remains in the recycled object pool.</span><br><span class="line">       // Clear out all other details.</span><br><span class="line">       flags = FLAG_IN_USE;</span><br><span class="line">       what = 0;</span><br><span class="line">       arg1 = 0;</span><br><span class="line">       arg2 = 0;</span><br><span class="line">       obj = null;</span><br><span class="line">       replyTo = null;</span><br><span class="line">       sendingUid = -1;</span><br><span class="line">       when = 0;</span><br><span class="line">       target = null;</span><br><span class="line">       callback = null;</span><br><span class="line">       data = null;</span><br><span class="line"></span><br><span class="line">       synchronized (sPoolSync) &#123;</span><br><span class="line">           if (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">               next = sPool;</span><br><span class="line">               sPool = this;</span><br><span class="line">               sPoolSize++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li>关于MessageQueue类<br>1、 Message next() 方法:看到消息的取出用到了一些native方法，这样做是为了获得更高的效率，消息的去取出并不是直接就从队列的头部取出的，而是根据了消息的when时间参数有关的，因为我们可以发送延时消息、也可以发送一个指定时间点的消息<ul><li>1、for循环的使用native 方法</li><li>2、根据时间戳获取消息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">Message next() &#123;</span><br><span class="line">      final long ptr = mPtr;</span><br><span class="line">      if (ptr == 0) &#123;</span><br><span class="line">          return null;</span><br><span class="line">      &#125;</span><br><span class="line">      int pendingIdleHandlerCount = -1; // -1 only during first iteration</span><br><span class="line">      int nextPollTimeoutMillis = 0;</span><br><span class="line">      //防止被反射修改了这个标记，直接写出for循环</span><br><span class="line">      for (;;) &#123;</span><br><span class="line">          if (nextPollTimeoutMillis != 0) &#123;</span><br><span class="line">              Binder.flushPendingCommands();</span><br><span class="line">          &#125;</span><br><span class="line">          //native 方法</span><br><span class="line">          nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">          synchronized (this) &#123;</span><br><span class="line">              // Try to retrieve the next message.  Return if found.</span><br><span class="line">              //拿到当前的时间戳</span><br><span class="line">              final long now = SystemClock.uptimeMillis();</span><br><span class="line">              Message prevMsg = null;</span><br><span class="line">              Message msg = mMessages;</span><br><span class="line">              //判断头指针的Target（Handler是否为空（因为头指针只是一个指针的作用））</span><br><span class="line">              if (msg != null &amp;&amp; msg.target == null) &#123;</span><br><span class="line">                  // Stalled by a barrier.  Find the next asynchronous message in the queue.</span><br><span class="line">                  do &#123;</span><br><span class="line">                      //遍历下一条Message</span><br><span class="line">                      prevMsg = msg;</span><br><span class="line">                      msg = msg.next;</span><br><span class="line">                  &#125; while (msg != null &amp;&amp; !msg.isAsynchronous());</span><br><span class="line">              &#125;</span><br><span class="line">              if (msg != null) &#123;</span><br><span class="line">                  if (now &lt; msg.when) &#123;</span><br><span class="line">                      //还没有到执行的时间</span><br><span class="line">                      nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      //到了执行时间，直接返回</span><br><span class="line">                      mBlocked = false;</span><br><span class="line">                      if (prevMsg != null) &#123;</span><br><span class="line">                          //拿出消息，断开链表</span><br><span class="line">                          prevMsg.next = msg.next;</span><br><span class="line">                      &#125; else &#123;</span><br><span class="line">                          mMessages = msg.next;</span><br><span class="line">                      &#125;</span><br><span class="line">                      msg.next = null;</span><br><span class="line">                      if (DEBUG) Log.v(TAG, &quot;Returning message: &quot; + msg);</span><br><span class="line">                      msg.markInUse();</span><br><span class="line">                      return msg;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  // No more messages.</span><br><span class="line">                  nextPollTimeoutMillis = -1;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // Process the quit message now that all pending messages have been handled.</span><br><span class="line">              if (mQuitting) &#123;</span><br><span class="line">                  dispose();</span><br><span class="line">                  return null;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              // If first time idle, then get the number of idlers to run.</span><br><span class="line">              // Idle handles only run if the queue is empty or if the first message</span><br><span class="line">              // in the queue (possibly a barrier) is due to be handled in the future.</span><br><span class="line">              if (pendingIdleHandlerCount &lt; 0</span><br><span class="line">                      &amp;&amp; (mMessages == null || now &lt; mMessages.when)) &#123;</span><br><span class="line">                  pendingIdleHandlerCount = mIdleHandlers.size();</span><br><span class="line">              &#125;</span><br><span class="line">              if (pendingIdleHandlerCount &lt;= 0) &#123;</span><br><span class="line">                  // No idle handlers to run.  Loop and wait some more.</span><br><span class="line">                  mBlocked = true;</span><br><span class="line">                  continue;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (mPendingIdleHandlers == null) &#123;</span><br><span class="line">                  mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];</span><br><span class="line">              &#125;</span><br><span class="line">              mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Run the idle handlers.</span><br><span class="line">          // We only ever reach this code block during the first iteration.</span><br><span class="line">          for (int i = 0; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">              final IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">              mPendingIdleHandlers[i] = null; // release the reference to the handler</span><br><span class="line"></span><br><span class="line">              boolean keep = false;</span><br><span class="line">              try &#123;</span><br><span class="line">                  keep = idler.queueIdle();</span><br><span class="line">              &#125; catch (Throwable t) &#123;</span><br><span class="line">                  Log.wtf(TAG, &quot;IdleHandler threw exception&quot;, t);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              if (!keep) &#123;</span><br><span class="line">                  synchronized (this) &#123;</span><br><span class="line">                      mIdleHandlers.remove(idler);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Reset the idle handler count to 0 so we do not run them again.</span><br><span class="line">          pendingIdleHandlerCount = 0;</span><br><span class="line"></span><br><span class="line">          // While calling an idle handler, a new message could have been delivered</span><br><span class="line">          // so go back and look again for a pending message without waiting.</span><br><span class="line">          nextPollTimeoutMillis = 0;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>2、 boolean enqueueMessage(Message msg, long when)方法中调用了  msg.recycle();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">        if (msg.target == null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.isInUse()) &#123;</span><br><span class="line">            throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (mQuitting) &#123;</span><br><span class="line">                IllegalStateException e = new IllegalStateException(</span><br><span class="line">                        msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">                Log.w(TAG, e.getMessage(), e);</span><br><span class="line">                // TODO: 2018/5/21  在这里调用的 释放消息</span><br><span class="line">                msg.recycle();</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、quit的方法: Looper.myLooper().quit();调用的就是下面的方法 只不过safe==false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void quit(boolean safe) &#123;</span><br><span class="line">       if (!mQuitAllowed) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;Main thread not allowed to quit.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           if (mQuitting) &#123;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           //置位正在退出的标志</span><br><span class="line">           mQuitting = true;</span><br><span class="line">          //清空所有消息</span><br><span class="line">           if (safe) &#123;</span><br><span class="line">               //安全的（系统的），未来未处理的消息都移除</span><br><span class="line">               removeAllFutureMessagesLocked();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //如果是不安全的，例如我们自己定义的消息，就一次性全部移除掉</span><br><span class="line">               removeAllMessagesLocked();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We can assume mPtr != 0 because mQuitting was previously false.</span><br><span class="line">           nativeWake(mPtr);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>安全的（系统的），未来未处理的消息都移除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllFutureMessagesLocked() &#123;</span><br><span class="line">       final long now = SystemClock.uptimeMillis();</span><br><span class="line">       Message p = mMessages;</span><br><span class="line">       if (p != null) &#123;</span><br><span class="line">           if (p.when &gt; now) &#123;</span><br><span class="line">               //如果所有消息都处理完了，就一次性把全部消息移除掉</span><br><span class="line">               removeAllMessagesLocked();</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //否则就通过for循环拿到还没有把还没有执行的Message，利用do循环</span><br><span class="line">               //把这些未处理的消息通过recycleUnchecked方法回收，放回到消息池里面</span><br><span class="line">               Message n;</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   n = p.next;</span><br><span class="line">                   if (n == null) &#123;</span><br><span class="line">                       return;</span><br><span class="line">                   &#125;</span><br><span class="line">                   if (n.when &gt; now) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   p = n;</span><br><span class="line">               &#125;</span><br><span class="line">               p.next = null;</span><br><span class="line">               do &#123;</span><br><span class="line">                   p = n;</span><br><span class="line">                   n = p.next;</span><br><span class="line">                   p.recycleUnchecked();</span><br><span class="line">               &#125; while (n != null);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果是不安全的，例如我们自己定义的消息，就一次性全部移除掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void removeAllMessagesLocked() &#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    while (p != null) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked();</span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关于Handler发送消息流程</p></li><li><p>通过一个Handler发送一个延迟5s的消息，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">innerHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              //todo</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,5000);</span><br></pre></td></tr></table></figure></li><li><p>调用到Handler中的postDelayed方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public final boolean postDelayed(Runnable r, long delayMillis) &#123;</span><br><span class="line">    return sendMessageDelayed(getPostMessage(r), delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getPostMessage(r)方法:通过obtain得到一个Message的对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static Message getPostMessage(Runnable r) &#123;</span><br><span class="line">     Message m = Message.obtain();</span><br><span class="line">     m.callback = r;</span><br><span class="line">     return m;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>sendMessageDelayed(getPostMessage(r), delayMillis):这里的delayMillis的时间小于0的话，也会为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final boolean sendMessageDelayed(Message msg, long delayMillis)</span><br><span class="line">  &#123;</span><br><span class="line">      if (delayMillis &lt; 0) &#123;</span><br><span class="line">          delayMillis = 0;</span><br><span class="line">      &#125;</span><br><span class="line">      return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis)；SystemClock.uptimeMillis() 系统的时间返回为milliseconds==毫秒，在这个方法就可以看出，MessageQueue不可获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean sendMessageAtTime(Message msg, long uptimeMillis) &#123;</span><br><span class="line">      MessageQueue queue = mQueue;</span><br><span class="line">      if (queue == null) &#123;</span><br><span class="line">          RuntimeException e = new RuntimeException(</span><br><span class="line">                  this + &quot; sendMessageAtTime() called with no mQueue&quot;);</span><br><span class="line">          Log.w(&quot;Looper&quot;, e.getMessage(), e);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">      return enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>那么关于mQueue何时初始化的呢，请看代码分析<br>1、我们平时都是new Handler（），开始使用的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Handler() &#123;</span><br><span class="line">    this(null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接调用了这里的方法，同时这个构造方法是Hide了的，在外界调用不掉，为啥把它Handler，我还不太懂，反正可以注意到    mQueue = mLooper.mQueue; 原MessageQueue是在Looper中初始化的，ok，往下走</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public Handler(Callback callback, boolean async) &#123;</span><br><span class="line">     if (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">         final Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">         if ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                 (klass.getModifiers() &amp; Modifier.STATIC) == 0) &#123;</span><br><span class="line">             Log.w(TAG, &quot;The following Handler class should be static or leaks might occur: &quot; +</span><br><span class="line">                 klass.getCanonicalName());</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mLooper = Looper.myLooper();</span><br><span class="line">     if (mLooper == null) &#123;</span><br><span class="line">         throw new RuntimeException(</span><br><span class="line">             &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     mQueue = mLooper.mQueue;</span><br><span class="line">     mCallback = callback;</span><br><span class="line">     mAsynchronous = async;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>Looper的构造方法，可以看到MessageQueue初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">     mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">     mThread = Thread.currentThread();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>那么Looper又在哪里初始化的呢:通过代码可以发现prepare()方法中初始化，通过前面的代码的分析又在ActivityThread中的main方法，通过调用Looper.prepareMainLooper（）方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private static void prepare(boolean quitAllowed) &#123;</span><br><span class="line">     if (sThreadLocal.get() != null) &#123;</span><br><span class="line">         throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     sThreadLocal.set(new Looper(quitAllowed));</span><br></pre></td></tr></table></figure></p><ul><li><p>关于enqueueMessage(queue, msg, uptimeMillis);其实也就是调用到MessageQueue.enqueueMessage方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) &#123;</span><br><span class="line">     msg.target = this;</span><br><span class="line">     if (mAsynchronous) &#123;</span><br><span class="line">         msg.setAsynchronous(true);</span><br><span class="line">     &#125;</span><br><span class="line">     return queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于MessageQueue.enqueueMessage():对msg一些的赋值，同时呢，也调用了，本地方法，这样性能很高，如果真的需要看懂源码的流程，一定打个断点，一步步的走下去，就可以看到很良好的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">boolean enqueueMessage(Message msg, long when) &#123;</span><br><span class="line">       //1、目标为空，那么抛出异常</span><br><span class="line">       if (msg.target == null) &#123;</span><br><span class="line">           throw new IllegalArgumentException(&quot;Message must have a target.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       //2、如果这个消息已经被使用了的话，也抛出异常</span><br><span class="line">       // /*package*/ boolean isInUse() &#123;</span><br><span class="line">       //        return ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">       //    &#125;</span><br><span class="line">       if (msg.isInUse()) &#123;</span><br><span class="line">           throw new IllegalStateException(msg + &quot; This message is already in use.&quot;);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       synchronized (this) &#123;</span><br><span class="line">           //3、如果是退出了，就是App退出了，退出了的标记</span><br><span class="line">           if (mQuitting) &#123;</span><br><span class="line">               IllegalStateException e = new IllegalStateException(</span><br><span class="line">                       msg.target + &quot; sending message to a Handler on a dead thread&quot;);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               // TODO: 2018/5/21  在这里调用的 释放消息</span><br><span class="line">               msg.recycle();</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">           //4、标记它正在使用中，</span><br><span class="line">           msg.markInUse();</span><br><span class="line">           //5、当前的时间</span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           boolean needWake;</span><br><span class="line">           if (p == null || when == 0 || when &lt; p.when) &#123;</span><br><span class="line">               // 6、新的头，如果阻塞，唤醒事件队列。</span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               // Inserted within the middle of the queue.  Usually we don&apos;t have to wake</span><br><span class="line">               // up the event queue unless there is a barrier at the head of the queue</span><br><span class="line">               // and the message is the earliest asynchronous message in the queue.</span><br><span class="line">               //插入队列中间。通常我们不必醒来</span><br><span class="line">               //增加事件队列，除非队列头上有障碍物。</span><br><span class="line">               //消息是队列中最早的异步消息。</span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               //7、for保持消息的不断的移动</span><br><span class="line">               for (;;) &#123;</span><br><span class="line">                   //前一个消息，如果走到这里，那么这个p不会为null</span><br><span class="line">                   prev = p;</span><br><span class="line">                   //把这个消息下一个赋值给P，如果下个值为null的话，就直接break</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   if (p == null || when &lt; p.when) &#123;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">                   //8、需要醒来，同时消息是异步的</span><br><span class="line">                   if (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = false;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p; // invariant: p == prev.next</span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // We can assume mPtr != 0 because mQuitting is false.</span><br><span class="line">           if (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>这样MessageQueue.next() 方法,就不断的取出Message，做相应的动作,</p></li><li>如何分发消息呢？还得看Looper.loop()方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void loop() &#123;</span><br><span class="line">  //前面省略了方法</span><br><span class="line">   for (;;) &#123;</span><br><span class="line">           //这样MessageQueue.next() 方法,就不断的取出Message</span><br><span class="line">           Message msg = queue.next(); // might block</span><br><span class="line">           msg.target.dispatchMessage(msg);</span><br><span class="line">  //省略了方法</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><p>Handle system messages here. 这样就把消息分发下去了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle system messages here.</span><br><span class="line"> */</span><br><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    // TODO: 2018/5/17</span><br><span class="line">    //这个callback呢，即使他妈的一个线程</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //两个都没有的话，就去把这个消息发送到handleMessage中去</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-366abc390f851a73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Handler机制.png"></p><ul><li><p>说明几点 </p><ul><li>1、 安卓的程序的入口的函数是ActivityThread.main()，反正每个App启动都会经过它，具体为啥，我也不清楚</li><li><p>2、首先初始化的是Looper，Looper的构造方法初始化MessageQueue，然后ThreadLocal.set()方法保存，原来是ThreadLocal里面有个ThreadLocalMap容器，底层的原理和HashMap差不多，有个初始长度为16的Entry数组，也有扩容机制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private Looper(boolean quitAllowed) &#123;</span><br><span class="line">        mQueue = new MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>3、由于Entry继承的是一个WeakReference类，那么是弱应用的子类，当内存不足，扫描到这里，就不被回收，导致App被kill，系统回到Launch，（当然这仅仅是我的假设，不正确），安卓系统不会把内置的软件给kill，不如说时间，主题，launch，如果要杀，就只能杀开发者的应用了</li></ul></li><li>4、在ActivityThread.main()后，有个Looper.loop(),可以得出在：子线程中创建handler的话，需要looper也要准备好 ，要不然会报错。这就是为什么在子线程里面创建Handler如果不手动创建和启动Looper会报错的原因<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final Looper me = myLooper();</span><br><span class="line">     if (me == null) &#123;</span><br><span class="line">         // TODO: 2018/5/17   在子线程中创建handler的话，需要looper也要准备好 ，要不然会报错</span><br><span class="line">         // 1、 首先拿到Looper对象（me），如果当前的线程没有Looper，那么就会抛出异常，</span><br><span class="line">         // 这就是为什么在子线程里面创建Handler如果不手动创建和启动Looper会报错的原因</span><br><span class="line">         throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>5、程序能够不断的运行着的原因，是Looper.loop中是一个死循环，当消息队列没有消息了，程序就会退出</p></li><li><p>6、消息的分发msg.target.dispatchMessage(msg); msg.target其实就是Handler对象，可以看到分发消息的最终结果，也可以从这里表明Message的使用有好多种可能。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void dispatchMessage(Message msg) &#123;</span><br><span class="line">    // TODO: 2018/5/17</span><br><span class="line">    //这个callback呢，即使他妈的一个线程</span><br><span class="line">    if (msg.callback != null) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        //两个都没有的话，就去把这个消息发送到handleMessage中去</span><br><span class="line">        if (mCallback != null) &#123;</span><br><span class="line">            if (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>7、Message中，目前是我见过享元模式最好的实现的方式。更多的Demo可以看这篇文章<a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a></p></li><li>8、为啥没有消息回收，因为谷歌工程师，已经帮我们做了。致敬谷歌</li><li>9、MessageQueue.next()，使用的是本地方法，因为效率的问题，需要更高的效率，所以需要本地，原理说实话，我想扯一下，看了好多文档，发现我自己也不明白，反正不是我们常规的队列中取出，而是根据when时间参数有关。</li><li>10、Handler，发送消息的姿势很多（注意是姿势），需要不断的尝试，在集合源码，就可以发现新大陆</li><li><p>11、后续会讲到View的绘制啊 <code>RESUME_ACTIVITY</code>activity获取焦点，底层通过的也是Handler，在ActivityThread 内部类H 继承的是Handler，这里也是View绘制的开始，后续会写一篇文章分析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> private class H extends Handler&#123;</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            case RESUME_ACTIVITY:</span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;);</span><br><span class="line">                    SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">                    handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true,</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>12、退出程序其实就是 <code>mLooper.myLooper().quit();</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case EXIT_APPLICATION:</span><br><span class="line">    if (mInitialApplication != null) &#123;</span><br><span class="line">        mInitialApplication.onTerminate();</span><br><span class="line">    &#125;</span><br><span class="line">    //退出Looper的循环 这里实际上是调用了MessageQueue的quit，清空所有Message。</span><br><span class="line">    mLooper.myLooper().quit();</span><br><span class="line">    break;</span><br></pre></td></tr></table></figure></li><li><p>13、<code>handler</code>正确的使用的姿势，可以看这篇文章<a href="https://www.jianshu.com/p/82b76e0cb41e" target="_blank" rel="noopener">安卓代码、图片、布局、网络和电量优化</a></p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> Handler机制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android源码分析（事件传递）</title>
      <link href="/2018/05/14/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%EF%BC%89/"/>
      <url>/2018/05/14/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2><ul><li>首先如何看安卓SDK源码，作者尝试过几种的方法，感觉这种比较方便<br>把在本地找到的Android.jar 放到工程中的libs的目录下，直接编译，就可以看到PhoneWindow 和DecorView的源码了<br><img src="https://upload-images.jianshu.io/upload_images/5363507-58562a1784cc86ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><a id="more"></a></li><li>结论：Android事件分发流程 = Activity -&gt; ViewGroup -&gt; View<br><img src="https://upload-images.jianshu.io/upload_images/5363507-1a5d392774b949c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件传递.png"><h4 id="Activity事件分发机制"><a href="#Activity事件分发机制" class="headerlink" title="Activity事件分发机制"></a>Activity事件分发机制</h4></li><li>Activity事件分发机制（Activity源码分析）<ul><li>当一个点击事件发生时，事件最先传到<code>Activity</code>的<code>dispatchTouchEvent()</code>进行事件分发<br><img src="https://upload-images.jianshu.io/upload_images/5363507-8e8c3d0127a39ff4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">      //第一点</span><br><span class="line">      if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">          onUserInteraction();</span><br><span class="line">      &#125;</span><br><span class="line">     //第二点</span><br><span class="line">      if (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">          return true;</span><br><span class="line">      &#125;</span><br><span class="line">    //第三点</span><br><span class="line">      return onTouchEvent(ev);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、触发方法  onUserInteraction();这个事件触发的机制是DOWN事件<br><img src="https://upload-images.jianshu.io/upload_images/5363507-5d6a95e44f2b2233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * onUserInteraction()</span><br><span class="line">  * 作用：实现屏保功能</span><br><span class="line">  * 注：</span><br><span class="line">  *    a. 该方法为空方法</span><br><span class="line">  *    b. 当此activity在栈顶时，触屏点击按home，back，menu键等都会触发此方法</span><br><span class="line">  */</span><br><span class="line">      public void onUserInteraction() &#123; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>2、触发方法 getWindow().superDispatchTouchEvent(ev)</p><ul><li>getWindow()：：：mWindow = new PhoneWindow(this);</li></ul></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-bb53a94f2832e1a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>定义：属于顶层View（DecorView）<ul><li>说明：</li><li>a. DecorView类是PhoneWindow类的一个内部类</li><li>b. DecorView继承自FrameLayout，是所有界面的父类</li><li>c. FrameLayout是ViewGroup的子类，故DecorView的间接父类 = ViewGroup</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mDecor = (DecorView) preservedWindow.getDecorView();</span><br></pre></td></tr></table></figure><ul><li><p>到此可以证明Activity的根布局是FrameLayout<br><img src="https://upload-images.jianshu.io/upload_images/5363507-0ca11b1769d84822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li><p>调用父类的方法 = ViewGroup的dispatchTouchEvent()</p><ul><li>即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private final class DecorView extends FrameLayout&#123;                            </span><br><span class="line">    public boolean superDispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">     // 调用父类的方法 = ViewGroup的dispatchTouchEvent()</span><br><span class="line">       // 即 将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制</span><br><span class="line">       return super.dispatchTouchEvent(event);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>3、Activity.onTouchEvent(ev)分析：Activity中的onTouchEvent，个人理解在返回键的时候哦，退出App（或者是一个Activity的结束）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">    if (mWindow.shouldCloseOnTouch(this, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">   //只有在点击事件在Window边界外才会返回true，一般情况都返回false</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-a9f0ef459d463f6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/** @hide */</span><br><span class="line"> public boolean shouldCloseOnTouch(Context context, MotionEvent event) &#123;</span><br><span class="line">     if (mCloseOnTouchOutside &amp;&amp; event.getAction() == MotionEvent.ACTION_DOWN</span><br><span class="line">             &amp;&amp; isOutOfBounds(context, event) &amp;&amp; peekDecorView() != null) &#123;</span><br><span class="line">         return true;</span><br><span class="line">     &#125;      </span><br><span class="line">     return false;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-483ad66a339cf763.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android事件分发流程.jpg"></p><h4 id="ViewGroup件分发机制"><a href="#ViewGroup件分发机制" class="headerlink" title="ViewGroup件分发机制"></a>ViewGroup件分发机制</h4><ul><li><p>上面Activity事件分发机制可知，ViewGroup事件分发机制从dispatchTouchEvent()开始</p></li><li><p>分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件<br><img src="https://upload-images.jianshu.io/upload_images/5363507-c1728b31ab7b667e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p></li><li>a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部<ul><li>b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断<h4 id="调用dispatchTransformedTouchEvent方法的时机"><a href="#调用dispatchTransformedTouchEvent方法的时机" class="headerlink" title="调用dispatchTransformedTouchEvent方法的时机"></a>调用dispatchTransformedTouchEvent方法的时机</h4>有个遍历ViewGroup所有的孩子<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a1274ffacf550148.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li></ul><ul><li>分析2：dispatchTransformedTouchEvent方法分析<ul><li>将运动事件转换为特定子视图的坐标空间，</li><li>过滤不相关的指针ID，并在必要时重写其操作。</li><li>如果孩子是无效的，假设位移事件将被发送到这个ViewGroup相反。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a7c20bb588a68a87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul></li></ul><ul><li>调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</li><li>因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，</li><li>即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的机制)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,</span><br><span class="line">                                               View child, int desiredPointerIdBits) &#123;</span><br><span class="line">     final boolean handled;</span><br><span class="line"></span><br><span class="line">     //取消运动是一种特殊情况。我们不需要执行任何转换</span><br><span class="line">     //或过滤。重要的是行动，而不是内容。</span><br><span class="line">     final int oldAction = event.getAction();</span><br><span class="line">     if (cancel || oldAction == MotionEvent.ACTION_CANCEL) &#123;</span><br><span class="line">         event.setAction(MotionEvent.ACTION_CANCEL);</span><br><span class="line">         // 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</span><br><span class="line">         // 因此会执行ViewGroup的onTouch() -&gt;&gt; onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，</span><br><span class="line">         // 即自己处理该事件，事件不会往下传递（具体请参考View事件的分发机制中的View.dispatchTouchEvent（））</span><br><span class="line">         // 此处需与上面区别：子View的dispatchTouchEvent（）</span><br><span class="line"></span><br><span class="line">         // 若点击的是空白处（即无任何View接收事件） / 拦截事件（手动复写onInterceptTouchEvent（），从而让其返回true）</span><br><span class="line">         if (child == null) &#123;</span><br><span class="line">             handled = super.dispatchTouchEvent(event);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             //调用View onTouchEvent() -&gt;&gt; performClick（） -&gt;&gt; onClick()，</span><br><span class="line">             handled = child.dispatchTouchEvent(event);</span><br><span class="line">         &#125;</span><br><span class="line">         event.setAction(oldAction);</span><br><span class="line">         /**</span><br><span class="line">          调用子View的dispatchTouchEvent后是有返回值的</span><br><span class="line">          若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立</span><br><span class="line">          于是给ViewGroup的dispatchTouchEvent（）直接返回了true，即直接跳出</span><br><span class="line">          即把ViewGroup的点击事件拦截掉</span><br><span class="line">          */</span><br><span class="line">         return handled;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean dispatchTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">    //手势输入的验证者</span><br><span class="line">    if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    //如果事件以可访问性为焦点的视图为目标，这就是，开始</span><br><span class="line">    //正常事件分派。也许一个后代会处理点击。</span><br><span class="line">    if (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(false);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    boolean handled = false;</span><br><span class="line">    if (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        final int action = ev.getAction();</span><br><span class="line">        final int actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        // 处理初始值。第一个点击的ACTION_DOWN 事件</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            //在开始一个新的触摸手势时丢弃所有以前的状态。</span><br><span class="line">            //框架可能会取消上一个手势的上或取消事件。</span><br><span class="line">            //由于程序开关，ANR，或一些其他的状态变化。</span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //检查拦截。</span><br><span class="line">        final boolean intercepted;</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                || mFirstTouchTarget != null) &#123;</span><br><span class="line">            //  // 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，</span><br><span class="line">            // 可通过调用requestDisallowInterceptTouchEvent()修改</span><br><span class="line">            final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;</span><br><span class="line">            if (!disallowIntercept) &#123;</span><br><span class="line">                // // 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件</span><br><span class="line"></span><br><span class="line">                // 判断值2：intercepted= onInterceptTouchEvent(ev)返回值</span><br><span class="line">                /**</span><br><span class="line">                 a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span><br><span class="line">                 b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span><br><span class="line">                 intercepted=false  不拦截</span><br><span class="line">                 */</span><br><span class="line">                intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">                //恢复操作，以防更改</span><br><span class="line">                ev.setAction(action); // restore action in case it was changed</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                intercepted = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //没有触摸目标，这个动作不是初始的。</span><br><span class="line">            //因此，此视图组继续拦截触摸。</span><br><span class="line">            intercepted = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ///如果被拦截，启动正常事件分派。如果已经有了</span><br><span class="line">        // /正在处理手势的视图，执行正常事件调度。</span><br><span class="line">        /**</span><br><span class="line">         a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span><br><span class="line">         b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span><br><span class="line">         */</span><br><span class="line">        if (intercepted || mFirstTouchTarget != null) &#123;</span><br><span class="line">            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Check for cancelation. 检查取消。</span><br><span class="line">        final boolean canceled = resetCancelNextUpFlag(this)</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line">        //如果需要，指针更新的触摸目标更新列表。</span><br><span class="line">        // Update list of touch targets for pointer down, if needed.</span><br><span class="line">        final boolean split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != 0;</span><br><span class="line">        TouchTarget newTouchTarget = null;</span><br><span class="line">        boolean alreadyDispatchedToNewTouchTarget = false;</span><br><span class="line">        if (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">            //  /如果事件是针对accessiiblity焦点我们给它的</span><br><span class="line">            //   具有可访问性焦点的视图，如果它不处理它</span><br><span class="line">            //   我们清理标记，像往常一样把事件发给所有的孩子。</span><br><span class="line">            // /我们正在查找可访问性集中的主机以避免保留。</span><br><span class="line">            // /由于这些事件非常罕见。</span><br><span class="line">            View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">                    ? findChildWithAccessibilityFocus() : null;</span><br><span class="line"></span><br><span class="line">            if (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">                    || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">                    || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">                //按下永远为0</span><br><span class="line">                final int actionIndex = ev.getActionIndex(); // always 0 for down</span><br><span class="line">                final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                        : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">                ///清除这个指针id的早期触摸目标，以防它们</span><br><span class="line">                //变得不同步。</span><br><span class="line">                removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">                final int childrenCount = mChildrenCount;</span><br><span class="line">                if (newTouchTarget == null &amp;&amp; childrenCount != 0) &#123;</span><br><span class="line">                    final float x = ev.getX(actionIndex);</span><br><span class="line">                    final float y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">                    ///找到一个可以接收事件的孩子。</span><br><span class="line">                    //对孩子进行前后扫描。</span><br><span class="line">                    final ArrayList&lt;View&gt; preorderedList = buildOrderedChildList();</span><br><span class="line">                    final boolean customOrder = preorderedList == null</span><br><span class="line">                            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">                    final View[] children = mChildren;</span><br><span class="line">                    //，遍历了当前ViewGroup下的所有子View</span><br><span class="line">                    for (int i = childrenCount - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">                        final int childIndex = customOrder</span><br><span class="line">                                ? getChildDrawingOrder(childrenCount, i) : i;</span><br><span class="line">                        final View child = (preorderedList == null)</span><br><span class="line">                                ? children[childIndex] : preorderedList.get(childIndex);</span><br><span class="line"></span><br><span class="line">                        ///如果有可访问性焦点的视图，我们希望它</span><br><span class="line">                        //  获取事件，如果不处理，我们将执行一个</span><br><span class="line">                        //  正常调度。我们可以做双重迭代，但这是</span><br><span class="line">                        //  更安全鉴于时间表。</span><br><span class="line">                        if (childWithAccessibilityFocus != null) &#123;</span><br><span class="line">                            if (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            childWithAccessibilityFocus = null;</span><br><span class="line">                            i = childrenCount - 1;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (!canViewReceivePointerEvents(child)</span><br><span class="line">                                || !isTransformedTouchPointInView(x, y, child, null)) &#123;</span><br><span class="line">                            ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        newTouchTarget = getTouchTarget(child);</span><br><span class="line">                        if (newTouchTarget != null) &#123;</span><br><span class="line">                            ///孩子在其范围内已经收到了触摸。</span><br><span class="line">                            //给它一个新指针，除了它正在处理的指针。</span><br><span class="line">                            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        resetCancelNextUpFlag(child);</span><br><span class="line">                        if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) &#123;</span><br><span class="line">                            //孩子想在自己的范围内接受边界。</span><br><span class="line">                            mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                            if (preorderedList != null) &#123;</span><br><span class="line">                                // 子索引点预设列表，找到原始指标</span><br><span class="line">                                for (int j = 0; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                                    if (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                        mLastTouchDownIndex = j;</span><br><span class="line">                                        break;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                mLastTouchDownIndex = childIndex;</span><br><span class="line">                            &#125;</span><br><span class="line">                            mLastTouchDownX = ev.getX();</span><br><span class="line">                            mLastTouchDownY = ev.getY();</span><br><span class="line">                            newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                            alreadyDispatchedToNewTouchTarget = true;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        ///可访问性焦点没有处理事件，所以很清楚。</span><br><span class="line">                        //[并]向所有的孩子正常派遣。</span><br><span class="line">                        ev.setTargetAccessibilityFocus(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (preorderedList != null) preorderedList.clear();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) &#123;</span><br><span class="line">                    //没有找到一个孩子来接这件事。</span><br><span class="line">                    ///将指针分配给最近添加的目标。</span><br><span class="line">                    newTouchTarget = mFirstTouchTarget;</span><br><span class="line">                    while (newTouchTarget.next != null) &#123;</span><br><span class="line">                        newTouchTarget = newTouchTarget.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Dispatch to touch targets./发送到触摸目标。</span><br><span class="line">        if (mFirstTouchTarget == null) &#123;</span><br><span class="line">            // No touch targets so treat this as an ordinary view.</span><br><span class="line">            //没有触及目标，所以把它当作普通的观点看待。</span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, null,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // //发送到触摸目标，不包括新的触摸目标，如果我们已经</span><br><span class="line">            //     被派往。如有必要取消触摸目标。</span><br><span class="line">            TouchTarget predecessor = null;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            while (target != null) &#123;</span><br><span class="line">                final TouchTarget next = target.next;</span><br><span class="line">                if (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = true;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    final boolean cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    //  条件判断的内部调用了该View的dispatchTouchEvent()</span><br><span class="line">                    // 即 实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）</span><br><span class="line">                    if (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (cancelChild) &#123;</span><br><span class="line">                        if (predecessor == null) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //更新需要更新或取消的触摸目标列表。</span><br><span class="line">        if (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; else if (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            final int actionIndex = ev.getActionIndex();</span><br><span class="line">            final int idBitsToRemove = 1 &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!handled &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5363507-e3eb13e3297155f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity事件分发流程（ViewGroup）.png"></p><h4 id="Activity事件分发的流程（View-dispatchTouchEvent-event）"><a href="#Activity事件分发的流程（View-dispatchTouchEvent-event）" class="headerlink" title="Activity事件分发的流程（View.dispatchTouchEvent(event）"></a>Activity事件分发的流程（View.dispatchTouchEvent(event）</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-c48d951731d69983.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>关键代码的分析：</p><ul><li><ol><li>mOnTouchListener != null （设置setOnTouchListener（this））</li></ol></li><li><ol start="2"><li>(mViewFlags &amp; ENABLED_MASK) == ENABLED （这个控件能否点击，）</li></ol></li><li><ol start="3"><li>mOnTouchListener.onTouch(this, event) （返回了true事件被拦截）<br>只有以下3个条件都为真，dispatchTouchEvent()才返回true<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；</span><br><span class="line">       // 否则执行onTouchEvent()</span><br><span class="line">       //     1. mOnTouchListener != null</span><br><span class="line">       //     2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">       //     3. mOnTouchListener.onTouch(this, event)</span><br><span class="line"></span><br><span class="line">       /**</span><br><span class="line">        * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">        * 说明：</span><br><span class="line">        *     a. 该条件是判断当前点击的控件是否enable</span><br><span class="line">        *     b. 由于很多View默认enable，故该条件恒定为true</span><br><span class="line">        */</span><br><span class="line">       //当li恒等于null的时候，后面的判断会执行</span><br><span class="line">       //但是li在设置了setOnTouchListener就不为空，如果onTouch返回为true的话，</span><br><span class="line">       // onclick就不会走了</span><br><span class="line">       if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">               &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">               &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">           result = true;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>当上面的result返回为false的时候才会走<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//没被拦截走到onTouchEvent（event）</span><br><span class="line">if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">    result = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关于onTouchEvent方法：记住这点就行ACTION_UP—》手机抬起来了，才会执行performClick（）</p><h4 id="目前大多数的app都是只设置了setOnClickListener（），可以自己手动点击一个按钮，会发现只有抬起手，这个事件才会执行，如果让用户体验的比较好一点，对那些有强迫症的用户，应该也重写setOnTouchListener（this）-但是记住不能拦击了，我的影像中，鲁大师App，就是重写了这个方法，所以在手指没有抬起来，下面tab的颜色已经发生了改变。"><a href="#目前大多数的app都是只设置了setOnClickListener（），可以自己手动点击一个按钮，会发现只有抬起手，这个事件才会执行，如果让用户体验的比较好一点，对那些有强迫症的用户，应该也重写setOnTouchListener（this）-但是记住不能拦击了，我的影像中，鲁大师App，就是重写了这个方法，所以在手指没有抬起来，下面tab的颜色已经发生了改变。" class="headerlink" title="目前大多数的app都是只设置了setOnClickListener（），可以自己手动点击一个按钮，会发现只有抬起手，这个事件才会执行，如果让用户体验的比较好一点，对那些有强迫症的用户，应该也重写setOnTouchListener（this）,但是记住不能拦击了，我的影像中，鲁大师App，就是重写了这个方法，所以在手指没有抬起来，下面tab的颜色已经发生了改变。"></a>目前大多数的app都是只设置了setOnClickListener（），可以自己手动点击一个按钮，会发现只有抬起手，这个事件才会执行，如果让用户体验的比较好一点，对那些有强迫症的用户，应该也重写setOnTouchListener（this）,但是记住不能拦击了，我的影像中，鲁大师App，就是重写了这个方法，所以在手指没有抬起来，下面tab的颜色已经发生了改变。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  // 若在onTouch（）返回true，就会让上述三个条件全部成立，</span><br><span class="line">  // 从而使得View.dispatchTouchEvent（）直接返回true，事件分发结束</span><br><span class="line"></span><br><span class="line">  // 若在onTouch（）返回false，就会使得上述三个条件不全部成立，</span><br><span class="line">  // 从而使得View.dispatchTouchEvent（）中跳出If，执行onTouchEvent(event)</span><br><span class="line">button.setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">    public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5363507-0502e8f837fa0621.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p> 只要我们通过setOnClickListener（）为控件View注册1个点击事件 ，那么就会给mOnClickListener变量赋值（即不为空）， 则会往下回调onClick（） &amp; performClick（）返回true，performClick 就是模拟了一个请求，点击事件的请求，之类的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    public boolean performClick() &#123;</span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">//          ListenerInfo mOnClickListener=getListenerInfo();</span><br><span class="line">//            getListenerInfo().mOnClickListener.onClick(this);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = false;</span><br><span class="line">        &#125;</span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>通过对performClick（） 源码解读，你可能可以发现有点怪怪的东西，就是一个方法中的全局变量。以前觉得有点怪怪的，但是目前看来，需要去判断下是否为null，不用去调用方法初始化值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListenerInfo getListenerInfo() &#123;</span><br><span class="line">     if (mListenerInfo != null) &#123;</span><br><span class="line">         return mListenerInfo;</span><br><span class="line">     &#125;</span><br><span class="line">     mListenerInfo = new ListenerInfo();</span><br><span class="line">     return mListenerInfo;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>涉及到的所有的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line">  @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)</span><br><span class="line">    public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        // 如果事件应该通过可访问性焦点来处理。</span><br><span class="line">        if (event.isTargetAccessibilityFocus()) &#123;</span><br><span class="line">            // 我们没有焦点，也没有虚拟后代，没有处理事件。</span><br><span class="line">            if (!isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 我们有焦点，得到事件，然后使用正常事件调度。</span><br><span class="line">            event.setTargetAccessibilityFocus(false);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean result = false;</span><br><span class="line"></span><br><span class="line">        if (mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onTouchEvent(event, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final int actionMasked = event.getActionMasked();</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            //防御新手势</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (onFilterTouchEventForSecurity(event)) &#123;</span><br><span class="line">            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //noinspection SimplifiableIfStatement</span><br><span class="line">            ListenerInfo li = mListenerInfo;</span><br><span class="line">            // 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；</span><br><span class="line">            // 否则执行onTouchEvent()</span><br><span class="line">            //     1. mOnTouchListener != null</span><br><span class="line">            //     2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">            //     3. mOnTouchListener.onTouch(this, event)</span><br><span class="line"></span><br><span class="line">            /**</span><br><span class="line">             * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">             * 说明：</span><br><span class="line">             *     a. 该条件是判断当前点击的控件是否enable</span><br><span class="line">             *     b. 由于很多View默认enable，故该条件恒定为true</span><br><span class="line">             */</span><br><span class="line">            //当li恒等于null的时候，后面的判断会执行</span><br><span class="line">            //但是li在设置了setOnTouchListener就不为空，如果onTouch返回为true的话，</span><br><span class="line">            // onclick就不会走了</span><br><span class="line">            if (li != null &amp;&amp; li.mOnTouchListener != null</span><br><span class="line">                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED</span><br><span class="line">                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">            //没被拦截走到onTouchEvent（event）</span><br><span class="line">            if (!result &amp;&amp; onTouchEvent(event)) &#123;</span><br><span class="line">                result = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!result &amp;&amp; mInputEventConsistencyVerifier != null) &#123;</span><br><span class="line">            mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //在嵌套滚动之后清理，如果这是手势的结束；</span><br><span class="line">        //也取消了如果我们试着action_down但是我们不想休息</span><br><span class="line">        //手势。</span><br><span class="line">        if (actionMasked == MotionEvent.ACTION_UP ||</span><br><span class="line">                actionMasked == MotionEvent.ACTION_CANCEL ||</span><br><span class="line">                (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) &#123;</span><br><span class="line">            stopNestedScroll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        final float x = event.getX();</span><br><span class="line">        final float y = event.getY();</span><br><span class="line">        final int viewFlags = mViewFlags;</span><br><span class="line">        final int action = event.getAction();</span><br><span class="line">        // 若该控件可点击，则进入switch判断中</span><br><span class="line">        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE</span><br><span class="line">                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)</span><br><span class="line">                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;</span><br><span class="line"></span><br><span class="line">        if ((viewFlags &amp; ENABLED_MASK) == DISABLED) &#123;</span><br><span class="line">            if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                setPressed(false);</span><br><span class="line">            &#125;</span><br><span class="line">            mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">            // A disabled view that is clickable still consumes the touch</span><br><span class="line">            // events, it just doesn&apos;t respond to them.</span><br><span class="line">            return clickable;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mTouchDelegate != null) &#123;</span><br><span class="line">            if (mTouchDelegate.onTouchEvent(event)) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若该控件可点击，则进入switch判断中</span><br><span class="line">        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">            switch (action) &#123;</span><br><span class="line">                // a. 若当前的事件 = 抬起View（主要分析）</span><br><span class="line">                case MotionEvent.ACTION_UP:</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    if ((viewFlags &amp; TOOLTIP) == TOOLTIP) &#123;</span><br><span class="line">                        handleTooltipUp();</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (!clickable) &#123;</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        mInContextButtonPress = false;</span><br><span class="line">                        mHasPerformedLongPress = false;</span><br><span class="line">                        mIgnoreNextUpEvent = false;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;</span><br><span class="line">                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) &#123;</span><br><span class="line">                        // take focus if we don&apos;t have it already and we should in</span><br><span class="line">                        // touch mode.</span><br><span class="line">                        boolean focusTaken = false;</span><br><span class="line">                        if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) &#123;</span><br><span class="line">                            focusTaken = requestFocus();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            // The button is being released before we actually</span><br><span class="line">                            // showed it as pressed.  Make it show the pressed</span><br><span class="line">                            // state now (before scheduling the click) to ensure</span><br><span class="line">                            // the user sees it.</span><br><span class="line">                            setPressed(true, x, y);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) &#123;</span><br><span class="line">                            // This is a tap, so remove the longpress check</span><br><span class="line">                            removeLongPressCallback();</span><br><span class="line"></span><br><span class="line">                            // Only perform take click actions if we were in the pressed state</span><br><span class="line">                            if (!focusTaken) &#123;</span><br><span class="line">                                // Use a Runnable and post this rather than calling</span><br><span class="line">                                // performClick directly. This lets other visual state</span><br><span class="line">                                // of the view update before click actions start.</span><br><span class="line">                                if (mPerformClick == null) &#123;</span><br><span class="line">                                    mPerformClick = new PerformClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                                if (!post(mPerformClick)) &#123;</span><br><span class="line">                                    // 执行performClick() -&gt;&gt;分析1</span><br><span class="line">                                    performClick();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (mUnsetPressedState == null) &#123;</span><br><span class="line">                            mUnsetPressedState = new UnsetPressedState();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        if (prepressed) &#123;</span><br><span class="line">                            postDelayed(mUnsetPressedState,</span><br><span class="line">                                    ViewConfiguration.getPressedStateDuration());</span><br><span class="line">                        &#125; else if (!post(mUnsetPressedState)) &#123;</span><br><span class="line">                            // If the post failed, unpress right now</span><br><span class="line">                            mUnsetPressedState.run();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    break;</span><br><span class="line">                // b. 若当前的事件 = 按下View</span><br><span class="line">                case MotionEvent.ACTION_DOWN:</span><br><span class="line">                    if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) &#123;</span><br><span class="line">                        mPrivateFlags3 |= PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line"></span><br><span class="line">                    if (!clickable) &#123;</span><br><span class="line">                        checkForLongClick(0, x, y);</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    if (performButtonActionOnTouchDown(event)) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.</span><br><span class="line">                    boolean isInScrollingContainer = isInScrollingContainer();</span><br><span class="line"></span><br><span class="line">                    // For views inside a scrolling container, delay the pressed feedback for</span><br><span class="line">                    // a short period in case this is a scroll.</span><br><span class="line">                    if (isInScrollingContainer) &#123;</span><br><span class="line">                        mPrivateFlags |= PFLAG_PREPRESSED;</span><br><span class="line">                        if (mPendingCheckForTap == null) &#123;</span><br><span class="line">                            mPendingCheckForTap = new CheckForTap();</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingCheckForTap.x = event.getX();</span><br><span class="line">                        mPendingCheckForTap.y = event.getY();</span><br><span class="line">                        postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // Not inside a scrolling container, so show the feedback right away</span><br><span class="line">                        setPressed(true, x, y);</span><br><span class="line">                        checkForLongClick(0, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">                // c. 若当前的事件 = 结束事件（非人为原因）</span><br><span class="line">                case MotionEvent.ACTION_CANCEL:</span><br><span class="line">                    if (clickable) &#123;</span><br><span class="line">                        setPressed(false);</span><br><span class="line">                    &#125;</span><br><span class="line">                    removeTapCallback();</span><br><span class="line">                    removeLongPressCallback();</span><br><span class="line">                    mInContextButtonPress = false;</span><br><span class="line">                    mHasPerformedLongPress = false;</span><br><span class="line">                    mIgnoreNextUpEvent = false;</span><br><span class="line">                    mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    break;</span><br><span class="line">                // d. 若当前的事件 = 滑动View</span><br><span class="line">                case MotionEvent.ACTION_MOVE:</span><br><span class="line">                    if (clickable) &#123;</span><br><span class="line">                        drawableHotspotChanged(x, y);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // Be lenient about moving outside of buttons</span><br><span class="line">                    if (!pointInView(x, y, mTouchSlop)) &#123;</span><br><span class="line">                        // Outside button</span><br><span class="line">                        // Remove any future long press/tap checks</span><br><span class="line">                        removeTapCallback();</span><br><span class="line">                        removeLongPressCallback();</span><br><span class="line">                        if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) &#123;</span><br><span class="line">                            setPressed(false);</span><br><span class="line">                        &#125;</span><br><span class="line">                        mPrivateFlags3 &amp;= ~PFLAG3_FINGER_DOWN;</span><br><span class="line">                    &#125;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 若该控件可点击，就一定返回true</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        // 若该控件不可点击，就一定返回false</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * Call this view&apos;s OnClickListener, if it is defined.  Performs all normal</span><br><span class="line">     * actions associated with clicking: reporting accessibility event, playing</span><br><span class="line">     * a sound, etc.</span><br><span class="line">     * *把这种观点的OnClickListener，如果它的定义。执行所有正常</span><br><span class="line">     *与点击相关的操作：报告可访问性事件，播放</span><br><span class="line">     *声音等。</span><br><span class="line">     * @return True there was an assigned OnClickListener that was called, false</span><br><span class="line">     *         otherwise is returned.</span><br><span class="line">     */</span><br><span class="line">    // 只要我们通过setOnClickListener（）为控件View注册1个点击事件</span><br><span class="line">    // 那么就会给mOnClickListener变量赋值（即不为空）</span><br><span class="line">    // 则会往下回调onClick（） &amp; performClick（）返回true</span><br><span class="line">    //performClick 就是模拟了一个请求，点击事件的请求，子类的东西</span><br><span class="line">    public boolean performClick() &#123;</span><br><span class="line">        final boolean result;</span><br><span class="line">        final ListenerInfo li = mListenerInfo;</span><br><span class="line">        if (li != null &amp;&amp; li.mOnClickListener != null) &#123;</span><br><span class="line">            playSoundEffect(SoundEffectConstants.CLICK);</span><br><span class="line">            // TODO: 2018/4/18 这里看源码  有点意思</span><br><span class="line">//          ListenerInfo mOnClickListener=getListenerInfo();</span><br><span class="line">//            getListenerInfo().mOnClickListener.onClick(this);</span><br><span class="line">            li.mOnClickListener.onClick(this);</span><br><span class="line">            result = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            result = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);</span><br><span class="line"></span><br><span class="line">        notifyEnterOrExitForAutoFillIfNeeded(true);</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-6dd9ca20e864ca72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity事件分发的流程（View.dispatchTouchEvent(event）.png"></p><h4 id="最后做了一张图"><a href="#最后做了一张图" class="headerlink" title="最后做了一张图"></a>最后做了一张图</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4c1e1edc8cf6a571.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件分发.png"></p>]]></content>
      
      
        <tags>
            
            <tag> Android事件传递 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓代码、图片、布局、网络和电量优化</title>
      <link href="/2018/05/06/%E5%AE%89%E5%8D%93%E4%BB%A3%E7%A0%81%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E5%B8%83%E5%B1%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%92%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/"/>
      <url>/2018/05/06/%E5%AE%89%E5%8D%93%E4%BB%A3%E7%A0%81%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E5%B8%83%E5%B1%80%E3%80%81%E7%BD%91%E7%BB%9C%E5%92%8C%E7%94%B5%E9%87%8F%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<ul><li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</li></ul><h4 id="写在前面的话，前段时间写了一篇文章-二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！"><a href="#写在前面的话，前段时间写了一篇文章-二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！" class="headerlink" title="写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！"></a>写在前面的话，前段时间写了一篇文章 <a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a>，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！</h4><a id="more"></a><h4 id="这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！"><a href="#这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！" class="headerlink" title="这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！"></a>这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-151e1acaa8105b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h4 id="Demo下载的地址"><a href="#Demo下载的地址" class="headerlink" title="Demo下载的地址"></a>Demo下载的地址</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-bfcb14dc69cb04ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F0xJ.png"></p><h4 id="代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）"><a href="#代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）" class="headerlink" title="代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）"></a>代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）</h4><p>数据集合的使用：建议最佳的做法是可能使用ArrayList作为首选，只要你需要使用额外的功能的时候，或者当程序性能由于经常从表的中间进行插入和删除而变差的时候，才会去选择LinkedList。HashMap性能上于HashTable相当，因为HashMap和HashTable在底层的存储和查找机制是一样的，但是TreeMap通常比HashMap要慢。HashSet总体上的性能比TreeSet好，特别实在添加和查询元素的时候，而这两个操作也是最重要的操作。TreeSet存在的唯一的原因是它可以维持元素的排序的状态，所以当需要一个排好序的Set，才使用TreeSet。因为其内部的结果欧支持排序，并且因为迭代是我们更有可能执行的操作，所以，用TreeSet迭代通常比用HashSet要快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">       * 建议最佳的做法是可能使用ArrayList作为首选，只要你需要使用额外的功能的时候，或者当程序性能由于经常从表的中间进行</span><br><span class="line">       * 插入和删除而变差的时候，才会去选择LinkedList</span><br><span class="line">       */</span><br><span class="line">      //数据结构的选择，对于ArrayList，插入的操作特别高昂，并且其代价将随着列表的尺寸的增加而增加</span><br><span class="line">      ArrayList list=new ArrayList();</span><br><span class="line">      //需要执行大量的随机的访问，这个不是一个好的选择，如果是使用迭代器在列表中插入新的数据，使用这个，比较低廉（插入和移除的代价比较低廉）</span><br><span class="line">      LinkedList linkedList=new LinkedList();</span><br><span class="line">      //HashMap性能上于HashTable相当，因为HashMap和HashTable在底层的存储和查找机制是一样的，但是TreeMap通常比HashMap要慢</span><br><span class="line">      HashMap&lt;String,String&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">      /**</span><br><span class="line">       * HashSet总体上的性能比TreeSet好，特别实在添加和查询元素的时候，而这两个操作也是最重要的操作。TreeSet存在的唯一的原因是它</span><br><span class="line">       * 可以维持元素的排序的状态，所以当需要一个排好序的Set，才使用TreeSet。因为其内部的结果欧支持排序，并且因为迭代是我们更有可能</span><br><span class="line">       * 执行的操作，所以，用TreeSet迭代通常比用HashSet要快</span><br><span class="line">       */</span><br><span class="line">      HashSet&lt;String&gt;  hashSet=new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      TreeSet&lt;String&gt; treeSet=new TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>SparseArray是Android特有的稀疏数组的实现，他是Integer和Object的为例进行的一个映射用于代替 HsahMap&lt;Integer,<e>&gt;,提高性能。</e></p><ul><li>SparseArray<ul><li>线程不安全（多线程中需要注意）</li><li>由于要进行二分查找，（可以是有序的），SparseArray会对插入的数据按照Key的大小顺序插入</li><li>SparseArray对删除操作做了优化，它并不会立刻删除这个元素，而是通过设置标记位（DELETED）的方法，后面尝试重用。</li></ul></li></ul><p>内部核心的实现（二分查找）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。</span><br><span class="line">    * 但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</span><br><span class="line">    * @param array</span><br><span class="line">    * @param size</span><br><span class="line">    * @param value</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   //二分查找</span><br><span class="line">   static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">       int lo = 0;</span><br><span class="line">       int hi = size - 1;</span><br><span class="line"></span><br><span class="line">       while (lo &lt;= hi) &#123;</span><br><span class="line">           /**</span><br><span class="line">            * &gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用0填充。</span><br><span class="line">            * —比如你的例子，byte是8位的，-1表示为byte型是11111111(补码表示法）</span><br><span class="line">            * b&gt;&gt;&gt;4就是无符号右移4位，即00001111，这样结果就是15。</span><br><span class="line">            * 这里相当移动一位，除以二</span><br><span class="line">            */</span><br><span class="line">           final int mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">           final int midVal = array[mid];</span><br><span class="line"></span><br><span class="line">           if (midVal &lt; value) &#123;</span><br><span class="line">               lo = mid + 1;</span><br><span class="line">           &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">               hi = mid - 1;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return mid;  // value found</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //按位取反（~）运算符 ,没有找到，这个数据</span><br><span class="line">       return ~lo;  // value not present</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>SpareArray 家族有以下的四类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  //SpareArray 家族有以下的四类</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line">SparseBooleanArray sparseBooleanArray=new SparseBooleanArray();</span><br><span class="line">sparseBooleanArray.append(1,false);</span><br><span class="line">//用于替换    HashMap&lt;Integer,Interger&gt;</span><br><span class="line">SparseIntArray SparseIntArray=new SparseIntArray();</span><br><span class="line">SparseIntArray.append(1,1);</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line"></span><br><span class="line">@SuppressLint(&#123;&quot;NewApi&quot;, &quot;LocalSuppress&quot;&#125;)</span><br><span class="line">SparseLongArray SparseLongArray=new SparseLongArray();</span><br><span class="line">SparseLongArray.append(1,1111000L);</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line">SparseArray&lt;String&gt; SparseArray11=new SparseArray&lt;String&gt;();</span><br><span class="line">SparseArray11.append(1,&quot;dd&quot;);</span><br></pre></td></tr></table></figure></p><p>SpareArray中的设计模式：原型模式:这里有使用到了的，原型模式内存中复制数据的，不会调用到类的构造的方法，而且访问的权限对原型模式无效</p><ul><li>优点： 1、性能提高。 2、逃避构造函数的约束。<ul><li>缺点：<pre><code>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。 2、必须实现 Cloneable 接口。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseArray&lt;String&gt; clone = sparseArray.clone();</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>Handler正确的使用姿势（☺☺☺）<br>下面的代码是很多人都会这样写，这样会造成内存泄漏<br>原因：Handler是和Looper以及MessageQueue一起工作的，在安卓中，一个 应用启动了，系统会默认创建一个主线程服务的Looper对象 ，该Looper对象处理主线程的所有的Message消息，他的生命周期贯穿整个应用。在主线程中使用的Handler的都会默认的绑定到这个looper的对象，咋主线程中创建handler的时候，它会立即关联主线程Looper对象的MessageQueue，这时发送到的MessageQueue 中的Message对象都会持有这个Handler的对象的引用，这样Looper处理消息时Handler的handlerMessage的方法，因此，如果Message还没有处理完成，那么handler的对象不会立即被垃圾回收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   /*-------------old ide 已经告诉我们这里可能内存泄露-------------------*/</span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private final Handler mHandler=new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//        mHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void run() &#123;</span><br><span class="line">//                // TODO: 2018/4/28  用户即使退出了应用的话，这里也是会执行的 ，通过日记的观察</span><br><span class="line">//                //这里有可能用户退出了Activity</span><br><span class="line">//                System.out.println(&quot;shiming mHandler --todo&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;,5000);</span><br></pre></td></tr></table></figure></p><p>如何避免，有两点的可以尝试</p><ul><li>1、在子线程中使用Handler，但是Handler不能再子线程中使用，需要开发者自己创建一个Looper对象，实现难，方法怪<ul><li>2、将handler声明为静态的内部类，静态内部类不会持有外部类的引用，因此，也不会引起内存泄露，</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  InnerHandler innerHandler = new InnerHandler(this);</span><br><span class="line">      innerHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              //这里这要 退出了 就不会执行了</span><br><span class="line">              System.out.println(&quot;shiming innerHandler --todo&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,5000);</span><br><span class="line">public class InnerHandler extends Handler&#123;</span><br><span class="line">      //弱应用，在另外一个地方会讲到</span><br><span class="line">      private final WeakReference&lt;HandlerActivity&gt; mActivityWeakReference;</span><br><span class="line"></span><br><span class="line">      public InnerHandler(HandlerActivity activity)&#123;</span><br><span class="line">          mActivityWeakReference=new WeakReference&lt;HandlerActivity&gt;(activity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>Context正确的姿势<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Context的种类</span><br><span class="line">     //Application 全局唯一的Context实例</span><br><span class="line">     Application application = getApplication();</span><br><span class="line">     Context applicationContext = application.getApplicationContext();</span><br><span class="line">     //不同的Activity，得到这个Context，是独立的，不会进行复用</span><br><span class="line">     Context baseContext = this.getBaseContext();</span><br><span class="line"></span><br><span class="line">     MyBroadcaseRecriver myBroadcaseRecriver = new MyBroadcaseRecriver();</span><br><span class="line"></span><br><span class="line">     //ContentProvider 中的Context</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      *如果创建单利必须需要使用到context对象</span><br><span class="line">      */</span><br><span class="line">     //这样不会内存泄露，不用改动单利类中代码</span><br><span class="line">     SingleInstance.getSingleInstance(getApplication().getApplicationContext());</span><br></pre></td></tr></table></figure></p><ul><li>单例模式，如果不得不传入Context，由于单例一直存在会导致Activity或者是Service的单例引用，从而不会被垃圾回收， Activity中的关联的View和数据结构也不会被释放，正确的方式应该使用Application中的Context</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class SingleInstance &#123;</span><br><span class="line">    private static SingleInstance sSingleInstance;</span><br><span class="line">    private final Context mContext;</span><br><span class="line"></span><br><span class="line">    private SingleInstance(Context context)&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">//    因为每次调用实例都需要判断同步锁，很多项目包括很多人都是用这种的</span><br><span class="line">//    双重判断校验的方法，这种的方法看似很完美的解决了效率的问题，但是它</span><br><span class="line">//    在并发量不多，安全性不太高的情况下能完美的运行，但是，</span><br><span class="line">//    在jvm编译的过程中会出现指令重排的优化过程，这就会导致singleton实际上</span><br><span class="line">//    没有被初始化，就分配了内存空间，也就是说singleton！=null但是又没有被初始化，</span><br><span class="line">//    这就会导致返回的singletonthird返回的是不完整的</span><br><span class="line">    public static SingleInstance getSingleInstance(Context context)&#123;</span><br><span class="line">        if (sSingleInstance==null)&#123;</span><br><span class="line">            synchronized (SingleInstance.class)&#123;</span><br><span class="line">                if (sSingleInstance==null)   &#123;</span><br><span class="line">                    // TODO: 2018/4/28 注意外面传入的conext对象是否，是哪个 </span><br><span class="line">                    sSingleInstance= new SingleInstance(context);</span><br><span class="line">                    //第二种是改动代码，使用application 中的context变量</span><br><span class="line">                    sSingleInstance= new SingleInstance(context.getApplicationContext());</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>java 四种引用方式和引用队列的解释<br>和java一样，Android也是基于垃圾回收（GC）机制实现内存的自动的回收，垃圾回收的算法“标记-清除（Mark-Sweep）” “标记压缩（Mark-Compact）“复制算法（Copying）以及引用计数算法（Reference-Counting），安卓的虚拟机（Dalvik还是Art），都是使用标记清除算法。 在Android中，内存泄露是指不再使用的对象依然占有内存，或者是他们占用的内存没有得到释放， 从而导致内存空间不断的减少，由于可用的空间比较少，发生内存泄露会使得内存更加的紧张，甚至最终由于内存耗尽而发生的OOM，导致应用的崩溃。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> * 和java一样，Android也是基于垃圾回收（GC）机制实现内存的自动的回收，垃圾回收的算法“标记-清除（Mark-Sweep）”</span><br><span class="line"> * “标记压缩（Mark-Compact）“复制算法（Copying）以及引用计数算法（Reference-Counting），安卓的虚拟机（Dalvik还是Art），</span><br><span class="line"> * 都是使用标记清除算法”</span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line">mTextView1.setText(des1);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在Android中，内存泄露是指不再使用的对象依然占有内存，或者是他们占用的内存没有得到释放，</span><br><span class="line"> * 从而导致内存空间不断的减少，由于可用的空间比较少，发生内存泄露会使得内存更加的紧张，</span><br><span class="line"> * 甚至最终由于内存耗尽而发生的OOM，导致应用的崩溃</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">mTextView2.setText(des2);</span><br></pre></td></tr></table></figure><ul><li>强引用：Java中里面最广泛的使用的一种，也是对象默认的引用类型，如果又一个对象具有强引用，那么垃圾回收器是不会对它进行回收操作的，当内存的空间不足的时候，Java虚拟机将会抛OutOfMemoryError错误，这时应用将会被终止运行</li><li>软引用：一个对象如果只有一个软引用，那么当内存空间充足是，垃圾回收器不会对他进行回收操作，只有当内存空间不足的时候，这个对象才会被回收，软引用可以用来实现内存敏感的高速缓存，如果配合引用队列（ReferenceQueue使用，当软引用指向对象被垃圾回收器回收后，java会把这个软引用加入到与之关联的引用队列中）</li><li>弱引用：弱引用是比软引用更弱的一种的引用的类型，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不敢当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用</li><li><p>引用队列：ReferenceQueue一般是作为WeakReference SoftReference 的构造的函数参数传入的，在WeakReference 或者是 softReference 的指向的对象被垃圾回收后，ReferenceQueue就是用来保存这个已经被回收的Reference</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String des3=&quot;强引用：Java中里面最广泛的使用的一种，也是对象默认的引用类型，如果又一个对象具有强引用，那么垃圾回收器是不会对它进行回收操作的，当内存的空间不足的时候，Java虚拟机将会抛出OutOfMemoryError错误，这时应用将会被终止运行&quot;;</span><br><span class="line"></span><br><span class="line">mTextView3.setText(des3);</span><br><span class="line">String des4=&quot;软引用：一个对象如果只有一个软引用，那么当内存空间充足是，垃圾回收器不会对他进行回收操作，只有当内存空间不足的时候，这个对象才会被回收，软引用可以用来实现内存敏感的高速缓存，如果配合引用队列（ReferenceQueue使用，当软引用指向对象被垃圾回收器回收后，java会把这个软引用加入到与之关联的引用队列中）&quot;;</span><br><span class="line"></span><br><span class="line">Object obj=new Object();</span><br><span class="line"></span><br><span class="line">SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(obj);//这里使用了软引用...</span><br><span class="line">/*</span><br><span class="line"> *在这个期间，有可能会出现内存不足的情况发生，那么GC就会直接把所有的软引用全部清除..并释放内存空间</span><br><span class="line"> *如果内存空间足够的话，那么就GC就不会进行工作...</span><br><span class="line"> *GC的工作取决于内存的大小，以及其内部的算法,,,,</span><br><span class="line"> */</span><br><span class="line">if(sr!=null)&#123;</span><br><span class="line">    //如果软引用还存在，那么直接就可以获取这个对象的相关数据...这样就实现了cache...</span><br><span class="line">    obj = sr.get();</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //如果已经不存在，表示GC已经将其回收，我们需要重新实例化对象，获取数据信息...</span><br><span class="line">    obj = new Object();</span><br><span class="line">    sr = new SoftReference&lt;&gt;(obj);</span><br><span class="line">&#125;</span><br><span class="line">mTextView4.setText(des4);</span><br><span class="line">String des5=&quot;弱引用：弱引用是比软引用更弱的一种的引用的类型，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不敢当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用&quot;;</span><br><span class="line"></span><br><span class="line">Object obj1 = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; weakProductA = new WeakReference&lt;&gt;(obj1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mTextView5.setText(des5);</span><br><span class="line">String des6=&quot;虚引用：和软引用和弱引用不同，虚引用并不会对所指向的对象生命周期产生任何影响，也就是对象还是会按照它原来的方式别垃圾回收期回收，虚引用本质上只是有一个标记作用，主要用来跟踪对象被垃圾回收的活动，虚引用必须和引用队列配合使用，当对象被垃圾回收时，如果存在虚引用，那么Java虚拟机会将这个虚引用加入到与之关联的引用队列中&quot;;</span><br><span class="line"></span><br><span class="line">mTextView6.setText(des6);</span><br><span class="line">/**</span><br><span class="line"> * 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</span><br><span class="line"> * 虚引用主要用来跟踪对象被垃圾回收器回收的活动</span><br><span class="line"> */</span><br><span class="line">// TODO: 2018/5/2 程序可以通过判断引用队列中是否已经加入了虚引用，</span><br><span class="line">// 来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，</span><br><span class="line">// 那么就可以在所引用的对象的内存被回收之前采取必要的行动。</span><br><span class="line">ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference&lt;Object&gt;(obj1, queue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String des7=&quot;引用队列：ReferenceQueue一般是作为WeakReference SoftReference 的构造的函数参数传入的，在WeakReference 或者是 softReference 的指向的对象被垃圾回收后，ReferenceQueue就是用来保存这个已经被回收的Reference&quot;;</span><br><span class="line">mTextView7.setText(des7);</span><br></pre></td></tr></table></figure></li><li><p>将HashMap封装成一个线程安全的集合，并且使用软引用的方式防止OOM（内存不足）。由于在ListView中会加载大量的图片.那么为了有效的防止OOM导致程序终止的情况</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * list中使用大量的bitmap，这种情况的话，我自己感觉使用的比较少</span><br><span class="line">   */</span><br><span class="line">  public class MemoryCache &#123;</span><br><span class="line">      //将HashMap封装成一个线程安全的集合，并且使用软引用的方式防止OOM（内存不足）...</span><br><span class="line">      //由于在ListView中会加载大量的图片.那么为了有效的防止OOM导致程序终止的情况...</span><br><span class="line">      private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cache=Collections.synchronizedMap(new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;());</span><br><span class="line"></span><br><span class="line">      public Bitmap get(String id)&#123;</span><br><span class="line">          if(!cache.containsKey(id))</span><br><span class="line">              return null;</span><br><span class="line">          SoftReference&lt;Bitmap&gt;ref=cache.get(id);</span><br><span class="line">          return ref.get();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void put(String id,Bitmap bitmap)&#123;</span><br><span class="line">          cache.put(id, new SoftReference&lt;Bitmap&gt;(bitmap));</span><br><span class="line">      &#125;</span><br><span class="line">      public void clear()&#123;</span><br><span class="line">          cache.clear();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>一个简单的Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/2 14:50</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class EmployeeCache &#123;</span><br><span class="line">    static private EmployeeCache cache;// 一个Cache实例</span><br><span class="line">    private Hashtable&lt;String, EmployeeRef&gt; employeeRefs;// 用于Chche内容的存储</span><br><span class="line">    private ReferenceQueue&lt;Employee&gt; q;// 垃圾Reference的队列</span><br><span class="line"></span><br><span class="line">     // 继承SoftReference，使得每一个实例都具有可识别的标识。</span><br><span class="line">    // 并且该标识与其在HashMap内的key相同。</span><br><span class="line">    public class EmployeeRef extends SoftReference&lt;Employee&gt; &#123;</span><br><span class="line">        private String _key = &quot;&quot;;</span><br><span class="line">        public EmployeeRef(Employee em, ReferenceQueue&lt;Employee&gt; q) &#123;</span><br><span class="line">            super(em, q);</span><br><span class="line">            _key = em.getID();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建一个缓存器实例</span><br><span class="line">    private EmployeeCache() &#123;</span><br><span class="line">        employeeRefs = new Hashtable&lt;String, EmployeeRef&gt;();</span><br><span class="line">        q = new ReferenceQueue&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取得缓存器实例</span><br><span class="line">    public static EmployeeCache getInstance() &#123;</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            cache = new EmployeeCache();</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以软引用的方式对一个Employee对象的实例进行引用并保存该引用</span><br><span class="line">    private void cacheEmployee(Employee em) &#123;</span><br><span class="line">        cleanCache();// 清除垃圾引用</span><br><span class="line">        EmployeeRef ref = new EmployeeRef(em, q);</span><br><span class="line">        employeeRefs.put(em.getID(), ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 依据所指定的ID号，重新获取相应Employee对象的实例</span><br><span class="line">    public Employee getEmployee(String ID) &#123;</span><br><span class="line">        Employee em = null;</span><br><span class="line">       // 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。</span><br><span class="line">        if (employeeRefs.containsKey(ID)) &#123;</span><br><span class="line">            EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);</span><br><span class="line">            em = (Employee) ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">       // 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，</span><br><span class="line">       // 并保存对这个新建实例的软引用</span><br><span class="line">        if (em == null) &#123;</span><br><span class="line">            em = new Employee(ID);</span><br><span class="line">            System.out.println(&quot;Retrieve From EmployeeInfoCenter. ID=&quot; + ID);</span><br><span class="line">            this.cacheEmployee(em);</span><br><span class="line">        &#125;</span><br><span class="line">        return em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象</span><br><span class="line">    private void cleanCache() &#123;</span><br><span class="line">        EmployeeRef ref = null;</span><br><span class="line">        while ((ref = (EmployeeRef) q.poll()) != null) &#123;</span><br><span class="line">            employeeRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除Cache内的全部内容</span><br><span class="line">    public void clearCache() &#123;</span><br><span class="line">        cleanCache();</span><br><span class="line">        employeeRefs.clear();</span><br><span class="line">        //告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的</span><br><span class="line">        System.gc();</span><br><span class="line">        //强制调用已经失去引用的对象的finalize方法</span><br><span class="line">        System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当垃圾收集器认为没有指向对象实例的引用时，会在销毁该对象之前调用finalize()方法。</span><br><span class="line">     * 该方法最常见的作用是确保释放实例占用的全部资源。java并不保证定时为对象实例调用该方法，</span><br><span class="line">     * 甚至不保证方法会被调用，所以该方法不应该用于正常内存处理。</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/2 14:49</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private String id;// 雇员的标识号码</span><br><span class="line">    private String name;// 雇员姓名</span><br><span class="line">    private String department;// 该雇员所在部门</span><br><span class="line">    private String Phone;// 该雇员联系电话</span><br><span class="line">    private int salary;// 该雇员薪资</span><br><span class="line">    private String origin;// 该雇员信息的来源</span><br><span class="line"></span><br><span class="line">    // 构造方法</span><br><span class="line">    public Employee(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        getDataFromlnfoCenter();</span><br><span class="line">    &#125;</span><br><span class="line">    // 到数据库中取得雇员信息</span><br><span class="line">    private void getDataFromlnfoCenter() &#123;</span><br><span class="line">// 和数据库建立连接井查询该雇员的信息，将查询结果赋值</span><br><span class="line">// 给name，department，plone，salary等变量</span><br><span class="line">// 同时将origin赋值为&quot;From DataBase&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getID() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他需要注意到的地方：</p><ul><li>1、不要重复的创建相同的对象，对象的创建都是需要内存分配的，对象的销毁需要垃圾回收，这些都在一定程度上影响程序的性能</li><li>2、对常量使用static final修饰，对于基本类型和String类型的常量，建议使用常量static final 修饰，因为final类型的常量会在静态dex文件的域初始化部分，这时对基本数据类型和String类型常量的调用不会涉及类的初始化，而是直接调用字面量</li><li>3、避免内部的get set方法的调用，get set的作用是对以外屏蔽具体的变量定义，从而达到更好的封装性，如果在类的内部调用get set的方法访问变量的话，会降低访问的速度，根据在安卓的官方的文档，在没有jit编译器时，直接访问变量的速度是调用get方法的3倍，在jit编译器，直接访问变量是调用get方法的7倍，当然使用了ProGuard的话，perGuard会对get set 进行内联的操作，从而达到直接访问的效果</li></ul><p>关于JIT：</p><ul><li>JIT是”Just In Time Compiler”的缩写，就是”即时编译技术”，与Dalvik虚拟机相关,JIT是在2.2版本提出的，目的是为了提高Android的运行速度，一直存活到4.4版本，因为在4.4之后的ROM中，就不存在Dalvik虚拟机了。 </li><li>编译打包APK文件:1、Java编译器将应用中所有Java文件编译为class文件,2、dx工具将应用编译输出的类文件转换为Dalvik字节码，即dex文件</li><li>Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。<ul><li>dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要JIT编译，Dalvik虚拟机从Android一出生一直活到4.4版本，而JIT在Android刚发布的时候并不存在，在2.2之后才被添加到Dalvik中。</li></ul></li><li>AOT是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式。<ul><li>JIT是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik。</li></ul></li><li>ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。<ul><li>当然ART与Dalvik相比，还是有缺点的。<ul><li>ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%</li><li>由于有了一个转码的过程，所以应用安装时间难免会延长<ul><li>但是这些与更流畅的Android体验相比而言，不值一提。</li></ul></li></ul></li></ul></li></ul><h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><p>四种图片格式</p><ul><li><p>JPEG</p><ul><li>是一种广泛使用的有损压缩图像标准格式，它不支持透明和多帧动画，一般摄影的作品是JEPG格式的，通过控制压缩比，可以调整图片的大小</li></ul></li><li><p>PNG</p><ul><li>是一种无损压缩的图片格式，他支持完整的透明通道，从图片处理的领域来讲，JEPG只有RGB三个通道，而PNG有ARGB四个通道，因此PNG图片占用空间一般比较大，会无形的增加app的大小，在做app瘦身时一般都要对PNG图片进行梳理以减小其占用的体积</li></ul></li></ul><ul><li><p>GIF</p><pre><code>* 是一种古老的图片的格式，诞生于1987年，随着初代互联网流行开来，他的特别是支持多帧动画，表情图，</code></pre><ul><li>Webp<ul><li>google于2010年发布，支持有损和无损、支持完整的透明通道、也支持多帧动画，目前主流的APP都已经使用了Webp，淘宝，微信，即保证了图片的大小和质量</li></ul></li></ul></li></ul><ul><li>在安卓应用开发中能够使用编解码格式的只有三种 JEPG PNG WEBP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 在安卓应用开发中能够使用编解码格式的只有三种 JEPG PNG WEBP</span><br><span class="line">  */</span><br><span class="line"> public enum CompressFormat &#123;</span><br><span class="line">     JPEG    (0),</span><br><span class="line">     PNG     (1),</span><br><span class="line">     WEBP    (2);//安卓4.0后开始支持</span><br><span class="line"></span><br><span class="line">     CompressFormat(int nativeInt) &#123;</span><br><span class="line">         this.nativeInt = nativeInt;</span><br><span class="line">     &#125;</span><br><span class="line">     final int nativeInt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>推荐几种图片处理网站</p><ul><li>无损压缩ImageOptin，在不牺牲图片质量的前提下，即减下来PNG图片占用的空间，又提高了图片的加载速度  <a href="https://imageoptim.com/api" target="_blank" rel="noopener">https://imageoptim.com/api</a><br><img src="https://upload-images.jianshu.io/upload_images/5363507-6e976e35bf70ebbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="智图.png"></li></ul><ul><li><p>有损压缩ImageAlpha，图片大小得到极大的缩小，如果需要使用的话，一定要ui设计师看能否使用  <a href="https://pngmini.com/" target="_blank" rel="noopener">https://pngmini.com/</a></p></li><li><p>有损压缩TinyPNG 比较知名的png压缩的工具，也需要ui设计师看能够使用不  <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p></li><li><p>PNG/JPEG 转化为 wepb  ：智图  ：<a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></p></li></ul><p>如果ui设计师工作量不饱和的话，可以推荐， 尽量使用 .9.png 点9图   小黑点表示 可拉伸区域，黑边表示纵向显示内容的范围</p><p>####布局优化：如果创建的层级结构比较复杂，View树嵌套的层次比较深，那么将会使得页面的响应的时间变长，导致运行的时候越来越慢</p><ul><li>merge标签(对安卓的事件传递要达到源码级的熟悉才可以理解) 在某些场景下可以减少布局的层次,由于所有的Activity的根布局都是FrameLayout    Window   PhoneWindow  DecorView   事件的传递，包括设置setContentView 等的方法—&gt; 我会写一篇文章独立解释安卓事件的源码解析，会更加清楚的介绍这个类，(对安卓的事件传递要达到源码级的熟悉才可以理解)todo&lt;—–所以，当独立的一个布局文件最外层是FrameLayout的时候，并且和这个布局不需要设置 background 或者 padding的时候，可以使用<merge>标签来代替FrameLayout布局。另外一种的情况可以使用《merge》便签的情况是当前布局作为另外一个布局的子布局</merge></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &lt;include android:layout_height=&quot;50dp&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      layout=&quot;@layout/layout_include_merge&quot;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;merge 标签 在某些场景下可以减少布局的层次,由于所有的&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure><ul><li><p>在安卓中经常会使用到相同的布局，比如说title，最佳的实践的方法就是把相同的布局抽取出来，独立成一个xml文件，需要使用到的时候，就把这个布局include进来，不仅减少了代码量，而且修改这个相同的布局，只需要修改一个地方即可.</p></li><li><p>ViewStub 是一种不可见的并且大小为0的试图，它可以延迟到运行时才填充inflate 布局资源，当Viewstub设为可见或者是inflate的时候，就会填充布局资源，这个布局和普通的试图就基本上没有任何区别，比如说，加载网络失败，或者是一个比较消耗性能的功能，需要用户去点击才可以加载，参考我的开源的项目 <a href="https://www.jianshu.com/p/6746d68ef2c3" target="_blank" rel="noopener">WritingPen</a></p></li></ul><p>注意事项：如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点</p><p>###———-&gt;2018.6.7修正这个说法，以前我说的是错误的，根本上的原因是ViewStub设置了 inflateid ，这才是更本身的原因,对不起！搞错了，还是要看源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   &lt;ViewStub</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:inflatedId=&quot;@+id/find_view_stub&quot;</span><br><span class="line">        android:id=&quot;@+id/view_stub&quot;</span><br><span class="line">        android:layout=&quot;@layout/view_stub_imageview&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    &lt;!--如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点--&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:id=&quot;@+id/imageview&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p><p>调用todo: 2018/5/4 為啥為null  原因是布局文件中根布局只有View，没有ViewGroup，ViewStub.inflate() 的方法和 setVisibility 方法是差不多，因为 setVisibility方法会（看源码）走这个inflate的方法</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> if (null!=mViewStub.getParent())&#123;</span><br><span class="line">                    /*</span><br><span class="line">                    android:inflatedId 的值是Java代码中调用ViewStub的 inflate()或者是serVisibility方法返回的Id，这个id就是被填充的View的Id</span><br><span class="line">                     */</span><br><span class="line">                    /**</span><br><span class="line">                     * ViewStub.inflate() 的方法和 setVisibility 方法是差不多，因为 setVisibility方法会（看源码）走这个inflate的方法</span><br><span class="line">                     */</span><br><span class="line">//                    View inflate = mViewStub.inflate();</span><br><span class="line">                    mViewStub.setVisibility(View.VISIBLE);</span><br><span class="line">                    //inflate---&gt;android.support.v7.widget.AppCompatImageView&#123;de7e3a2 V.ED..... ......I. 0,0-0,0 #7f07003e app:id/find_view_stub&#125;</span><br><span class="line">//                    System.out.println(&quot;shiming inflate---&gt;&quot;+inflate);</span><br><span class="line">                    final View find_view_stub = findViewById(R.id.find_view_stub);</span><br><span class="line">                    System.out.println(&quot;shiming ----&quot;+find_view_stub);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    View iamgeivew11 = find_view_stub.findViewById(R.id.imageview);</span><br><span class="line">                    //himing ---- iamgeivew11null</span><br><span class="line">                    // TODO: 2018/5/4 為啥為null  原因是布局文件中根布局只有View，没有ViewGroup</span><br><span class="line">                    System.out.println(&quot;shiming ---- iamgeivew11&quot;+iamgeivew11);</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Toast.makeText(LayoutOptimizationActivity.this,&quot;已经inflate了&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">                    final View viewById = findViewById(R.id.find_view_stub);</span><br><span class="line">                    View iamgeivew = findViewById(R.id.imageview);</span><br><span class="line">                    //已经inflate了android.support.v7.widget.AppCompatImageView&#123;4637833 V.ED..... ........ 348,294-732,678 #7f07003e app:id/find_view_stub&#125;</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了&quot;+viewById);//</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了iamgeivew&quot;+iamgeivew);//已经inflate了iamgeivew==null</span><br><span class="line">                    View iamgeivew11 = viewById.findViewById(R.id.imageview);</span><br><span class="line">                    //已经inflate了 iamgeivew11null</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了 iamgeivew11&quot;+iamgeivew11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><ul><li>尽量使用CompoundDrawable,如果存在相邻的ImageView和TextView 的话</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;150dp&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;我是文字&quot;</span><br><span class="line">        android:drawableBottom=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:text=&quot;我是title2&quot;</span><br><span class="line">       android:drawableEnd=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:drawableRight=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;我是文字33&quot;</span><br><span class="line">        android:drawableLeft=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:drawableStart=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:drawableTop=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:text=&quot;我是文字3&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5363507-796b8e15dd7eda3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><ul><li>使用Lint 检查代码，和布局是否可以存在优化的地方，我会写个简单的经常遇见过的问题，同时完成一篇文档，加以说明,地址<a href="https://www.jianshu.com/p/d6068542b00b" target="_blank" rel="noopener">Lint的使用（安卓性能提升必备掌握的工具）</a></li></ul><h4 id="网络优化-移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量"><a href="#网络优化-移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量" class="headerlink" title="网络优化. 移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量"></a>网络优化. 移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量</h4><ul><li>2018年7月2日增加上网过程的说明流程（最近面试别人，发现好多同学这个都说的不太明白，特此说明下）：对于普通的上网，系统是这样做的：浏览器本身就是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应域名的对应的Ip地址，通过IP地址找到对应Ip对应的服务器，要求建立TCP连接，等浏览器发送完HTTP Request包后，服务器接受到请求包之后才开始处理请求包，服务器调用自身服务，返回Http Response （响应包）：客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body）,等收到全部的内容随后断开与该服务器之间的TCP连接。具体的文章在这里<a href="https://www.jianshu.com/p/84aa55a8a7eb" target="_blank" rel="noopener">Web工作的方式</a></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-8f5601da0c982aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图解"></p><ul><li>DNS域名的系统，主要的功能根据应用请求所用的域名URL去网络上面映射表中查相对应的IP地址，这个过程有可能会消耗上百毫秒，而且可能存在着DNS劫持的危险，可以替换为Ip直接连接的方式来代替域名访问的方法，从而达到更快的网络请求，但是使用Ip地址不够灵活，当后台变换了Ip地址的话，会出现访问不了，前段的App需要发包，解决方法是增加Ip地址动态更新的能力，或者是在IP地址访问失败了，切换到域名的访问.</li></ul><p>Demo—&gt;ping 一个地址，不正确的话，切换到备用的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> boolean ping = ping(&quot;wwww.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 测试主域名是否可用</span><br><span class="line">    *</span><br><span class="line">    * @param ip</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private final int PING_TIME_OUT = 1000; // ping 超时时间</span><br><span class="line">   private boolean ping(String ip) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Integer status = executeCommandIp( ip, PING_TIME_OUT );</span><br><span class="line">           if ( status != null &amp;&amp; status == 0 ) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (TimeoutException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">  /**</span><br><span class="line">    * 执行域名是否可通</span><br><span class="line">    * @param command</span><br><span class="line">    * @param timeout</span><br><span class="line">    * @return</span><br><span class="line">    * @throws IOException</span><br><span class="line">    * @throws InterruptedException</span><br><span class="line">    * @throws TimeoutException</span><br><span class="line">    */</span><br><span class="line">   private int executeCommandIp( final String command, final long timeout )</span><br><span class="line">           throws IOException, InterruptedException, TimeoutException &#123;</span><br><span class="line">       Process process = Runtime.getRuntime().exec(</span><br><span class="line">               &quot;ping -c 1 -w 100 &quot; + command);</span><br><span class="line">       mWorker = new PingWorker(process);</span><br><span class="line">       mWorker.start();</span><br><span class="line">       try &#123;</span><br><span class="line">           mWorker.join(timeout);</span><br><span class="line">           if (mWorker.exit != null) &#123;</span><br><span class="line">               return mWorker.exit;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //throw new TimeoutException();</span><br><span class="line">               return -1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">           mWorker.interrupt();</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">           throw ex;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           process.destroy();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>PingWorker 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PingWorker extends Thread &#123;</span><br><span class="line">       private final Process process;</span><br><span class="line">       private Integer exit;</span><br><span class="line">       private String ip;</span><br><span class="line"></span><br><span class="line">       public PingWorker(Process process) &#123;</span><br><span class="line">           this.process = process;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               exit = process.waitFor();</span><br><span class="line">               if (exit == 0) &#123;</span><br><span class="line">                   BufferedReader buf = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">                   String str = new String();</span><br><span class="line">                   StringBuffer ipInfo = new StringBuffer();</span><br><span class="line"></span><br><span class="line">                   //读出所有信息并显示</span><br><span class="line">                   while((str=buf.readLine())!=null) &#123;</span><br><span class="line">                       ipInfo.append(str);</span><br><span class="line">                   &#125;</span><br><span class="line">                   /*</span><br><span class="line">                   PING sni1st.dtwscache.ourwebcdn.com (14.215.228.4) 56(84) bytes of data.64 bytes from 14.215.228.4: icmp_seq=1 ttl=57 time=16.6 ms--- sni1st.dtwscache.ourwebcdn.com ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 16.656/16.656/16.656/0.000 ms</span><br><span class="line">                    */</span><br><span class="line">                   System.out.println(&quot;shiming ipInfo-----&gt;&quot;+ipInfo);</span><br><span class="line">                   Pattern mPattern = Pattern.compile(&quot;\\((.*?)\\)&quot;);</span><br><span class="line">                   Matcher matcher = mPattern.matcher(ipInfo.toString());</span><br><span class="line">                   if ( matcher.find() ) &#123;</span><br><span class="line">                       ip = matcher.group( 1 );</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   ip = &quot; process.waitFor()===&quot;+exit;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               ip=&quot;java.io.IOException: Stream closed&quot;;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           catch (InterruptedException e) &#123;</span><br><span class="line">               ip=&quot;java.io.InterruptedException: Stream closed&quot;;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>合并网络请求，一次完整的Http请求，首先进行的是DNS查找，通过TCP三次握手，从而建立连接，如果是https请求的话，还要经过TLS握手成功后才可以进行连接，对于网络请求，减少接口，能够合并的网络请求就尽量合并</p><ul><li>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li></ul><p>HTTPS和HTTP的区别主要为以下四点：</p><ul><li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li></ul></li><li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li><li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><ul><li><p>预先获取数据能够将网络请求集中在一次，这样其他时间段手机就可以切换到空闲的时间，从而避免经常性的唤醒，从而节约用电</p></li><li><p>避免轮询：如果说每个一段时间需要向服务器发起主动的网络请求，其实不建议在app端做这样的操作，可以使用推送，如果说在不得已的情况下，也要避免使用Thread.sleep()函数来循环等待，建议使用系统的AlarmManager来实现定时轮询，AlarmManager 可以保证在系统休眠的时候，CPU也可以得到休息，在下一次需要发起网络球球的时候才唤醒</p></li><li><p>尽量避免网络请求失败时候，无限制的循环重试连接，在我第一篇简书博客有写过一个网络加载的框架 ：<a href="https://www.jianshu.com/p/141ee58eb143" target="_blank" rel="noopener">https://www.jianshu.com/p/141ee58eb143</a>    中有提到过</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//基于Rxjava 和 RxAndroid Retorfit</span><br><span class="line">        o.subscribeOn(Schedulers.io())</span><br><span class="line">              .retryWhen(new RetryWhenHandler(1, 5))</span><br><span class="line">              .doOnSubscribe(new Action0() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void call() &#123;</span><br><span class="line">                      s.onBegin();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .subscribeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .unsubscribeOn(Schedulers.io())</span><br><span class="line">              .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .subscribe(s);</span><br></pre></td></tr></table></figure></li><li><p>离线缓存，对于图片或者文件，内存缓存+磁盘缓存+网络缓存，一般我们本地需要做的是二级缓存，当缓存中存在图片或者是文件，直接从缓存中读取，不会走网络，下载图片，在Android中使用LruCache实现内存缓存，<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a>实现本地缓存</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 图片缓存的核心类</span><br><span class="line">  */</span><br><span class="line"> private LruCache&lt;String, Bitmap&gt; mLruCache;</span><br><span class="line"> // 缓存大小</span><br><span class="line"> private static final int CACHE_MAX_SIZE = 1024;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</span><br><span class="line">  */</span><br><span class="line"> private void lruCacheDemo() &#123;</span><br><span class="line">     // 获取应用程序最大可用内存</span><br><span class="line">     int maxMemory = (int) Runtime.getRuntime().maxMemory();</span><br><span class="line">     //设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</span><br><span class="line">     int cacheSize = maxMemory / 8;</span><br><span class="line">     mLruCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">         //重写sizeOf方法，计算出要缓存的每张图片的大小</span><br><span class="line">         //这个方法要特别注意，跟我们实例化 LruCache 的 maxSize 要呼应，怎么做到呼应呢，比如 maxSize 的大小为缓存的个数，这里就是 return 1就 ok，如果是内存的大小，如果5M，这个就不能是个数 了，这是应该是每个缓存 value 的 size 大小，如果是 Bitmap，这应该是 bitmap.getByteCount();</span><br><span class="line">         @Override</span><br><span class="line">         protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">             return value.getRowBytes() * value.getHeight();</span><br><span class="line">         &#125;</span><br><span class="line">         ////这里用户可以重写它，实现数据和内存回收操作</span><br><span class="line">         @Override</span><br><span class="line">         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123;</span><br><span class="line">             if (oldValue != newValue) &#123;</span><br><span class="line">                 oldValue.recycle();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 从LruCache中获取一张图片，如果不存在就返回null。</span><br><span class="line">  */</span><br><span class="line"> private Bitmap getBitmapFromLruCache(String key) &#123;</span><br><span class="line">     return mLruCache.get(key);</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 往LruCache中添加一张图片</span><br><span class="line">  *</span><br><span class="line">  * @param key</span><br><span class="line">  * @param bitmap</span><br><span class="line">  */</span><br><span class="line"> private void addBitmapToLruCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">     if (getBitmapFromLruCache(key) == null) &#123;</span><br><span class="line">         if (bitmap != null)</span><br><span class="line">             mLruCache.put(key, bitmap);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>压缩数据的大小：可以对发送服务端数据进行gzip压缩，同时可以使用更优的数据传输格式，例如二进制的代替Json格式，这个比较牛逼，估计运用的很少，使用webp格式代替图片格式</li></ul><ul><li>不同的网络环境使用不同的超时策略，常见的网络格式有 2g、3g、4g、wifi,实时的更新当前的网络状态，通过监听来获取最新的网络类型，并动态调整网络超时的时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void netWorkDemo() &#123;</span><br><span class="line">       TextView netWork = findViewById(R.id.net_work);</span><br><span class="line">       boolean networkConnected = NetworkUtils.isNetworkConnected(this);</span><br><span class="line">       int networkType = NetworkUtils.getNetworkType(this);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;shiming 是否联网了&quot;+networkConnected);</span><br><span class="line">       switch (networkType)&#123;</span><br><span class="line">           case TYPE_UNKNOWN:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---无网络连接&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---无网络连接&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_2G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---2G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---2G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_3G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_3G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_3G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_4G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_4G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_4G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_WIFI:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_WIFI&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_WIFI&quot;);</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>NetworkUtils 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.performanceoptimization.network_optimization;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.net.ConnectivityManager;</span><br><span class="line">import android.net.NetworkInfo;</span><br><span class="line">import android.telephony.TelephonyManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/28 10:52</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * des:网络连接工具类</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class NetworkUtils &#123;</span><br><span class="line">    private static final String SUBTYPE_TD_SCDMA = &quot;SCDMA&quot;;</span><br><span class="line">    private static final String SUBTYPE_WCDMA = &quot;WCDMA&quot;;</span><br><span class="line">    private static final String SUBTYPE_CDMA2000 = &quot;CDMA2000&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否已连接到网络.</span><br><span class="line">     *</span><br><span class="line">     * @param context Context</span><br><span class="line">     * @return 是否已连接到网络</span><br><span class="line">     */</span><br><span class="line">    public static boolean isNetworkConnected(Context context) &#123;</span><br><span class="line">        ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context</span><br><span class="line">                .CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivity != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivity.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isConnected()) &#123;</span><br><span class="line">                if (info.getState() == NetworkInfo.State.CONNECTED) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前网络类型</span><br><span class="line">     *</span><br><span class="line">     * @param context Context</span><br><span class="line">     * @return 当前网络类型(Unknown, 2G, 3G, 4G, WIFI)</span><br><span class="line">     */</span><br><span class="line">    public static int getNetworkType(Context context) &#123;</span><br><span class="line">        NetworkInfo info = ((ConnectivityManager) context.getSystemService(</span><br><span class="line">                Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();</span><br><span class="line">        if (info != null &amp;&amp; info.isConnected()) &#123;</span><br><span class="line">            if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">                return NetworkType.TYPE_WIFI;</span><br><span class="line">            &#125; else if (info.getType() == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">                switch (info.getSubtype()) &#123;</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_GPRS:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EDGE:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_CDMA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_1xRTT:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_IDEN: //api&lt;8 : replace by 11</span><br><span class="line">                        return NetworkType.TYPE_2G;</span><br><span class="line"></span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_UMTS:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_0:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_A:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSDPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSUPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_B: //api&lt;9 : replace by 14</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EHRPD:  //api&lt;11 : replace by 12</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSPAP:  //api&lt;13 : replace by 15</span><br><span class="line">                        return NetworkType.TYPE_3G;</span><br><span class="line"></span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_LTE:    //api&lt;11 : replace by 13</span><br><span class="line">                        return NetworkType.TYPE_4G;</span><br><span class="line"></span><br><span class="line">                    default:</span><br><span class="line">                        // http://baike.baidu.com/item/TD-SCDMA 中国移动 联通 电信 三种3G制式</span><br><span class="line">                        String subtypeName = info.getSubtypeName();</span><br><span class="line">                        if (SUBTYPE_TD_SCDMA.equalsIgnoreCase(subtypeName) ||</span><br><span class="line">                                SUBTYPE_WCDMA.equalsIgnoreCase(subtypeName) ||</span><br><span class="line">                                SUBTYPE_CDMA2000.equalsIgnoreCase(subtypeName)) &#123;</span><br><span class="line">                            return NetworkType.TYPE_3G;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return NetworkType.TYPE_UNKNOWN;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NetworkType.TYPE_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>NetworkType类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.performanceoptimization.network_optimization;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/28 10:52</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * des:网络连接类型常量</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class NetworkType &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 无网络连接</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_UNKNOWN = -1;</span><br><span class="line">    /**</span><br><span class="line">     * 2G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_2G = 0;</span><br><span class="line">    /**</span><br><span class="line">     * 3G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_3G = 1;</span><br><span class="line">    /**</span><br><span class="line">     * 4G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_4G = 2;</span><br><span class="line">    /**</span><br><span class="line">     * WIFI</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_WIFI = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li></ul><p>####电量优化</p><ul><li><p>1、（BroadCastReceiver）为了减少应用耗损的电量，我们在代码中尽量避免使用无用的操作代码，当应用退到后台了，一切页面的刷新都是没有意义的，并且浪费电，比如有个监听网络状态的广播并执行一些动作，弹窗或者是Toast，那么app需要在后台的时候，禁用掉这个功能，</p></li><li><p>2、数据传输    蓝牙传输，Wi-Fi传输  移动网络传输  后台数据的管理：根据业务需求，接口尽量避免无效数据的传输  数据传输的频度问题：通过经验值或者是数据统计的方法确定好数据传输的频度，避免冗余重复的数据传输，数据传输过程中要压缩数据的大小，合并网络请求，避免轮询</p></li><li><p>3、位置服务 正确的使用位置复位，是应用耗电的一个关键     </p><ul><li><p>需要注意以下的三点：</p><ul><li>1、有没有及时注销位置监听器：和广播差不多<ul><li>2、位置更新监听频率的设定；更加业务需求设置一个合理的更新频率值，<ul><li>minTime:用来指定间更新通知的最小的时间间隔，单位是毫秒，看日志这里是1s更新的</li><li>minDistance:用来指定位置更新通知的最小的距离，单位是米</li></ul></li></ul></li></ul><ul><li>3、Android提供了三种定位<ul><li>GPS定位，通过GPS实现定位，精度最高，通常在10米（火星坐标），但是GPS定位在时间和电量上消耗也是最高的</li><li>网络定位，通过移动通信的基站信号差异来计算出手机所在的位置，精度比GPS差好多</li><li>被动定位，最省电的定位服务，如果使用被动定位服务。说明它想知道位置更新信息但有不主动获取，等待手机中其他应用或者是服务或者是系统组件发出定位请求，并和这些组件的监听器一起接收位置的信息，实际的开发中，一般使用的是第三方的地图，高德，腾讯，百度，他们做了很好的封装，同时在地图上的表现上更加的优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">        /**</span><br><span class="line">         *   //设置定位精确度 Criteria.ACCURACY_COARSE比较粗略，Criteria.ACCURACY_FINE则比较精细</span><br><span class="line">         *         criteria.setAccuracy(Criteria.ACCURACY_FINE);</span><br><span class="line">         *         //设置是否要求速度</span><br><span class="line">         *         criteria.setSpeedRequired(false);</span><br><span class="line">         *         // 设置是否允许运营商收费</span><br><span class="line">         *         criteria.setCostAllowed(false);</span><br><span class="line">         *         //设置是否需要方位信息</span><br><span class="line">         *         criteria.setBearingRequired(false);</span><br><span class="line">         *         //设置是否需要海拔信息</span><br><span class="line">         *         criteria.setAltitudeRequired(false);</span><br><span class="line">         *         // 设置对电源的需求</span><br><span class="line">         *         criteria.setPowerRequirement(Criteria.POWER_LOW);</span><br><span class="line">         */</span><br><span class="line">        Criteria criteria = new Criteria();</span><br><span class="line">        criteria.setAccuracy(Criteria.ACCURACY_FINE);</span><br><span class="line">        criteria.setAltitudeRequired(false);</span><br><span class="line">        criteria.setBearingRequired(false);</span><br><span class="line">        criteria.setCostAllowed(true);</span><br><span class="line">        criteria.setPowerRequirement(Criteria.POWER_LOW);</span><br><span class="line">        String serviceName = Context.LOCATION_SERVICE;</span><br><span class="line">        mLocationManager = (LocationManager) getSystemService(serviceName);</span><br><span class="line">//        locationManager.setTestProviderEnabled(&quot;gps&quot;, true);</span><br><span class="line">        // TODO: 2018/5/3 IllegalArgumentException &apos;Provider &quot;gps&quot; unknown&quot;   https://www.cnblogs.com/ok-lanyan/archive/2011/10/12/2208378.html</span><br><span class="line">        mLocationManager.addTestProvider(LocationManager.GPS_PROVIDER,</span><br><span class="line">                &quot;requiresNetwork&quot; == &quot;&quot;, &quot;requiresSatellite&quot; == &quot;&quot;, &quot;requiresCell&quot; == &quot;&quot;, &quot;hasMonetaryCost&quot; == &quot;&quot;,</span><br><span class="line">                &quot;supportsAltitude&quot; == &quot;&quot;, &quot;supportsSpeed&quot; == &quot;&quot;,</span><br><span class="line">                &quot;supportsBearing&quot; == &quot;&quot;, android.location.Criteria.POWER_LOW,</span><br><span class="line">                android.location.Criteria.ACCURACY_FINE);</span><br><span class="line">        mProvider = mLocationManager.getBestProvider(criteria, true);</span><br><span class="line"></span><br><span class="line">        //获取纬度</span><br><span class="line">        //获取经度</span><br><span class="line">        mLlistener = new LocationListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onLocationChanged(Location location) &#123;</span><br><span class="line">                // thread is not runable, msg ignore, state:TIMED_WAITING, 这里的线程有可能ANR</span><br><span class="line">                if (location != null) &#123;</span><br><span class="line">                    double lat = location.getLatitude();//获取纬度</span><br><span class="line">                    double lng = location.getLongitude();//获取经度</span><br><span class="line">                    System.out.println(&quot;shiming   lat+&quot; + lat);</span><br><span class="line">                    System.out.println(&quot;shiming   lng+&quot; + lng);</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    mCount++;</span><br><span class="line">                    System.out.println(&quot;当前线程的位置name---&quot;+name+&quot;i===&quot;+mCount);</span><br><span class="line">                    mTv_location.setText(&quot;位置信息是2s变动的，可以设置,我是第&quot;+mCount+&quot;次变动的---&gt;&quot;+&quot;\n\r&quot;+&quot;lat====&quot;+lat+&quot;      lng-----&gt;&quot;+lng);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mLocationManager!=null) &#123;</span><br><span class="line">                    mLocationManager.removeUpdates(this);</span><br><span class="line">                    if (mLocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) &#123;</span><br><span class="line">                        mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 2000, 1000, mLlistener);</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 2000, 1000, mLlistener);</span><br><span class="line">                    &#125;</span><br><span class="line">//                     TODO: 2018/5/3  这里在报错了，我把他注释掉</span><br><span class="line">//                mLocationManager.setTestProviderEnabled(mProvider, false);//   java.lang.IllegalArgumentException: Provider &quot;network&quot; unknown</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProviderDisabled(String provider) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProviderEnabled(String provider) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStatusChanged(String provider, int status,</span><br><span class="line">                                        Bundle extras) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        /**</span><br><span class="line">         * minTime:用来指定间更新通知的最小的时间间隔，单位是毫秒，看日志这里是1s更新的</span><br><span class="line">         * minDistance:用来指定位置更新通知的最小的距离，单位是米</span><br><span class="line">         */</span><br><span class="line">        mLocationManager.requestLocationUpdates(mProvider, 2000, (float) 1000.0, mLlistener);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><p>在OnDestroy 变量手动值为null，我在测试过程中，只有在值为null的时候这个位置监听才会停止，有兴趣的小伙伴，可以好好看看值为null，底层会做什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 记得需要销毁这个监听,</span><br><span class="line">     * todo 如果不手动置为null的话，其实您可以通过日记发现，这个监听还是一直在走的，所以说这里手动值为null的好处</span><br><span class="line">     */</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (mAm!=null)&#123;</span><br><span class="line">            mAm.cancel(mPi);</span><br><span class="line">            mAm=null;//变为null</span><br><span class="line">        &#125;</span><br><span class="line">        if (null!=mTag)&#123;</span><br><span class="line">            mTag.release();</span><br><span class="line">            //释放唤醒锁锁</span><br><span class="line">            mTag=null;</span><br><span class="line">        &#125;</span><br><span class="line">        mLocationManager.removeUpdates(mLlistener);</span><br><span class="line">        if (mLocationManager != null) &#123;</span><br><span class="line">            mLocationManager.removeUpdates(mLlistener);</span><br><span class="line">            mLocationManager = null;//不用分配空间</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLlistener != null) &#123;</span><br><span class="line">            mLlistener = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //   mLocationManager.setTestProviderEnabled(mProvider, false);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><ul><li>WakeLock 是为了保持设备的唤醒状态的API，组织用户长时间不用，仍然需要组织设备进入休眠的状态，比如用户在看电影的时候。使用wakelock 时，需要及时的释放锁，比如播放视屏的时候WakeLock保持屏幕的常亮，在暂停的时候就应该释放锁，而不是等到停止播放才释放。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> @SuppressLint(&quot;WakelockTimeout&quot;)</span><br><span class="line">    private void wakeLockDemo() &#123;</span><br><span class="line">//        PowerManager.PARTIAL_WAKE_LOCK;//保持CPU正常运转，但屏幕和键盘灯有可能是关闭的</span><br><span class="line">//        PowerManager.SCREEN_DIM_WAKE_LOCK://保持CPU正常运转，允许屏幕点亮但可能是置灰的，键盘灯可能是关闭的</span><br><span class="line">//        PowerManager.SCREEN_BRIGHT_WAKE_LOCK;//保持CPU正常的运转，允许屏幕高亮显示，键盘灯可能是关闭的</span><br><span class="line">//        PowerManager.FULL_WAKE_LOCK;//保持CPU正常运转，保持屏幕高亮显示，键盘灯也保持连读</span><br><span class="line">//        PowerManager.ACQUIRE_CAUSES_WAKEUP;//强制屏幕和键盘灯亮起，这种锁针对必须通知用户的操作</span><br><span class="line">//        PowerManager.ON_AFTER_RELEASE;//当WakeLock被释放了，继续保持屏幕和键盘灯开启一定的时间</span><br><span class="line">        PowerManager powerManager = (PowerManager) this.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        /**</span><br><span class="line">         *   case PARTIAL_WAKE_LOCK:</span><br><span class="line">         *             case SCREEN_DIM_WAKE_LOCK:</span><br><span class="line">         *             case SCREEN_BRIGHT_WAKE_LOCK:</span><br><span class="line">         *             case FULL_WAKE_LOCK:</span><br><span class="line">         *             case PROXIMITY_SCREEN_OFF_WAKE_LOCK:</span><br><span class="line">         *             case DOZE_WAKE_LOCK:</span><br><span class="line">         *             case DRAW_WAKE_LOCK:</span><br><span class="line">         */</span><br><span class="line">        mTag = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;Tag&quot;);</span><br><span class="line">        if (null!= mTag)&#123;</span><br><span class="line">            mTag.acquire();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>AlarmManager 也是比较耗电的，通常情况下需要保证两次唤醒操作的时间间隔不要太短了，在不需要使用唤醒功能的情况下，尽早的取消唤醒功能，否则应用会一直消耗电量 AlarmManager 是SDK提供的一个唤醒的APi，是系统级别的服务，可以在特定的时刻广播一个指定的Intent，这个pendingIntent可以用来启动Activity、Service、BroadcastReceiver， app，在后台也会启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  private void alarmManager() &#123;</span><br><span class="line">        //创建Intent对象，action为ELITOR_CLOCK，附加信息为字符串“你该打酱油了”</span><br><span class="line">        Intent intent = new Intent(&quot;action&quot;);</span><br><span class="line">        intent.putExtra(&quot;msg&quot;,&quot;重启---App ---Le  -- 回到前台&quot;);</span><br><span class="line">//        intent.setClass(ElectricQuantityOptimizationActivity.this,MainActivity.class);</span><br><span class="line">        //定义一个PendingIntent对象，PendingIntent.getBroadcast包含了sendBroadcast的动作。</span><br><span class="line">        //也就是发送了action 为&quot;action&quot;的intent</span><br><span class="line">        mPi = PendingIntent.getBroadcast(this,0,intent,0);</span><br><span class="line"></span><br><span class="line">       //AlarmManager对象,注意这里并不是new一个对象，Alarmmanager为系统级服务</span><br><span class="line">        mAm = (AlarmManager)getSystemService(ALARM_SERVICE);</span><br><span class="line"></span><br><span class="line">       //设置闹钟从当前时间开始，每隔5s执行一次PendingIntent对象pi，注意第一个参数与第二个参数的关系</span><br><span class="line">        // 5秒后通过PendingIntent pi对象发送广播</span><br><span class="line">        assert mAm != null;</span><br><span class="line">        /**</span><br><span class="line">         * 频繁的报警对电池寿命不利。至于API 22，警报管理器将覆盖近期和高频报警请求，</span><br><span class="line">         * 在未来至少延迟5秒的警报，并确保重复间隔至少为60秒,如果真的需要间隔很短的话，官方建议使用handler</span><br><span class="line">         * 该方法用于设置重复闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟首次执行时间，</span><br><span class="line">         * 第三个参数表示闹钟两次执行的间隔时间，第三个参数表示闹钟响应动作。</span><br><span class="line">         */</span><br><span class="line">        mAm.setRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),1000, mPi);</span><br><span class="line">        //该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。</span><br><span class="line">        //am.set(AlarmManager.RTC_WAKEUP,100000,pi);</span><br><span class="line">        /**</span><br><span class="line">         * （1）int type： 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP。AlarmManager.ELAPSED_REALTIME表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3；</span><br><span class="line">         * AlarmManager.ELAPSED_REALTIME_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.RTC表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.RTC_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.POWER_OFF_WAKEUP表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</span><br><span class="line">         */</span><br><span class="line">        //该方法也用于设置重复闹钟，与第二个方法相似，不过其两个闹钟执行的间隔时间不是固定的而已。</span><br><span class="line">        //基本上相似,只不过这个方法优化了很多,省电</span><br><span class="line">        // am.setInexactRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),1000,pi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:28</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        String msg = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        System.out.println(&quot;shiming &quot;  +  msg) ;</span><br><span class="line">        Toast.makeText(context,msg,Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">//        ElectricQuantityOptimizationActivity context1 = (ElectricQuantityOptimizationActivity) context;</span><br><span class="line">//        context1.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供一个Demo，当app崩溃了，通过AlarmManager来重启App的功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:28</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static CrashHandler mAppCrashHandler;</span><br><span class="line"></span><br><span class="line">    private Thread.UncaughtExceptionHandler mDefaultHandler;</span><br><span class="line"></span><br><span class="line">    private MyApplication mAppContext;</span><br><span class="line"></span><br><span class="line">    public void initCrashHandler(MyApplication application) &#123;</span><br><span class="line">        this.mAppContext = application;</span><br><span class="line">        // 获取系统默认的UncaughtException处理器</span><br><span class="line">        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static CrashHandler getInstance() &#123;</span><br><span class="line">        if (mAppCrashHandler == null) &#123;</span><br><span class="line">            mAppCrashHandler = new CrashHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return mAppCrashHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        AlarmManager mgr = (AlarmManager) mAppContext.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">        Intent intent = new Intent(mAppContext, MainActivity.class);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        intent.putExtra(&quot;crash&quot;, true);</span><br><span class="line">        System.out.println(&quot;shiming -----》重启应用了哦&quot;);</span><br><span class="line">        PendingIntent restartIntent = PendingIntent.getActivity(mAppContext, 0, intent, PendingIntent.FLAG_ONE_SHOT);</span><br><span class="line">        mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 5000, restartIntent); // 1秒钟后重启应用</span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">        System.exit(0);</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>程序会重新启动，如果点击电量优化，App崩溃了，请给与全部权限，还要在开发者模式里面给与位置信息模拟的设置，如果崩溃了， 你也可以发现app会自动的重新启动，这是AlarmManager的应用，注意看MyApplication里面的代码，tks<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:48</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class MyApplication  extends Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        /**</span><br><span class="line">         * 程序会重新启动，如果点击电量优化，App崩溃了，请给与全部权限，</span><br><span class="line">         * 还要在开发者模式里面给与位置信息模拟的设置，如果崩溃了，</span><br><span class="line">         * 你也可以发现app会自动的重新启动，这是AlarmManager的应用，注意看MyApplication里面的代码，tks</span><br><span class="line">         */</span><br><span class="line">       CrashHandler.getInstance().initCrashHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>###以上就是个人总结的基本，总结的不太全面，同时也不太详细，如果可以的话，还请给个小星星，表示鼓励，谢谢了☺☺☺</p><p>###git地址<a href="https://github.com/Shimingli/PerformanceOptimizationForAndroid" target="_blank" rel="noopener">PerformanceOptimizationForAndroid</a></p>]]></content>
      
      
        <tags>
            
            <tag> 安卓代码、图片、布局、网络和电量优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lint的使用（安卓性能提升必备掌握的工具）</title>
      <link href="/2018/05/05/Lint%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%BF%85%E5%A4%87%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%89/"/>
      <url>/2018/05/05/Lint%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E6%8F%90%E5%8D%87%E5%BF%85%E5%A4%87%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%B7%A5%E5%85%B7%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="什么是-Lint"><a href="#什么是-Lint" class="headerlink" title="什么是 Lint"></a>什么是 Lint</h2><p>Lint 是Android Studio 提供的 <strong>代码扫描分析工具</strong>，它可以帮助我们发现代码结构/质量问题，同时提供一些解决方案，而且这个过程不需要我们手写测试用例。</p><p>Lint 发现的每个问题都有描述信息和等级（和测试发现 bug 很相似），我们可以很方便地定位问题，同时按照严重程度进行解决。</p><p>当然这个“严重程度”我们可以手动调节，有些原则问题不容侵犯，必须提升到 error，而有的个别问题也可以无视，毕竟人非圣贤孰能无过嘛。<br><a id="more"></a></p><h2 id="Lint-工作方式简单介绍"><a href="#Lint-工作方式简单介绍" class="headerlink" title="Lint 工作方式简单介绍"></a>Lint 工作方式简单介绍</h2><p>Lint 会根据预先配置的检测标准检查我们 Android 项目的源文件，发现潜在的 bug 或者可以优化的地方，优化的内容主要包括以下几方面：</p><ul><li>Correctness：不够完美的编码，比如硬编码、使用过时 API 等</li><li>Performance：对性能有影响的编码，比如：静态引用，循环引用等</li><li>Internationalization：国际化，直接使用汉字，没有使用资源引用等</li><li>Security：不安全的编码，比如在 WebView 中允许使用 JavaScriptInterface 等</li><li>…<h2 id="Android-Studio-中使用-Lint"><a href="#Android-Studio-中使用-Lint" class="headerlink" title="Android Studio 中使用 Lint"></a>Android Studio 中使用 Lint</h2>1、<br><img src="https://upload-images.jianshu.io/upload_images/5363507-92ee4366d54c50b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>2、<br><img src="https://upload-images.jianshu.io/upload_images/5363507-153c7217f041a5c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png">/3、<br><img src="https://upload-images.jianshu.io/upload_images/5363507-6f14d8059a5c2fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><h2 id="拿一个以前的项目的分析结果"><a href="#拿一个以前的项目的分析结果" class="headerlink" title="拿一个以前的项目的分析结果"></a>拿一个以前的项目的分析结果</h2></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-57cec658c6cdd634.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210246.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-5e4fbd4975e4c859.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210312.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-067fafdd49c2c1ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210315.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-828b47ade1709a9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210319.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-688c16f15234094e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210324.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-d072a52eee950018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210328.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-5968e53780fc9dc3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210331.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-9ede476901b5a0b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210334.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4a062ded33a100ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210337.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-ba396d5266a7121e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210342.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-09a04ff9a27664fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210345.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-327b0a6db096ef9b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20180503210427.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-6e4d2db0c47ada54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104272.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-307f1fc85893e20f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104273.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-3eb30fb8b8463717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104274.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-287bf1185835a8c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104275.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-aee6445b7413f466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104276.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-c026fc5d44695074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104277.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-6bf5a1038f6e82ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104278.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-56e12a56c983eb5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_201805032104279.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-5b8afbe53a150096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042710.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-61763560ce2647a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042711.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-5349e67b4137e147.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042712.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-06237a29af38aa35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042713.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-abbb3fccf5d9715b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042715.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-090a65c5936c25a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042716.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-b8d35b138339bd27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042717.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4d7710ea813724d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042718.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-7c308b7b511cf4b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042719.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-f8ca1641e8f4717a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042720.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-326bbd34b0b27cf4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042721.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-981e758b0a841c16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042722.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-010de004372e61a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042723.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-dc886a8e7f6407db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042724.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-85a49ae448ad0622.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042725.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-ada6b048ce31fe39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042726.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4435d020c74c07fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042728.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-1ffddd8f8e5cdcd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042729.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-67976b5e395d92df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042730.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-7c0a5003bfbbca37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042731.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-1270e8f3c511090d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042732.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-f59a22fe820f2c30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042733.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-1c997c8c024a162f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042734.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-e1c1040785150ff5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042735.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-fbc31b100749deef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042736.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-bef2edf3bbe9164d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042737.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-e033fffdbf267628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_2018050321042738.png"></p><h2 id="以上就是基本的用法和分析，谢谢"><a href="#以上就是基本的用法和分析，谢谢" class="headerlink" title="以上就是基本的用法和分析，谢谢"></a>以上就是基本的用法和分析，谢谢</h2>]]></content>
      
      
        <tags>
            
            <tag> Lint的使用 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>注解（Annotation） by Thinking in Java</title>
      <link href="/2018/04/27/Java/"/>
      <url>/2018/04/27/Java/</url>
      <content type="html"><![CDATA[<p>###注解（元数据）为我们在代码中添加信息提供了一种形式化的方法，使我们可以在某个时刻非常方便的使用这些数据（受到了C#的启发 C#覆盖一个方法必须使用@Override，但是java不是必选的）</p><p> java SE5重要的语言的变化</p><ul><li>注解使得我们的能够以将有编译器来测试和验证的格式，存储有关程序的额外的信息</li><li>注解可以用来生成描述符文件，甚至或是新的类定义，并有助于减轻编写样板代码的的负担</li><li>使用注解，我们可以将这些元数据保存在Java代码中，并利用 annotion API 为自己的注解构造处理工具</li><li>更加干净易读的代码以及编译器类型的检查</li><li>虽然Java SE5提供一些元数据，但是一般来说，主要还是需要我们自己定义新的注解，并且按照自己的方法使用它们<a id="more"></a> ###定义注解<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/27 11:41</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * 　　@Target(ElementType.TYPE)   //接口、类、枚举、注解</span><br><span class="line"> * 　　@Target(ElementType.FIELD) //字段、枚举的常量</span><br><span class="line"> * 　　@Target(ElementType.METHOD) //方法</span><br><span class="line"> * 　　@Target(ElementType.PARAMETER) //方法参数。参数声明</span><br><span class="line"> * 　　@Target(ElementType.CONSTRUCTOR)  //构造函数，构造器的声明</span><br><span class="line"> * 　　@Target(ElementType.LOCAL_VARIABLE)//局部变量</span><br><span class="line"> * 　　@Target(ElementType.ANNOTATION_TYPE)//注解</span><br><span class="line"> * 　　@Target(ElementType.PACKAGE) ///包</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)//定义你的注解将应用在什么地方（一个方法，一个域）</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)//定义注解在哪个级别可以使用，在源码中（SOURCE）、类文件中（CALSS），或者运行时（RUNTIME）</span><br><span class="line">//没有元素的注解，称为标记注解（marker annotation），如果某个方法或者实现某个用例的需求，加上次方法，项目经理可以很好地观察到进度</span><br><span class="line">//如果需要修改系统的业务逻辑，则维护改项目的开发人员也可以很容易的找到相对于的实例</span><br><span class="line">public @interface Test &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>关于RetentionPolicy 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/27 15:09</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public enum  RetentionPolicy &#123;</span><br><span class="line">        /**</span><br><span class="line">         * Annotations are to be discarded by the compiler.</span><br><span class="line">         * 注解将被编译器丢弃</span><br><span class="line">         */</span><br><span class="line">        SOURCE,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Annotations are to be recorded in the class file by the compiler</span><br><span class="line">         * but need not be retained by the VM at run time.  This is the default</span><br><span class="line">         * behavior.</span><br><span class="line">         * 注解在class文件中可用，但会被VM丢弃</span><br><span class="line">         */</span><br><span class="line">        CLASS,</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">         * Annotations are to be recorded in the class file by the compiler and</span><br><span class="line">         * retained by the VM at run time, so they may be read reflectively.</span><br><span class="line">         * VM将在运行期也保留注解，因此可以通过反射机制读取注解的信息</span><br><span class="line">         * @see java.lang.reflect.AnnotatedElement</span><br><span class="line">         */</span><br><span class="line">        RUNTIME</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###目前可以理解为注释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Testale &#123;</span><br><span class="line">    public void execute()&#123;</span><br><span class="line">        System.out.println(&quot;shiming execute&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Test//就好比一个注释</span><br><span class="line">    void testExecute()&#123;</span><br><span class="line">        execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###Demo—–&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/27 14:25</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface UseCase &#123;</span><br><span class="line">    //由于编译器会对id进行类型检查，因此将用例文档的追踪数据库与源代码想关联是可靠的</span><br><span class="line">    public int id();//默认值的限定，首先，元素不能有不确定的值，也就是说，元素必须要么具有默认值，要么具有使用元素提供的元素的值</span><br><span class="line">    //如果注解某个方法没有给出值的话，则该注解的处理器就会使用此元素的默认值</span><br><span class="line">    public String description() default &quot;shiming no descriprition 我是默认的des&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/27 14:35</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * 注解的元素在使用时候为名-值对的形式，并需要置于@USECase申明之后的括号内，在方法注解中可以给出description的值，也可以不给</span><br><span class="line"> * 因此，在UseCase的注解处理器分析处理这个类时会使用该元素的默认值</span><br><span class="line"> */</span><br><span class="line">public class PasswordUtils &#123;</span><br><span class="line">    @UseCase(id = 1,description = &quot;start need d  我是id==1&quot;)</span><br><span class="line">    public boolean validatePassword(String s)&#123;</span><br><span class="line">        return s.startsWith(&quot;d&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UseCase(id = 2)</span><br><span class="line">    public String validatePasswordReverse(String s)&#123;</span><br><span class="line">        return new StringBuilder(s).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @UseCase(id = 3,description = &quot;start need 我是id==3&quot;)</span><br><span class="line">    public boolean validatePasswordStirng(String s)&#123;</span><br><span class="line">        return s.startsWith(&quot;shiming&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> ####如果没有用来读取注解的工具，那么注解也不会比注释更加有用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/27 15:16</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> *</span><br><span class="line"> * 如果没有用来读取注解的工具，那么注解也不会比注释更加有用</span><br><span class="line"> */</span><br><span class="line">public class UseCaseTracker &#123;</span><br><span class="line">    @SuppressLint(&quot;UseValueOf&quot;)</span><br><span class="line">    public static void trackUseCases(List&lt;Integer&gt; useCases, Class&lt;?&gt; cl)&#123;</span><br><span class="line">        /**</span><br><span class="line">         * getDeclaredMethods返回 Method 对象的一个数组，</span><br><span class="line">         * 这些对象反映此 Class 对象表示的类或接口声明的所有方法，</span><br><span class="line">         * 包括公共、保护、默认（包）访问和私有方法，但不包括继承的方法</span><br><span class="line">         */</span><br><span class="line">        for (Method m:cl.getDeclaredMethods())&#123;</span><br><span class="line">            UseCase annotation = m.getAnnotation(UseCase.class);</span><br><span class="line">            System.out.println(&quot;执行了第几次 &quot;+annotation+&quot;-----&gt;m.getName&quot;+m.getName());</span><br><span class="line">            if (annotation!=null)&#123;</span><br><span class="line">                System.out.println(&quot;shiming  &quot;+annotation.id()+&quot;----&gt;&quot;+annotation.description());</span><br><span class="line">                //注意这是元素还有角标的问题</span><br><span class="line">                useCases.remove(new Integer(annotation.id()));</span><br><span class="line">            &#125;</span><br><span class="line">            for (int i:useCases)&#123;</span><br><span class="line">                System.out.println(&quot;shiming warning Missing usecase&quot;+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">  integers.add(1);</span><br><span class="line">  integers.add(2);</span><br><span class="line">  integers.add(3);</span><br><span class="line">  integers.add(4);</span><br><span class="line">  UseCaseTracker.trackUseCases(integers,PasswordUtils.class);</span><br></pre></td></tr></table></figure></p><p>执行结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: 执行了第几次 null-----&gt;m.getNameaccess$super</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase1</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase2</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase3</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase4</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: 执行了第几次 @annotation.shimihg.demo.UseCase(description=start need d  我是id==1, id=1)-----&gt;m.getNamevalidatePassword</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming  1----&gt;start need d  我是id==1</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase2</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase3</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase4</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: 执行了第几次 @annotation.shimihg.demo.UseCase(description=shiming no descriprition 我是默认的des, id=2)-----&gt;m.getNamevalidatePasswordReverse</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming  2----&gt;shiming no descriprition 我是默认的des</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase3</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase4</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: 执行了第几次 @annotation.shimihg.demo.UseCase(description=start need 我是id==3, id=3)-----&gt;m.getNamevalidatePasswordStirng</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming  3----&gt;start need 我是id==3</span><br><span class="line">04-27 15:40:19.830 4425-4425/annotation.shimihg.com I/System.out: shiming warning Missing usecase4</span><br></pre></td></tr></table></figure></p><p>####未完待续，☺☺☺！git：<a href="https://github.com/Shimingli/AnnotationDemo" target="_blank" rel="noopener">https://github.com/Shimingli/AnnotationDemo</a></p>]]></content>
      
      
        <tags>
            
            <tag> 注解（Annotation） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>基于Glide4.7.1二次封装</title>
      <link href="/2018/04/22/%E5%9F%BA%E4%BA%8EGlide4-7-1%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/"/>
      <url>/2018/04/22/%E5%9F%BA%E4%BA%8EGlide4-7-1%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85/</url>
      <content type="html"><![CDATA[<h3 id="github"><a href="#github" class="headerlink" title="github"></a><a href="https://github.com/Shimingli/ImageLoader" target="_blank" rel="noopener">github</a></h3><p><img src="https://upload-images.jianshu.io/upload_images/5363507-285dae46159d767e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><a id="more"></a><br>使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">String url=&quot;https://upload-images.jianshu.io/upload_images/5363507-476c8bb17b124d22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;;</span><br><span class="line">   //        //圆形图片</span><br><span class="line">   ImageLoaderV4.getInstance().displayCircleImage(this, &quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;, mImageView_1, R.mipmap.ic_launcher_round);</span><br><span class="line">   //圆角图片</span><br><span class="line">   ImageLoaderV4.getInstance().displayRoundImage(this, &quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;, mImageView_2, R.mipmap.ic_launcher_round, 40);</span><br><span class="line">   //模糊图片</span><br><span class="line">   ImageLoaderV4.getInstance().displayBlurImage(this, &quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;, mImageView_3, R.mipmap.ic_launcher_round, 10);</span><br><span class="line"></span><br><span class="line">   //本地图片 不做处理</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResource(this, R.mipmap.test, mImageView_4);</span><br><span class="line">   // TODO: 2018/4/20  以下的三种不介意使用，需要解决一些问题  start</span><br><span class="line">   //本地图片，模糊处理</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResource(this, R.mipmap.test, mImageView_5, new BlurBitmapTranformation( 200));</span><br><span class="line">   //本地图片，裁圆角处理</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResource(this, R.mipmap.test, mImageView_6, new GlideCircleTransformation());</span><br><span class="line">   //四周倒角处理</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResource(this, R.mipmap.test, mImageView_7, new RoundBitmapTranformation( 40));</span><br><span class="line">   // TODO: 2018/4/20  以上的三种不介意使用，需要解决一些问题  start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   //使用的是另外一种方法，指定传入的那种的方法 ,还可以不断的扩展，不断的扩展，这是Gilded提供的一些操作，牛逼 ，牛逼 这是对本地图片的操作</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResourceTransform(this, R.mipmap.test, mImageView_8, new CenterInside(), R.mipmap.test);</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResourceTransform(this, R.mipmap.test, mImageView_9, new CircleCrop(), R.mipmap.test);</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResourceTransform(this, R.mipmap.test, mImageView_10, new FitCenter(), R.mipmap.test);</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageInResourceTransform(this, R.mipmap.test, mImageView_11, new RoundedCorners(10), R.mipmap.test);</span><br><span class="line"></span><br><span class="line">  //对网络图片的操作</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageByNet(this,url,mImageView_12, R.mipmap.test,new CenterInside());</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageByNet(this,url,mImageView_13, R.mipmap.test,new CircleCrop());</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageByNet(this,url,mImageView_14, R.mipmap.test,new FitCenter());</span><br><span class="line">   ImageLoaderV4.getInstance().displayImageByNet(this,url,mImageView_15, R.mipmap.test,new RoundedCorners(10));</span><br></pre></td></tr></table></figure></p><p>实现效果：监听图片的下载进度,注意事项需要在监听返回键的时候，取消请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ImageLoaderV4.getInstance().disPlayImageProgress(this, &quot;http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png&quot;, mImageView_8, R.mipmap.test, R.mipmap.test, new OnGlideImageViewListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onProgress(int percent, boolean isDone, GlideException exception) &#123;</span><br><span class="line">               System.out.println(&quot;shiming percent=&quot;+percent);</span><br><span class="line">               System.out.println(&quot;shiming isDone=&quot;+isDone);</span><br><span class="line">               mProgress.setText(&quot;我在主线程，进度是多少==&quot;+percent+&quot;%&quot;);</span><br><span class="line"></span><br><span class="line">               if (isDone)&#123;</span><br><span class="line">                   mProgress.setText(&quot;我在主线程，进度是多少==100%&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       ImageLoaderV4.getInstance().disPlayImageProgressByOnProgressListener(this, &quot;http://img.zcool.cn/community/0142135541fe180000019ae9b8cf86.jpg@1280w_1l_2o_100sh.png&quot;, mImageView_7, R.mipmap.test, R.mipmap.test, new OnProgressListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onProgress(String imageUrl, long bytesRead, long totalBytes, boolean isDone, GlideException exception) &#123;</span><br><span class="line">               System.out.println(&quot;shiming bytesRead=&quot;+bytesRead);</span><br><span class="line">               System.out.println(&quot;shiming totalBytes=&quot;+totalBytes);</span><br><span class="line">               mProgress7.setText(&quot;我在主线程，进度是多少==+bytesRead&quot;+bytesRead+&quot;totalBytes=&quot;+totalBytes);</span><br><span class="line"></span><br><span class="line">               if (isDone)&#123;</span><br><span class="line">                   mProgress7.setText(&quot;我在主线程，进度是多少==100%&quot;);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-986fb8ede4e9e455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-dbb259f34f2bcc35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>使用内部提供的图片处理<br><img src="https://upload-images.jianshu.io/upload_images/5363507-24f9ce31041e0bdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.github.bumptech.glide:glide:4.7.1&apos;</span><br><span class="line">annotationProcessor &apos;com.github.bumptech.glide:compiler:4.7.1&apos;</span><br><span class="line">compile &quot;com.github.bumptech.glide:okhttp3-integration:4.5.0&quot;</span><br></pre></td></tr></table></figure></p><p>构建AppGlideModule<br><img src="https://upload-images.jianshu.io/upload_images/5363507-305073f5732aa42f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>初始化registerComponents()方法，使用okhttp加入拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   OkHttp 是一个底层网络库(相较于 Cronet 或 Volley 而言)，尽管它也包含了 SPDY 的支持。</span><br><span class="line">   OkHttp 与 Glide 一起使用可以提供可靠的性能，并且在加载图片时通常比 Volley 产生的垃圾要少。</span><br><span class="line">   对于那些想要使用比 Android 提供的 HttpUrlConnection 更 nice 的 API，</span><br><span class="line">    或者想确保网络层代码不依赖于 app 安装的设备上 Android OS 版本的应用，OkHttp 是一个合理的选择。</span><br><span class="line">    如果你已经在 app 中某个地方使用了 OkHttp ，这也是选择继续为 Glide 使用 OkHttp 的一个很好的理由，就像选择其他网络库一样。</span><br><span class="line">   添加 OkHttp 集成库的 Gradle 依赖将使 Glide 自动开始使用 OkHttp 来加载所有来自 http 和 https URL 的图片</span><br><span class="line">   * @param context</span><br><span class="line">   * @param glide</span><br><span class="line">   * @param registry</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(Context context, Glide glide, Registry registry) &#123;</span><br><span class="line">      super.registerComponents(context, glide, registry);</span><br><span class="line">      registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(ProgressManager.getOkHttpClient()));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p> 默认情况下，Glide使用 LruResourceCache ， 这是 MemoryCache 接口的一个缺省实现，使用固定大小的内存和 LRU 算法。 LruResourceCache 的大小由 Glide 的 MemorySizeCalculator 类来决定，这个类主要关注设备的内存类型，设备 RAM 大小，以及屏幕分辨率。应用程序可以自定义 MemoryCache 的大小， 具体是在它们的 AppGlideModule 中使用applyOptions(Context, GlideBuilder) 方法配置 MemorySizeCalculator<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   //Glide会自动合理分配内存缓存，但是也可以自己手动分配。</span><br><span class="line">//    @Override</span><br><span class="line">//    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123;</span><br><span class="line">//        super.applyOptions(context, builder);</span><br><span class="line">//        //1、setMemoryCacheScreens设置MemoryCache应该能够容纳的像素值的设备屏幕数，</span><br><span class="line">//        // 说白了就是缓存多少屏图片，默认值是2。</span><br><span class="line">//        //todo 建议不要设置，使用glide 默认</span><br><span class="line">////        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)</span><br><span class="line">////                .setMemoryCacheScreens(2)</span><br><span class="line">////                .build();</span><br><span class="line">////        builder.setMemoryCache(new LruResourceCache(calculator.getMemoryCacheSize()));</span><br><span class="line">//</span><br><span class="line">//        //2。也可以直接覆写缓存大小：todo 建议不要设置，使用glide 默认</span><br><span class="line">////        int memoryCacheSizeBytes = 1024 * 1024 * 20; // 20mb</span><br><span class="line">////        builder.setMemoryCache(new LruResourceCache(memoryCacheSizeBytes));</span><br><span class="line">////        3.甚至可以提供自己的 MemoryCache 实现：</span><br><span class="line">////        builder.setMemoryCache(new YourAppMemoryCacheImpl());</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure></p><p>Bitmap 池Glide 使用 LruBitmapPool 作为默认的 BitmapPool  LruBitmapPool 是一个内存中的固定大小的 BitmapPool，使用 LRU 算法清理。默认大小基于设备的分辨率和密度，同时也考虑内存类和 isLowRamDevice 的返回值。 具体的计算通过 Glide 的 MemorySizeCalculator 来完成，与 Glide 的 MemoryCache 的大小检测方法相似。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//    @Override</span><br><span class="line">//    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123;</span><br><span class="line">//        super.applyOptions(context, builder);</span><br><span class="line">//    //1 .应用可以在它们的 AppGlideModule 中定制 [BitmapPool] 的尺寸，</span><br><span class="line">//        // 使用 applyOptions(Context, GlideBuilder) 方法并配置 MemorySizeCalculator</span><br><span class="line">////        MemorySizeCalculator calculator = new MemorySizeCalculator.Builder(context)</span><br><span class="line">////                .setBitmapPoolScreens(3)</span><br><span class="line">////                .build();</span><br><span class="line">////        builder.setBitmapPool(new LruBitmapPool(calculator.getBitmapPoolSize()));</span><br><span class="line">//</span><br><span class="line">//        //2、应用也可以直接复写这个池的大小：</span><br><span class="line">//</span><br><span class="line">////        int bitmapPoolSizeBytes = 1024 * 1024 * 30; // 30mb</span><br><span class="line">////        builder.setBitmapPool(new LruBitmapPool(bitmapPoolSizeBytes));</span><br><span class="line">//</span><br><span class="line">//</span><br><span class="line">//        //3、甚至可以提供 BitmapPool 的完全自定义实现：</span><br><span class="line">//</span><br><span class="line">////        builder.setBitmapPool(new YourAppBitmapPoolImpl());</span><br><span class="line">//    &#125;</span><br></pre></td></tr></table></figure><p>磁盘缓存Glide 使用 DiskLruCacheWrapper 作为默认的 磁盘缓存 . DiskLruCacheWrapper 是一个使用 LRU 算法的固定大小的磁盘缓存。默认磁盘大小为 250 MB ， 位置是在应用的 缓存文件夹 中的一个 特定目录 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  @Override</span><br><span class="line">    public void applyOptions(@NonNull Context context, @NonNull GlideBuilder builder) &#123;</span><br><span class="line">        super.applyOptions(context, builder);</span><br><span class="line">        //假如应用程序展示的媒体内容是公开的（从无授权机制的网站上加载，或搜索引擎等），</span><br><span class="line">        //那么应用可以将这个缓存位置改到外部存储：</span><br><span class="line">//        builder.setDiskCache(new ExternalDiskCacheFactory(context));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         //2、无论使用内部或外部磁盘缓存，应用程序都可以改变磁盘缓存的大小：</span><br><span class="line">//        int diskCacheSizeBytes = 1024 *1024 *100;  //100 MB</span><br><span class="line">//        builder.setDiskCache(new InternalDiskCacheFactory(context, diskCacheSizeBytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //3、应用程序还可以改变缓存文件夹在外存或内存上的名字：</span><br><span class="line">//        int diskCacheSizeBytes = 1024 * 1024 *100; // 100 MB</span><br><span class="line">//        builder.setDiskCache(new InternalDiskCacheFactory(context, cacheFolderName, diskCacheSizeBytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //4、应用程序还可以自行选择 DiskCache 接口的实现，并提供自己的 DiskCache.Factory 来创建缓存。</span><br><span class="line">        // Glide 使用一个工厂接口来在后台线程中打开 磁盘缓存 ，</span><br><span class="line">        // 这样方便缓存做诸如检查路径存在性等的IO操作而不用触发 严格模式 。</span><br><span class="line">//        builder.setDiskCache(new DiskCache.Factory() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public DiskCache build() &#123;</span><br><span class="line">//                return new YourAppCustomDiskCache();</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/20 15:13</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> 磁盘缓存</span><br><span class="line"> Glide 使用 DiskLruCacheWrapper 作为默认的 磁盘缓存 。</span><br><span class="line"> DiskLruCacheWrapper 是一个使用 LRU 算法的固定大小的磁盘缓存。默认磁盘大小为 250 MB ，</span><br><span class="line"> 位置是在应用的 缓存文件夹 中的一个 特定目录 。</span><br><span class="line"> 假如应用程序展示的媒体内容是公开的（从无授权机制的网站上加载，或搜索引擎等），</span><br><span class="line"> 那么应用可以将这个缓存位置改到外部存储：</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class ExternalDiskCacheFactory implements DiskCache.Factory &#123;</span><br><span class="line">    public ExternalDiskCacheFactory(Context context) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public DiskCache build() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了维持对 Glide v3 的 GlideModules 的向后兼容性， Glide 仍然会解析应用程序和所有被包含的库中的 AndroidManifest.xml 文件， 并包含在这些清单中列出的旧 GlideModules 模块类。如果你已经迁移到 Glide v4 的 AppGlideModule 和 LibraryGlideModule ，你可以完全禁用清单解析。 这样可以改善 Glide 的初始启动时间，并避免尝试解析元数据时的一些潜在问题。要禁用清单解析， 请在你的 AppGlideModule 实现中复写 isManifestParsingEnabled() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean isManifestParsingEnabled() &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IImageLoaderClient接口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public interface IImageLoaderClient &#123;</span><br><span class="line">    public void init(Context context);</span><br><span class="line"></span><br><span class="line">    public void destroy(Context context);</span><br><span class="line"></span><br><span class="line">    public File getCacheDir(Context context);</span><br><span class="line"></span><br><span class="line">    public void clearMemoryCache(Context context);</span><br><span class="line"></span><br><span class="line">    public void clearDiskCache(Context context);</span><br><span class="line"></span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url);</span><br><span class="line"></span><br><span class="line">    public void getBitmapFromCache(Context context, String url, IGetBitmapListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius);</span><br><span class="line"></span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, IGetDrawableListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, int defRes, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, int defRes, BitmapTransformation transformations);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //add shiming   2018.4.20 transformation 需要装换的那种图像的风格，错误图片，或者是，正在加载中的错误图</span><br><span class="line">    public void displayImageInResourceTransform(Activity activity, int resId, ImageView imageView, Transformation transformation, int errorResId);</span><br><span class="line">    public void displayImageInResourceTransform(Context context, int resId, ImageView imageView, Transformation transformation, int errorResId);</span><br><span class="line">    public void displayImageInResourceTransform(Fragment fragment, int resId, ImageView imageView, Transformation transformation, int errorResId);</span><br><span class="line"></span><br><span class="line">    //这是对网络图片，进行的图片操作，使用的glide中的方法</span><br><span class="line">    public void displayImageByNet(Context context, String url, ImageView imageView, int defRes,Transformation transformation);</span><br><span class="line">    public void displayImageByNet(Fragment fragment, String url, ImageView imageView, int defRes,Transformation transformation);</span><br><span class="line">    public void displayImageByNet(Activity activity, String url, ImageView imageView, int defRes,Transformation transformation);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  停止图片的加载，对某一个的Activity</span><br><span class="line">     * @hide</span><br><span class="line">     */</span><br><span class="line">    public void clear(Activity activity,ImageView imageView);</span><br><span class="line">    /**</span><br><span class="line">     * 停止图片的加载，context</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     */</span><br><span class="line">    public void clear(Context context,ImageView imageView);</span><br><span class="line">    /**</span><br><span class="line">     * 停止图片的加载，fragment</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     */</span><br><span class="line">    public void clear(Fragment fragment,ImageView imageView);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    //如果需要的话，需要指定加载中，或者是失败的图片</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Fragment fragment, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView);</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Activity activity, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView);</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Context context, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView);</span><br><span class="line">    //某些情形下，你可能希望只要图片不在缓存中则加载直接失败（比如省流量模式）</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Fragment fragment,String url,ImageView imageView);</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Activity activity,String url,ImageView imageView);</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Context context,String url,ImageView imageView);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *如果你想确保一个特定的请求跳过磁盘和/或内存缓存（比如，图片验证码 –）</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param skipflag  是否跳过内存缓存</span><br><span class="line">     * @param diskCacheStratey  是否跳过磁盘缓存</span><br><span class="line">     */</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Fragment fragment,String url,ImageView imageView,boolean skipflag,boolean diskCacheStratey);</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Activity activity,String url,ImageView imageView,boolean skipflag,boolean diskCacheStratey);</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Context context,String url,ImageView imageView,boolean skipflag,boolean diskCacheStratey);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 知道这个图片会加载失败，那么的话，我们可以重新加载</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param fallbackUrl</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    //从 Glide 4.3.0 开始，你可以很轻松地使用 .error() 方法。这个方法接受一个任意的 RequestBuilder,它会且只会在主请求失败时开始一个新的请求：</span><br><span class="line">    public void disPlayImageErrorReload(Fragment fragment,String url,String fallbackUrl,ImageView imageView);</span><br><span class="line">    public void disPlayImageErrorReload(Activity activity,String url,String fallbackUrl,ImageView imageView);</span><br><span class="line">    public void disPlayImageErrorReload(Context context,String url,String fallbackUrl,ImageView imageView);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     未来 Glide 将默认加载硬件位图而不需要额外的启用配置，只保留禁用的选项 现在已经默认开启了这个配置，但是在有些情况下需要关闭</span><br><span class="line">     所以提供了以下的方法，禁用硬件位图 disallowHardwareConfig</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">//    哪些情况不能使用硬件位图?</span><br><span class="line">//    在显存中存储像素数据意味着这些数据不容易访问到，在某些情况下可能会发生异常。已知的情形列举如下：</span><br><span class="line">//    在 Java 中读写像素数据，包括：</span><br><span class="line">//    Bitmap#getPixel</span><br><span class="line">//    Bitmap#getPixels</span><br><span class="line">//    Bitmap#copyPixelsToBuffer</span><br><span class="line">//    Bitmap#copyPixelsFromBuffer</span><br><span class="line">//    在本地 (native) 代码中读写像素数据</span><br><span class="line">//    使用软件画布 (software Canvas) 渲染硬件位图:</span><br><span class="line">//    Canvas canvas = new Canvas(normalBitmap)</span><br><span class="line">//canvas.drawBitmap(hardwareBitmap, 0, 0, new Paint());</span><br><span class="line">//    在绘制位图的 View 上使用软件层 (software layer type) （例如，绘制阴影）</span><br><span class="line">//    ImageView imageView = …</span><br><span class="line">//            imageView.setImageBitmap(hardwareBitmap);</span><br><span class="line">//imageView.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</span><br><span class="line">//    打开过多的文件描述符 . 每个硬件位图会消耗一个文件描述符。</span><br><span class="line">// 这里存在一个每个进程的文件描述符限制 ( Android O 及更早版本一般为 1024，在某些 O-MR1 和更高的构建上是 32K)。</span><br><span class="line">// Glide 将尝试限制分配的硬件位图以保持在这个限制以内，但如果你已经分配了大量的文件描述符，这可能是一个问题。</span><br><span class="line">//    需要ARGB_8888 Bitmaps 作为前置条件</span><br><span class="line">//    在代码中触发截屏操作，它会尝试使用 Canvas 来绘制视图层级。</span><br><span class="line">//    作为一个替代方案，在 Android O 以上版本你可以使用 PixelCopy.</span><br><span class="line">//   共享元素过渡 (shared element transition)(OMR1已修复)</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Fragment fragment,String url,ImageView imageView);</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Activity activity,String url,ImageView imageView);</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Context context,String url,ImageView imageView);</span><br><span class="line"></span><br><span class="line">    //监听图片的下载进度，是否完成，百分比 也可以加载本地图片，扩张一下</span><br><span class="line">    public void disPlayImageProgress(Context context,String url,ImageView imageView,int placeholderResId,int errorResId,OnGlideImageViewListener listener);</span><br><span class="line">    public void disPlayImageProgress(Activity activity,String url,ImageView imageView,int placeholderResId,int errorResId,OnGlideImageViewListener listener);</span><br><span class="line">    public void disPlayImageProgress(Fragment fragment,String url,ImageView imageView,int placeholderResId,int errorResId,OnGlideImageViewListener listener);</span><br><span class="line"></span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Context context,String url,ImageView imageView,int placeholderResId,int errorResId, OnProgressListener onProgressListener);</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Activity activity,String url,ImageView imageView,int placeholderResId,int errorResId, OnProgressListener onProgressListener);</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Fragment fragment,String url,ImageView imageView,int placeholderResId,int errorResId, OnProgressListener onProgressListener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    TransitionOptions 用于给一个特定的请求指定过渡。</span><br><span class="line">//    每个请求可以使用 RequestBuilder 中的 transition()</span><br><span class="line">//    方法来设定 TransitionOptions 。还可以通过使用</span><br><span class="line">//    BitmapTransitionOptions 或 DrawableTransitionOptions</span><br><span class="line">//    来指定类型特定的过渡动画。对于 Bitmap 和 Drawable</span><br><span class="line">//    之外的资源类型，可以使用 GenericTransitionOptions。 Glide v4 将不会默认应用交叉淡入或任何其他的过渡效果。每个请求必须手动应用过渡。</span><br><span class="line">    public void displayImageByTransition(Context context, String url, TransitionOptions transitionOptions, ImageView imageView);</span><br><span class="line">    public void displayImageByTransition(Activity activity, String url, TransitionOptions transitionOptions, ImageView imageView);</span><br><span class="line">    public void displayImageByTransition(Fragment fragment, String url, TransitionOptions transitionOptions, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    //失去焦点，建议实际的项目中少用，取消求情</span><br><span class="line">    public void glidePauseRequests(Context context);</span><br><span class="line">    public void glidePauseRequests(Activity activity);</span><br><span class="line">    public void glidePauseRequests(Fragment fragment);</span><br><span class="line"></span><br><span class="line">    //获取焦点，建议实际的项目中少用</span><br><span class="line">    public void glideResumeRequests(Context context);</span><br><span class="line">    public void glideResumeRequests(Activity activity);</span><br><span class="line">    public void glideResumeRequests(Fragment fragment);</span><br><span class="line">    //加载缩图图     int thumbnailSize = 10;//越小，图片越小，低网络的情况，图片越小</span><br><span class="line">    //GlideApp.with(this).load(urlnoData).override(thumbnailSize))// API 来强制 Glide 在缩略图请求中加载一个低分辨率图像</span><br><span class="line">    public void displayImageThumbnail(Context context,String url,String backUrl,int thumbnailSize,ImageView imageView);</span><br><span class="line">    public void displayImageThumbnail(Activity activity,String url,String backUrl,int thumbnailSize,ImageView imageView);</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment,String url,String backUrl,int thumbnailSize,ImageView imageView);</span><br><span class="line">    //如果没有两个url的话，也想，记载一个缩略图</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment,String url,float thumbnailSize,ImageView imageView);</span><br><span class="line">    public void displayImageThumbnail(Activity activity,String url,float thumbnailSize,ImageView imageView);</span><br><span class="line">    public void displayImageThumbnail(Context context,String url,float thumbnailSize,ImageView imageView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>GlideImageLoaderClient实现类</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br><span class="line">1001</span><br><span class="line">1002</span><br><span class="line">1003</span><br><span class="line">1004</span><br><span class="line">1005</span><br><span class="line">1006</span><br><span class="line">1007</span><br><span class="line">1008</span><br><span class="line">1009</span><br><span class="line">1010</span><br><span class="line">1011</span><br><span class="line">1012</span><br><span class="line">1013</span><br><span class="line">1014</span><br><span class="line">1015</span><br><span class="line">1016</span><br><span class="line">1017</span><br><span class="line">1018</span><br><span class="line">1019</span><br><span class="line">1020</span><br><span class="line">1021</span><br><span class="line">1022</span><br><span class="line">1023</span><br><span class="line">1024</span><br><span class="line">1025</span><br><span class="line">1026</span><br><span class="line">1027</span><br><span class="line">1028</span><br><span class="line">1029</span><br><span class="line">1030</span><br><span class="line">1031</span><br><span class="line">1032</span><br><span class="line">1033</span><br><span class="line">1034</span><br><span class="line">1035</span><br><span class="line">1036</span><br><span class="line">1037</span><br><span class="line">1038</span><br><span class="line">1039</span><br><span class="line">1040</span><br><span class="line">1041</span><br><span class="line">1042</span><br><span class="line">1043</span><br><span class="line">1044</span><br><span class="line">1045</span><br><span class="line">1046</span><br><span class="line">1047</span><br><span class="line">1048</span><br><span class="line">1049</span><br><span class="line">1050</span><br><span class="line">1051</span><br><span class="line">1052</span><br><span class="line">1053</span><br><span class="line">1054</span><br><span class="line">1055</span><br><span class="line">1056</span><br><span class="line">1057</span><br><span class="line">1058</span><br><span class="line">1059</span><br><span class="line">1060</span><br><span class="line">1061</span><br><span class="line">1062</span><br><span class="line">1063</span><br><span class="line">1064</span><br><span class="line">1065</span><br><span class="line">1066</span><br><span class="line">1067</span><br><span class="line">1068</span><br><span class="line">1069</span><br><span class="line">1070</span><br><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br><span class="line">1084</span><br><span class="line">1085</span><br><span class="line">1086</span><br><span class="line">1087</span><br><span class="line">1088</span><br><span class="line">1089</span><br><span class="line">1090</span><br><span class="line">1091</span><br><span class="line">1092</span><br><span class="line">1093</span><br><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br><span class="line">1097</span><br><span class="line">1098</span><br><span class="line">1099</span><br><span class="line">1100</span><br><span class="line">1101</span><br><span class="line">1102</span><br><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br><span class="line">1106</span><br><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br><span class="line">1114</span><br><span class="line">1115</span><br><span class="line">1116</span><br><span class="line">1117</span><br><span class="line">1118</span><br><span class="line">1119</span><br><span class="line">1120</span><br><span class="line">1121</span><br><span class="line">1122</span><br><span class="line">1123</span><br><span class="line">1124</span><br><span class="line">1125</span><br><span class="line">1126</span><br><span class="line">1127</span><br><span class="line">1128</span><br><span class="line">1129</span><br><span class="line">1130</span><br><span class="line">1131</span><br><span class="line">1132</span><br><span class="line">1133</span><br><span class="line">1134</span><br><span class="line">1135</span><br><span class="line">1136</span><br><span class="line">1137</span><br><span class="line">1138</span><br><span class="line">1139</span><br><span class="line">1140</span><br><span class="line">1141</span><br><span class="line">1142</span><br><span class="line">1143</span><br><span class="line">1144</span><br><span class="line">1145</span><br><span class="line">1146</span><br><span class="line">1147</span><br><span class="line">1148</span><br><span class="line">1149</span><br><span class="line">1150</span><br><span class="line">1151</span><br><span class="line">1152</span><br><span class="line">1153</span><br><span class="line">1154</span><br><span class="line">1155</span><br><span class="line">1156</span><br><span class="line">1157</span><br><span class="line">1158</span><br><span class="line">1159</span><br><span class="line">1160</span><br><span class="line">1161</span><br><span class="line">1162</span><br><span class="line">1163</span><br><span class="line">1164</span><br><span class="line">1165</span><br><span class="line">1166</span><br><span class="line">1167</span><br><span class="line">1168</span><br><span class="line">1169</span><br><span class="line">1170</span><br><span class="line">1171</span><br><span class="line">1172</span><br><span class="line">1173</span><br><span class="line">1174</span><br><span class="line">1175</span><br><span class="line">1176</span><br><span class="line">1177</span><br><span class="line">1178</span><br><span class="line">1179</span><br><span class="line">1180</span><br><span class="line">1181</span><br><span class="line">1182</span><br><span class="line">1183</span><br><span class="line">1184</span><br><span class="line">1185</span><br><span class="line">1186</span><br><span class="line">1187</span><br><span class="line">1188</span><br><span class="line">1189</span><br><span class="line">1190</span><br><span class="line">1191</span><br><span class="line">1192</span><br><span class="line">1193</span><br><span class="line">1194</span><br><span class="line">1195</span><br><span class="line">1196</span><br><span class="line">1197</span><br><span class="line">1198</span><br><span class="line">1199</span><br><span class="line">1200</span><br><span class="line">1201</span><br><span class="line">1202</span><br><span class="line">1203</span><br><span class="line">1204</span><br><span class="line">1205</span><br><span class="line">1206</span><br><span class="line">1207</span><br><span class="line">1208</span><br><span class="line">1209</span><br><span class="line">1210</span><br><span class="line">1211</span><br><span class="line">1212</span><br><span class="line">1213</span><br><span class="line">1214</span><br><span class="line">1215</span><br><span class="line">1216</span><br><span class="line">1217</span><br><span class="line">1218</span><br><span class="line">1219</span><br><span class="line">1220</span><br><span class="line">1221</span><br><span class="line">1222</span><br><span class="line">1223</span><br><span class="line">1224</span><br><span class="line">1225</span><br><span class="line">1226</span><br><span class="line">1227</span><br><span class="line">1228</span><br><span class="line">1229</span><br><span class="line">1230</span><br><span class="line">1231</span><br><span class="line">1232</span><br><span class="line">1233</span><br></pre></td><td class="code"><pre><span class="line">package code.shiming.com.imageloader471;</span><br><span class="line"></span><br><span class="line">import android.annotation.SuppressLint;</span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.graphics.Bitmap;</span><br><span class="line">import android.graphics.drawable.Drawable;</span><br><span class="line">import android.os.AsyncTask;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.Looper;</span><br><span class="line">import android.os.SystemClock;</span><br><span class="line">import android.support.annotation.NonNull;</span><br><span class="line">import android.support.annotation.Nullable;</span><br><span class="line">import android.support.annotation.UiThread;</span><br><span class="line">import android.support.v4.app.Fragment;</span><br><span class="line">import android.util.Log;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line"></span><br><span class="line">import com.bumptech.glide.Glide;</span><br><span class="line">import com.bumptech.glide.TransitionOptions;</span><br><span class="line">import com.bumptech.glide.load.DataSource;</span><br><span class="line">import com.bumptech.glide.load.Transformation;</span><br><span class="line">import com.bumptech.glide.load.engine.DiskCacheStrategy;</span><br><span class="line">import com.bumptech.glide.load.engine.GlideException;</span><br><span class="line">import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line">import com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions;</span><br><span class="line">import com.bumptech.glide.request.RequestListener;</span><br><span class="line">import com.bumptech.glide.request.RequestOptions;</span><br><span class="line">import com.bumptech.glide.request.target.SimpleTarget;</span><br><span class="line">import com.bumptech.glide.request.target.Target;</span><br><span class="line">import com.bumptech.glide.request.transition.Transition;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import code.shiming.com.imageloader471.listener.IGetBitmapListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.IGetDrawableListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.IImageLoaderListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.ImageSize;</span><br><span class="line">import code.shiming.com.imageloader471.okhttp.OnGlideImageViewListener;</span><br><span class="line">import code.shiming.com.imageloader471.okhttp.OnProgressListener;</span><br><span class="line">import code.shiming.com.imageloader471.okhttp.ProgressManager;</span><br><span class="line">import code.shiming.com.imageloader471.tranform.BlurBitmapTranformation;</span><br><span class="line">import code.shiming.com.imageloader471.tranform.GlideCircleTransformation;</span><br><span class="line">import code.shiming.com.imageloader471.tranform.RoundBitmapTranformation;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> * des:</span><br><span class="line"> * with(Context context). 使用Application上下文，Glide请求将不受Activity/Fragment生命周期控制。</span><br><span class="line">   with(Activity activity).使用Activity作为上下文，Glide的请求会受到Activity生命周期控制。</span><br><span class="line">   with(FragmentActivity activity).Glide的请求会受到FragmentActivity生命周期控制。</span><br><span class="line">   with(android.app.Fragment fragment).Glide的请求会受到Fragment 生命周期控制。</span><br><span class="line">   with(android.support.v4.app.Fragment fragment).Glide的请求会受到Fragment生命周期控制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class GlideImageLoaderClient implements IImageLoaderClient &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TAG =&quot;GlideImageLoaderClient&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(Context context) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void destroy(Context context) &#123;</span><br><span class="line">        clearMemoryCache(context);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public File getCacheDir(Context context) &#123;</span><br><span class="line">        return Glide.getPhotoCacheDir(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用ui线程</span><br><span class="line">     * @param context</span><br><span class="line">     */</span><br><span class="line">    @UiThread</span><br><span class="line">    @Override</span><br><span class="line">    public void clearMemoryCache(Context context) &#123;</span><br><span class="line">        GlideApp.get(context).clearMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;StaticFieldLeak&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    public void clearDiskCache(final Context context) &#123;</span><br><span class="line">        new AsyncTask&lt;Void, Void, Void&gt; ()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected Void doInBackground(Void... params) &#123;</span><br><span class="line">                //必须在子线程中  This method must be called on a background thread.</span><br><span class="line">                Glide.get(context).clearDiskCache();</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;glide 不支持同步 获取缓存中 bitmap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 获取缓存中的图片</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param listener</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void getBitmapFromCache(Context context, String url, final IGetBitmapListener listener) &#123;</span><br><span class="line">       GlideApp.with(context).asBitmap().load(url).into(new SimpleTarget&lt;Bitmap&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) &#123;</span><br><span class="line">               if (listener != null) &#123;</span><br><span class="line">                   listener.onBitmap(resource);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     默认的策略是DiskCacheStrategy.AUTOMATIC</span><br><span class="line">     DiskCacheStrategy.ALL 使用DATA和RESOURCE缓存远程数据，仅使用RESOURCE来缓存本地数据。</span><br><span class="line">     DiskCacheStrategy.NONE 不使用磁盘缓存</span><br><span class="line">     DiskCacheStrategy.DATA 在资源解码前就将原始数据写入磁盘缓存</span><br><span class="line">     DiskCacheStrategy.RESOURCE 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源。</span><br><span class="line">     DiskCacheStrategy.AUTOMATIC 根据原始图片数据和资源编码策略来自动选择磁盘缓存策略。</span><br><span class="line">     * @param context  上下文</span><br><span class="line">     * @param resId  id</span><br><span class="line">     * @param imageView into</span><br><span class="line">      */</span><br><span class="line">    //DiskCacheStrategy.SOURCE：缓存原始数据 DiskCacheStrategy.DATA对应Glide 3中的DiskCacheStrategy.SOURCE</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        //设置缓存策略缓存原始数据  Saves just the original data to cache</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url url</span><br><span class="line">     * @param imageView in</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param isCache 是否是缓存 如果是：缓存策略缓存原始数据  不是的话 ：缓存策略DiskCacheStrategy.NONE：什么都不缓存</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).skipMemoryCache(isCache).diskCacheStrategy(isCache ? DiskCacheStrategy.AUTOMATIC : DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param fragment 绑定生命周期</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用.placeholder()方法在某些情况下会导致图片显示的时候出现图片变形的情况</span><br><span class="line">     * 这是因为Glide默认开启的crossFade动画导致的TransitionDrawable绘制异常</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes defRes 可以是个new ColorDrawable(Color.BLACK) 也可以是张图片</span><br><span class="line">     */</span><br><span class="line">    //默认为200  时间有点长  ，工程中要修改下，设置一个加载失败和加载中的动画过渡，V4.0的使用的方法</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).transition(new DrawableTransitionOptions().crossFade(200)).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 默认时间为200 需</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).transition(new DrawableTransitionOptions().crossFade(200)).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param transformations bitmapTransform 方法设置图片转换</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, final BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(requestOptionsTransformation(defRes,defRes,transformations)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(requestOptionsTransformation(defRes,defRes,transformations)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载原圆形图片</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    public void displayImageCircle(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(circleRequestOptions(defRes,defRes)).into(imageView);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void displayImageCircle(Fragment context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.DATA).apply(circleRequestOptions(defRes,defRes)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    public RequestOptions requestOptions(int placeholderResId, int errorResId) &#123;</span><br><span class="line">        return new RequestOptions()</span><br><span class="line">                .placeholder(placeholderResId)</span><br><span class="line">                .error(errorResId);</span><br><span class="line">    &#125;</span><br><span class="line">    public RequestOptions requestOptionsTransformation(int placeholderResId, int errorResId,BitmapTransformation bitmapTransformation) &#123;</span><br><span class="line">        return requestOptions(placeholderResId,errorResId)</span><br><span class="line">                .transform(bitmapTransformation);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 加载原图</span><br><span class="line">     * @param placeholderResId</span><br><span class="line">     * @param errorResId</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public RequestOptions circleRequestOptions(int placeholderResId, int errorResId) &#123;</span><br><span class="line">        return requestOptions(placeholderResId, errorResId)</span><br><span class="line">                .transform(new GlideCircleTransformation());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RequestOptions roundRequestOptions(int placeholderResId, int errorResId,int radius) &#123;</span><br><span class="line">        return requestOptions(placeholderResId, errorResId)</span><br><span class="line">                .transform(new RoundBitmapTranformation(radius));</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes placeholder(int resourceId). 设置资源加载过程中的占位Drawable  error(int resourceId).设置load失败时显示的Drawable</span><br><span class="line">     * @param size override(int width, int height). 重新设置Target的宽高值</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).placeholder(defRes).error(defRes).override(size.getWidth(), size.getHeight()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).placeholder(defRes).error(defRes).override(size.getWidth(), size.getHeight()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * .skipMemoryCache( true )去特意告诉Glide跳过内存缓存  是否跳过内存，还是不跳过</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param cacheInMemory</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).placeholder(defRes).error(defRes).skipMemoryCache(cacheInMemory).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).placeholder(defRes).error(defRes).skipMemoryCache(cacheInMemory).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只在需要的地方进行监听 listener 通过自定义的接口回调参数</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param listener  监听资源加载的请求状态 但不要每次请求都使用新的监听器，要避免不必要的内存申请，</span><br><span class="line">     *                  可以使用单例进行统一的异常监听和处理</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, final String url, final ImageView imageView, final IImageLoaderListener listener) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                Log.e(TAG, &quot;Load failed&quot;, e);//如果关系的话，关系如何失败</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, final String url, final ImageView imageView, final IImageLoaderListener listener) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, final String url, final ImageView imageView, int defRes, final IImageLoaderListener listener) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).placeholder(defRes).error(defRes).listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, final String url, final ImageView imageView, int defRes, final IImageLoaderListener listener) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 圆形图片的裁剪</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(circleRequestOptions(defRes,defRes)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(circleRequestOptions(defRes,defRes)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void displayCircleImage(Activity fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.DATA).apply(circleRequestOptions(defRes,defRes)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param radius 倒圆角的图片 需要传入需要radius  越大的话，倒角越明显</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(roundRequestOptions(defRes,defRes,radius)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.DATA).apply(roundRequestOptions(defRes,defRes,radius)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param blurRadius 模糊的程度 ，数字越大越模糊</span><br><span class="line">     * @param listener 接口回调需要拿到drawable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, final IGetDrawableListener listener) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).into(new SimpleTarget&lt;Drawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResourceReady(@NonNull Drawable resource, @Nullable Transition&lt;? super Drawable&gt; transition) &#123;</span><br><span class="line">                if ( listener != null ) &#123;</span><br><span class="line">                    listener.onDrawable( resource );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不需要关系此模糊图的drawable</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param blurRadius</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(blurRequestOptions(defRes,defRes,blurRadius)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private RequestOptions blurRequestOptions(int defRes, int defRes1, int blurRadius) &#123;</span><br><span class="line">        return requestOptions(defRes, defRes1)</span><br><span class="line">                .transform(new BlurBitmapTranformation(blurRadius));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(blurRequestOptions(resId,resId,blurRadius)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(blurRequestOptions(defRes,defRes,blurRadius)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  加载资源文件</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Activity fragment, int resId, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param transformation 需要变换那种图像</span><br><span class="line">     * @param errorResId</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Activity fragment, int resId, ImageView imageView,Transformation transformation,int errorResId) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).apply(requestOptionsTransform(errorResId,errorResId,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Context context, int resId, ImageView imageView, Transformation transformation, int errorResId) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).apply(requestOptionsTransform(errorResId,errorResId,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Fragment fragment, int resId, ImageView imageView, Transformation transformation, int errorResId) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).apply(requestOptionsTransform(errorResId,errorResId,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Context context, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(requestOptionsTransform(defRes,defRes,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Fragment fragment, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(requestOptionsTransform(defRes,defRes,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Activity activity, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        GlideApp.with(activity).load(url).diskCacheStrategy(DiskCacheStrategy.AUTOMATIC).apply(requestOptionsTransform(defRes,defRes,transformation)).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Activity activity, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(activity).clear(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Context context, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context).clear(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Fragment fragment, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment).clear(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">//    默认的策略是DiskCacheStrategy.AUTOMATIC</span><br><span class="line">//    DiskCacheStrategy.ALL 使用DATA和RESOURCE缓存远程数据，仅使用RESOURCE来缓存本地数据。</span><br><span class="line">//    DiskCacheStrategy.NONE 不使用磁盘缓存</span><br><span class="line">//    DiskCacheStrategy.DATA 在资源解码前就将原始数据写入磁盘缓存</span><br><span class="line">//    DiskCacheStrategy.RESOURCE 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源。</span><br><span class="line">//    DiskCacheStrategy.AUTOMATIC 根据原始图片数据和资源编码策略来自动选择磁盘缓存策略。</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Fragment fragment, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(url).diskCacheStrategy(diskCacheStrategy).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">//    DiskCacheStrategy.NONE： 表示不缓存任何内容。</span><br><span class="line">//    DiskCacheStrategy.DATA： 表示只缓存原始图片。</span><br><span class="line">//    DiskCacheStrategy.RESOURCE： 表示只缓存转换过后的图片。</span><br><span class="line">//    DiskCacheStrategy.ALL ： 表示既缓存原始图片，也缓存转换过后的图片。</span><br><span class="line">//    DiskCacheStrategy.AUTOMATIC： 表示让Glide根据图片资源智能地选择使用哪一种缓存策略（默认选项）。</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Activity activity, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(activity).load(url).diskCacheStrategy(diskCacheStrategy).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Context context, String url, DiskCacheStrategy diskCacheStrategy,ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context).load(url).diskCacheStrategy(diskCacheStrategy).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .onlyRetrieveFromCache(true)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Activity activity, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .onlyRetrieveFromCache(true)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .onlyRetrieveFromCache(true)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *如果你想确保一个特定的请求跳过磁盘和/或内存缓存（比如，图片验证码 –）</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param skipflag  是否跳过内存缓存</span><br><span class="line">     * @param diskCacheStratey  是否跳过磁盘缓存</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Fragment fragment, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(diskCacheStratey?DiskCacheStrategy.NONE:DiskCacheStrategy.AUTOMATIC)</span><br><span class="line">                .skipMemoryCache(skipflag)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Activity activity, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(diskCacheStratey?DiskCacheStrategy.NONE:DiskCacheStrategy.AUTOMATIC)</span><br><span class="line">                .skipMemoryCache(skipflag)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Context context, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(diskCacheStratey?DiskCacheStrategy.NONE:DiskCacheStrategy.AUTOMATIC)</span><br><span class="line">                .skipMemoryCache(skipflag)</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Fragment fragment, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .error(GlideApp.with(fragment)</span><br><span class="line">                        .load(fallbackUrl))</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Activity activity, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .error(GlideApp.with(activity)</span><br><span class="line">                        .load(fallbackUrl))</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Context context, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .error(GlideApp.with(context)</span><br><span class="line">                        .load(fallbackUrl))</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .disallowHardwareConfig()</span><br><span class="line">                .into(imageView);</span><br><span class="line">        //第二种方法</span><br><span class="line">//        RequestOptions options = new RequestOptions().disallowHardwareConfig();</span><br><span class="line">//        Glide.with(fragment)</span><br><span class="line">//                .load(url)</span><br><span class="line">//                .apply(options)</span><br><span class="line">//                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Activity activity, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .disallowHardwareConfig()</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .disallowHardwareConfig()</span><br><span class="line">                .into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    //监听进度</span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Context context, final String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        onGlideImageViewListener=listener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Activity activity, final String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        onGlideImageViewListener=listener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Fragment fragment, final String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        onGlideImageViewListener=listener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Context context, final String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        GlideApp.with(context)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        this.onProgressListener = onProgressListener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Activity activity, final String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        GlideApp.with(activity)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        this.onProgressListener = onProgressListener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Fragment fragment, final String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        GlideApp.with(fragment)</span><br><span class="line">                .load(url)</span><br><span class="line">                .diskCacheStrategy(DiskCacheStrategy.NONE)//todo 我是为了测试，看到进度条，才把缓存策略设置成这样的，项目中一定不要这样做</span><br><span class="line">                .apply(new RequestOptions()</span><br><span class="line">                        .placeholder(placeholderResId)</span><br><span class="line">                        .error(errorResId))</span><br><span class="line">                .listener(new RequestListener&lt;Drawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onLoadFailed(@Nullable GlideException e, Object model, Target&lt;Drawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, e);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean onResourceReady(Drawable resource, Object model, Target&lt;Drawable&gt; target, DataSource dataSource, boolean isFirstResource) &#123;</span><br><span class="line">                        mainThreadCallback(url,mLastBytesRead, mTotalBytes, true, null);</span><br><span class="line">                        ProgressManager.removeProgressListener(internalProgressListener);</span><br><span class="line">                        return false;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).into(imageView);</span><br><span class="line"></span><br><span class="line">        //赋值 上去</span><br><span class="line">        this.onProgressListener = onProgressListener;</span><br><span class="line">        mMainThreadHandler = new Handler(Looper.getMainLooper());</span><br><span class="line">        internalProgressListener = new OnProgressListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onProgress(String imageUrl, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">                if (totalBytes == 0) return;</span><br><span class="line">                if (mLastBytesRead == bytesRead &amp;&amp; mLastStatus == isDone) return;</span><br><span class="line"></span><br><span class="line">                mLastBytesRead = bytesRead;</span><br><span class="line">                mTotalBytes = totalBytes;</span><br><span class="line">                mLastStatus = isDone;</span><br><span class="line">                mainThreadCallback(imageUrl,bytesRead, totalBytes, isDone, exception);</span><br><span class="line"></span><br><span class="line">                if (isDone) &#123;</span><br><span class="line">                    ProgressManager.removeProgressListener(this);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ProgressManager.addProgressListener(internalProgressListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Context context, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line"></span><br><span class="line">        if (transitionOptions instanceof DrawableTransitionOptions)&#123;</span><br><span class="line">            GlideApp.with(context)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition((DrawableTransitionOptions)transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            GlideApp.with(context)</span><br><span class="line">                    .asBitmap()</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition(transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Activity activity, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line">        if (transitionOptions instanceof DrawableTransitionOptions)&#123;</span><br><span class="line">            GlideApp.with(activity)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition((DrawableTransitionOptions)transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            GlideApp.with(activity)</span><br><span class="line">                    .asBitmap()</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition(transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Fragment fragment, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line">        if (transitionOptions instanceof DrawableTransitionOptions)&#123;</span><br><span class="line">            GlideApp.with(fragment)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition((DrawableTransitionOptions)transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            GlideApp.with(fragment)</span><br><span class="line">                    .asBitmap()</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .transition(transitionOptions)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Context context) &#123;</span><br><span class="line">        GlideApp.with(context).pauseRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Activity activity) &#123;</span><br><span class="line">        GlideApp.with(activity).pauseRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Fragment fragment) &#123;</span><br><span class="line">        GlideApp.with(fragment).pauseRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Context context) &#123;</span><br><span class="line">        GlideApp.with(context).resumeRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Activity activity) &#123;</span><br><span class="line">        GlideApp.with(activity).resumeRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Fragment fragment) &#123;</span><br><span class="line">        GlideApp.with(fragment).resumeRequests();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     *  加载缩略图</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url 图片url</span><br><span class="line">     * @param backUrl 缩略图的url</span><br><span class="line">     * @param thumbnailSize 如果需要放大放小的数值</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Context context, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line"></span><br><span class="line">        if(thumbnailSize == 0) &#123;</span><br><span class="line">            GlideApp.with(context)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(Glide.with(context)</span><br><span class="line">                            .load(backUrl))</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">            //越小，图片越小，低网络的情况，图片越小</span><br><span class="line">            GlideApp.with(context)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .diskCacheStrategy(DiskCacheStrategy.NONE)//为了测试不缓存</span><br><span class="line">                    .thumbnail(GlideApp.with(context)</span><br><span class="line">                            .load(backUrl)</span><br><span class="line">                            .override(thumbnailSize))// API 来强制 Glide 在缩略图请求中加载一个低分辨率图像</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Activity activity, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if(thumbnailSize == 0) &#123;</span><br><span class="line">            GlideApp.with(activity)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(Glide.with(activity)</span><br><span class="line">                            .load(backUrl))</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">            //越小，图片越小，低网络的情况，图片越小</span><br><span class="line">            GlideApp.with(activity)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .diskCacheStrategy(DiskCacheStrategy.NONE)//为了测试不缓存</span><br><span class="line">                    .thumbnail(GlideApp.with(activity)</span><br><span class="line">                            .load(backUrl)</span><br><span class="line">                            .override(thumbnailSize))// API 来强制 Glide 在缩略图请求中加载一个低分辨率图像</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if(thumbnailSize == 0) &#123;</span><br><span class="line">            GlideApp.with(fragment)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(Glide.with(fragment)</span><br><span class="line">                            .load(backUrl))</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line"></span><br><span class="line">            //越小，图片越小，低网络的情况，图片越小</span><br><span class="line">            GlideApp.with(fragment)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .diskCacheStrategy(DiskCacheStrategy.NONE)//为了测试不缓存</span><br><span class="line">                    .thumbnail(GlideApp.with(fragment)</span><br><span class="line">                            .load(backUrl)</span><br><span class="line">                            .override(thumbnailSize))// API 来强制 Glide 在缩略图请求中加载一个低分辨率图像</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  * thumbnail 方法有一个简化版本，它只需要一个 sizeMultiplier 参数。</span><br><span class="line">     * 如果你只是想为你的加载相同的图片，但尺寸为 View 或 Target 的某个百分比的话特别有用：</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param thumbnailSize</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if(thumbnailSize &gt;= 0.0F &amp;&amp; thumbnailSize &lt;= 1.0F) &#123;</span><br><span class="line">            GlideApp.with(fragment)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(/*sizeMultiplier=*/ thumbnailSize)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;thumbnailSize 的值必须在0到1之间&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Activity activity, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if(thumbnailSize &gt;= 0.0F &amp;&amp; thumbnailSize &lt;= 1.0F) &#123;</span><br><span class="line">            GlideApp.with(activity)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(/*sizeMultiplier=*/ thumbnailSize)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;thumbnailSize 的值必须在0到1之间&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Context context, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if(thumbnailSize &gt;= 0.0F &amp;&amp; thumbnailSize &lt;= 1.0F) &#123;</span><br><span class="line">            GlideApp.with(context)</span><br><span class="line">                    .load(url)</span><br><span class="line">                    .thumbnail(/*sizeMultiplier=*/ thumbnailSize)</span><br><span class="line">                    .into(imageView);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;thumbnailSize 的值必须在0到1之间&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Handler mMainThreadHandler;</span><br><span class="line">    private long mTotalBytes = 0;</span><br><span class="line">    private long mLastBytesRead = 0;</span><br><span class="line">    private void mainThreadCallback(final String url, final long bytesRead, final long totalBytes, final boolean isDone, final GlideException exception) &#123;</span><br><span class="line">        mMainThreadHandler.post(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                // TODO: 2018/4/20 放慢效果  实际的项目中给我去掉</span><br><span class="line">                SystemClock.sleep(100);</span><br><span class="line">                final int percent = (int) ((bytesRead * 1.0f / totalBytes) * 100.0f);</span><br><span class="line">                if (onProgressListener != null) &#123;</span><br><span class="line">                    onProgressListener.onProgress(url, bytesRead, totalBytes, isDone, exception);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (onGlideImageViewListener != null) &#123;</span><br><span class="line">                    onGlideImageViewListener.onProgress(percent, isDone, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private boolean mLastStatus = false;</span><br><span class="line">    private OnProgressListener internalProgressListener;</span><br><span class="line">    private OnGlideImageViewListener onGlideImageViewListener;</span><br><span class="line">    private OnProgressListener onProgressListener;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定传入的那种图片的变形</span><br><span class="line">     * @param placeholderResId</span><br><span class="line">     * @param errorResId</span><br><span class="line">     * @param transformation</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public RequestOptions requestOptionsTransform(int placeholderResId, int errorResId,Transformation transformation) &#123;</span><br><span class="line">        return new RequestOptions()</span><br><span class="line">                .placeholder(placeholderResId)</span><br><span class="line">                .error(errorResId).transform(transformation);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 加载资源文件的同时，对图片进行处理</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param transformations</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).transform(transformations).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).transform(transformations).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当传入到其他的东西的时候，我要保证图片不变形</span><br><span class="line">     * @param placeholderResId</span><br><span class="line">     * @param errorResId</span><br><span class="line">     * @param transformation</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public RequestOptions requestOptionsNoTransform(int placeholderResId, int errorResId, Transformation&lt;Bitmap&gt; transformation) &#123;</span><br><span class="line">        return new RequestOptions()</span><br><span class="line">                .placeholder(placeholderResId)</span><br><span class="line">                .error(errorResId).transform(transformation);</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 加载资源文件失败了，加载中的默认图和失败的图片</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, int defRes) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    //关心context</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).transform(transformations).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    //关心fragment</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        GlideApp.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).transform(transformations).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ImageLoaderV4调用类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br></pre></td><td class="code"><pre><span class="line">package code.shiming.com.imageloader471;</span><br><span class="line"></span><br><span class="line">import android.app.Activity;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.graphics.Bitmap;</span><br><span class="line">import android.support.v4.app.Fragment;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line"></span><br><span class="line">import com.bumptech.glide.TransitionOptions;</span><br><span class="line">import com.bumptech.glide.load.Transformation;</span><br><span class="line">import com.bumptech.glide.load.engine.DiskCacheStrategy;</span><br><span class="line">import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"></span><br><span class="line">import java.io.File;</span><br><span class="line"></span><br><span class="line">import code.shiming.com.imageloader471.listener.IGetBitmapListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.IGetDrawableListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.IImageLoaderListener;</span><br><span class="line">import code.shiming.com.imageloader471.listener.ImageSize;</span><br><span class="line">import code.shiming.com.imageloader471.okhttp.OnGlideImageViewListener;</span><br><span class="line">import code.shiming.com.imageloader471.okhttp.OnProgressListener;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> */</span><br><span class="line">public class ImageLoaderV4 implements IImageLoaderClient &#123;</span><br><span class="line">    /**</span><br><span class="line">     * volatile 关键字：我个人理解的是：使用volatile关键字的程序在并发时能够正确执行。</span><br><span class="line">     * 但是它不能够代替synchronized关键字。在网上找到这么一句话：</span><br><span class="line">     * 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，</span><br><span class="line">     * 加入volatile关键字时，会多出一个lock前缀指令lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），</span><br><span class="line">     * 内存屏障会提供3个功能：1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，</span><br><span class="line">     * 也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</span><br><span class="line">     * 2）它会强制将对缓存的修改操作立即写入主存；3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</span><br><span class="line">     */</span><br><span class="line">    private volatile static ImageLoaderV4 instance;</span><br><span class="line">    private IImageLoaderClient client;</span><br><span class="line"></span><br><span class="line">    private ImageLoaderV4() &#123;</span><br><span class="line">        client = new GlideImageLoaderClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /***</span><br><span class="line">     * 设置 图片加载库客户端</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public void setImageLoaderClient(Context context, IImageLoaderClient client) &#123;</span><br><span class="line">        if (this.client != null) &#123;</span><br><span class="line">            this.client.clearMemoryCache(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.client != client) &#123;</span><br><span class="line">            this.client = client;</span><br><span class="line">            if (this.client != null) &#123;</span><br><span class="line">                this.client.init(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 因为每次调用实例都需要判断同步锁，很多项目包括很多人都是用这种的</span><br><span class="line">     * 双重判断校验的方法，这种的方法看似很完美的解决了效率的问题，但是它</span><br><span class="line">     * 在并发量不多，安全性不太高的情况下能完美的运行，但是，</span><br><span class="line">     * 在jvm编译的过程中会出现指令重排的优化过程，这就会导致singleton实际上</span><br><span class="line">     * 没有被初始化，就分配了内存空间，也就是说singleton！=null但是又没有被初始化，</span><br><span class="line">     * 这就会导致返回的singletonthird返回的是不完整的</span><br><span class="line">     * 参考：http://www.360doc.com/content/11/0810/12/1542811_139352888.shtml</span><br><span class="line">     * 建议使用内部类实现单利模式</span><br><span class="line">     */</span><br><span class="line">    public static ImageLoaderV4 getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (ImageLoaderV4.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new ImageLoaderV4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(Context context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.destroy(context);</span><br><span class="line">            client = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instance = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public File getCacheDir(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            return client.getCacheDir(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearMemoryCache(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clearMemoryCache(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearDiskCache(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clearDiskCache(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            return client.getBitmapFromCache(context, url);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不是</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param listener</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void getBitmapFromCache(Context context, String url, IGetBitmapListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.getBitmapFromCache(context, url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, resId, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView,isCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes,BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, cacheInMemory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, cacheInMemory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayCircleImage(context, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayCircleImage(fragment, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayRoundImage(context, url, imageView, defRes, radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, final IGetDrawableListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, url, blurRadius, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayRoundImage(fragment, url, imageView, defRes, radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, url, imageView, defRes, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, resId, imageView, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(fragment, url, imageView, defRes, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId,  imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId,  imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId, imageView, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes, BitmapTransformation transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId,  imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Activity activity, int resId, ImageView imageView, Transformation transformation, int errorResId) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResourceTransform(activity, resId,  imageView, transformation, errorResId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Context context, int resId, ImageView imageView, Transformation transformation, int errorResId) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResourceTransform(context, resId,  imageView, transformation, errorResId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResourceTransform(Fragment fragment, int resId, ImageView imageView, Transformation transformation, int errorResId) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResourceTransform(fragment, resId,  imageView, transformation, errorResId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Context context, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByNet(context, url,  imageView, defRes, transformation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Fragment fragment, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByNet(fragment, url,  imageView, defRes, transformation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByNet(Activity activity, String url, ImageView imageView, int defRes, Transformation transformation) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByNet(activity, url,  imageView, defRes, transformation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。</span><br><span class="line">     * 实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，</span><br><span class="line">     * Glide 会自动取消加载并回收资源。这里我隐藏了api的调用</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Activity activity, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clear(activity, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。</span><br><span class="line">     * 实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，</span><br><span class="line">     * Glide 会自动取消加载并回收资源。这里我隐藏了api的调用</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Context context, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clear(context, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**尽管及时取消不必要的加载是很好的实践，但这并不是必须的操作。</span><br><span class="line">     * 实际上，当 Glide.with() 中传入的 Activity 或 Fragment 实例销毁时，</span><br><span class="line">     * Glide 会自动取消加载并回收资源。这里我隐藏了api的调用</span><br><span class="line">     * &#123;@hide&#125;</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void clear(Fragment fragment, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clear(fragment, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 指定选择哪种缓存的策略</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param diskCacheStrategy</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Fragment fragment, String url, DiskCacheStrategy diskCacheStrategy, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByDiskCacheStrategy(fragment, url,  diskCacheStrategy, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Activity activity, String url, DiskCacheStrategy diskCacheStrategy, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByDiskCacheStrategy(activity, url,  diskCacheStrategy, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByDiskCacheStrategy(Context context, String url, DiskCacheStrategy diskCacheStrategy, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByDiskCacheStrategy(context, url,  diskCacheStrategy, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageOnlyRetrieveFromCache(fragment, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Activity activity, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageOnlyRetrieveFromCache(activity, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageOnlyRetrieveFromCache(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageOnlyRetrieveFromCache(context, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Fragment fragment, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageSkipMemoryCache(fragment, url, imageView,skipflag,diskCacheStratey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Activity activity, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageSkipMemoryCache(activity, url, imageView,skipflag,diskCacheStratey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageSkipMemoryCache(Context context, String url, ImageView imageView, boolean skipflag, boolean diskCacheStratey) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageSkipMemoryCache(context, url, imageView,skipflag,diskCacheStratey);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Fragment fragment, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageErrorReload(fragment, url,fallbackUrl, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Activity activity, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageErrorReload(activity, url,fallbackUrl, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageErrorReload(Context context, String url, String fallbackUrl, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageErrorReload(context, url,fallbackUrl, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImagedisallowHardwareConfig(fragment, url,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Activity activity, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImagedisallowHardwareConfig(activity, url,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImagedisallowHardwareConfig(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImagedisallowHardwareConfig(context, url,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Context context, String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgress(context, url,imageView,placeholderResId,errorResId,listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Activity activity, String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgress(activity, url,imageView,placeholderResId,errorResId,listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgress(Fragment fragment, String url, ImageView imageView, int placeholderResId, int errorResId, OnGlideImageViewListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgress(fragment, url,imageView,placeholderResId,errorResId,listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Context context, String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgressByOnProgressListener(context, url,imageView,placeholderResId,errorResId,onProgressListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Activity activity, String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgressByOnProgressListener(activity, url,imageView,placeholderResId,errorResId,onProgressListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 需要监听 总的字节数，和文件的大小，同时也可以扩展为，加载本地图片</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param placeholderResId</span><br><span class="line">     * @param errorResId</span><br><span class="line">     * @param onProgressListener</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void disPlayImageProgressByOnProgressListener(Fragment fragment, String url, ImageView imageView, int placeholderResId, int errorResId, OnProgressListener onProgressListener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.disPlayImageProgressByOnProgressListener(fragment, url,imageView,placeholderResId,errorResId,onProgressListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 过渡选项</span><br><span class="line">     TransitionOptions 用于决定你的加载完成时会发生什么。</span><br><span class="line">     使用 TransitionOption 可以应用以下变换：</span><br><span class="line">     View淡入</span><br><span class="line">     与占位符交叉淡入</span><br><span class="line">     或者什么都不发生</span><br><span class="line">     从白色 慢慢变透明 5s的间隔</span><br><span class="line">     GlideApp.with(this)</span><br><span class="line">     .load(ur11)</span><br><span class="line">     .transition(withCrossFade(5000)) 可以传入过度的时间</span><br><span class="line">     .into(mImageView_7);</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Context context, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByTransition(context, url,transitionOptions,imageView);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Activity activity, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByTransition(activity, url,transitionOptions,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageByTransition(Fragment fragment, String url, TransitionOptions transitionOptions, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageByTransition(fragment, url,transitionOptions,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glidePauseRequests(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Activity activity) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glidePauseRequests(activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glidePauseRequests(Fragment fragment) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glidePauseRequests(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glideResumeRequests(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Activity activity) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glideResumeRequests(activity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void glideResumeRequests(Fragment fragment) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.glideResumeRequests(fragment);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Context context, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(context,url,backUrl,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Activity activity, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(activity,url,backUrl,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment, String url, String backUrl, int thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(fragment,url,backUrl,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 没有地址也需要指定缩略图</span><br><span class="line">     * @param fragment</span><br><span class="line">     * @param url</span><br><span class="line">     * @param thumbnailSize</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Fragment fragment, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(fragment,url,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Activity activity, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(activity,url,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageThumbnail(Context context, String url, float thumbnailSize, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageThumbnail(context,url,thumbnailSize,imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于图片下载进度的监听,在AppGlideModuleProgress 需要初始化ProgressManager<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class AppGlideModuleProgress extends AppGlideModule &#123;</span><br><span class="line">    /**</span><br><span class="line">     OkHttp 是一个底层网络库(相较于 Cronet 或 Volley 而言)，尽管它也包含了 SPDY 的支持。</span><br><span class="line">     OkHttp 与 Glide 一起使用可以提供可靠的性能，并且在加载图片时通常比 Volley 产生的垃圾要少。</span><br><span class="line">     对于那些想要使用比 Android 提供的 HttpUrlConnection 更 nice 的 API，</span><br><span class="line">      或者想确保网络层代码不依赖于 app 安装的设备上 Android OS 版本的应用，OkHttp 是一个合理的选择。</span><br><span class="line">      如果你已经在 app 中某个地方使用了 OkHttp ，这也是选择继续为 Glide 使用 OkHttp 的一个很好的理由，就像选择其他网络库一样。</span><br><span class="line">     添加 OkHttp 集成库的 Gradle 依赖将使 Glide 自动开始使用 OkHttp 来加载所有来自 http 和 https URL 的图片</span><br><span class="line">     * @param context</span><br><span class="line">     * @param glide</span><br><span class="line">     * @param registry</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void registerComponents(Context context, Glide glide, Registry registry) &#123;</span><br><span class="line">        super.registerComponents(context, glide, registry);</span><br><span class="line">        registry.replace(GlideUrl.class, InputStream.class, new OkHttpUrlLoader.Factory(ProgressManager.getOkHttpClient()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ProgressManager</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">public class ProgressManager &#123;</span><br><span class="line"></span><br><span class="line">    private static List&lt;WeakReference&lt;OnProgressListener&gt;&gt; listeners = Collections.synchronizedList(new ArrayList&lt;WeakReference&lt;OnProgressListener&gt;&gt;());</span><br><span class="line">    private static OkHttpClient okHttpClient;</span><br><span class="line"></span><br><span class="line">    private ProgressManager() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static OkHttpClient getOkHttpClient() &#123;</span><br><span class="line">        if (okHttpClient == null) &#123;</span><br><span class="line">            okHttpClient = new OkHttpClient.Builder()</span><br><span class="line">                    .addNetworkInterceptor(new Interceptor() &#123;</span><br><span class="line">                        @Override</span><br><span class="line">                        public Response intercept(@NonNull Chain chain) throws IOException &#123;</span><br><span class="line">                            Request request = chain.request();</span><br><span class="line">                            Response response = chain.proceed(request);</span><br><span class="line">                            return response.newBuilder()</span><br><span class="line">                                    .body(new ProgressResponseBody(request.url().toString(), response.body(), LISTENER))</span><br><span class="line">                                    .build();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        return okHttpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static final OnProgressListener LISTENER = new OnProgressListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onProgress(String imageUrl, long bytesRead, long totalBytes, boolean isDone, GlideException exception) &#123;</span><br><span class="line">            if (listeners == null || listeners.size() == 0) return;</span><br><span class="line"></span><br><span class="line">            for (int i = 0; i &lt; listeners.size(); i++) &#123;</span><br><span class="line">                WeakReference&lt;OnProgressListener&gt; listener = listeners.get(i);</span><br><span class="line">                OnProgressListener progressListener = listener.get();</span><br><span class="line">                if (progressListener == null) &#123;</span><br><span class="line">                    listeners.remove(i);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    progressListener.onProgress(imageUrl, bytesRead, totalBytes, isDone, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public static void addProgressListener(OnProgressListener progressListener) &#123;</span><br><span class="line">        if (progressListener == null) return;</span><br><span class="line"></span><br><span class="line">        if (findProgressListener(progressListener) == null) &#123;</span><br><span class="line">            listeners.add(new WeakReference&lt;&gt;(progressListener));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void removeProgressListener(OnProgressListener progressListener) &#123;</span><br><span class="line">        if (progressListener == null) return;</span><br><span class="line"></span><br><span class="line">        WeakReference&lt;OnProgressListener&gt; listener = findProgressListener(progressListener);</span><br><span class="line">        if (listener != null) &#123;</span><br><span class="line">            listeners.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static WeakReference&lt;OnProgressListener&gt; findProgressListener(OnProgressListener listener) &#123;</span><br><span class="line">        if (listener == null) return null;</span><br><span class="line">        if (listeners == null || listeners.size() == 0) return null;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; listeners.size(); i++) &#123;</span><br><span class="line">            WeakReference&lt;OnProgressListener&gt; progressListener = listeners.get(i);</span><br><span class="line">            if (progressListener.get() == listener) &#123;</span><br><span class="line">                return progressListener;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ProgressResponseBody<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class ProgressResponseBody extends ResponseBody &#123;</span><br><span class="line"></span><br><span class="line">    private String imageUrl;</span><br><span class="line">    private ResponseBody responseBody;</span><br><span class="line">    private OnProgressListener progressListener;</span><br><span class="line">    private BufferedSource bufferedSource;</span><br><span class="line"></span><br><span class="line">    public ProgressResponseBody(String url, ResponseBody responseBody, OnProgressListener progressListener) &#123;</span><br><span class="line">        this.imageUrl = url;</span><br><span class="line">        this.responseBody = responseBody;</span><br><span class="line">        this.progressListener = progressListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public MediaType contentType() &#123;</span><br><span class="line">        return responseBody.contentType();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long contentLength() &#123;</span><br><span class="line">        return responseBody.contentLength();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public BufferedSource source() &#123;</span><br><span class="line">        if (bufferedSource == null) &#123;</span><br><span class="line">            bufferedSource = Okio.buffer(source(responseBody.source()));</span><br><span class="line">        &#125;</span><br><span class="line">        return bufferedSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Source source(Source source) &#123;</span><br><span class="line">        return new ForwardingSource(source) &#123;</span><br><span class="line">            long totalBytesRead = 0;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public long read(@NonNull Buffer sink, long byteCount) throws IOException &#123;</span><br><span class="line">                long bytesRead = super.read(sink, byteCount);</span><br><span class="line">                totalBytesRead += (bytesRead == -1) ? 0 : bytesRead;</span><br><span class="line"></span><br><span class="line">                if (progressListener != null) &#123;</span><br><span class="line">                    progressListener.onProgress(imageUrl, totalBytesRead, contentLength(), (bytesRead == -1), null);</span><br><span class="line">                &#125;</span><br><span class="line">                return bytesRead;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OnProgressListener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface OnProgressListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">      * @param imageUrl 图片地址</span><br><span class="line">     * @param bytesRead 下载了多少字节</span><br><span class="line">     * @param totalBytes 总共的大小</span><br><span class="line">     * @param isDone 是否完成</span><br><span class="line">     * @param exception 异常</span><br><span class="line">     */</span><br><span class="line">    void onProgress(String imageUrl, long bytesRead, long totalBytes, boolean isDone, GlideException exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OnGlideImageViewListener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface OnGlideImageViewListener &#123;</span><br><span class="line">    /**</span><br><span class="line">     * </span><br><span class="line">     * @param percent 下载进度的百分比，不关心，大小</span><br><span class="line">     * @param isDone 是否完成</span><br><span class="line">     * @param exception 异常</span><br><span class="line">     */</span><br><span class="line">    void onProgress(int percent, boolean isDone, GlideException exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>glide4.X优点<br> 1、新的文档，用户可以通过提交请求到Glide’s gh-pages分支贡献。<br>2、用户可以添加新类型或自定义选项集来轻松地自定义Glide流畅的API。大量简化个人请求类型，确保选项始终如一，易于使用，即使您正在加载不同类型的资源。<br>3、各种性能改进，包括在下载采样图像时大量减少垃圾，更加智能的默认磁盘缓存策略，以及加载GIF时性能提升。<br>4、改进了视图大小和布局的处理，特别是在RecyclerView中。<br>官方文档：<a href="https://muyangmin.github.io/glide-docs-cn/" target="_blank" rel="noopener">https://muyangmin.github.io/glide-docs-cn/</a></p><p>Glide V4变化较大的是库处理选项的方式。在Glide v3中，选项是由一系列复杂的多类型构建器单独处理的。在Glide v4中，这些已被具有单一类型的单个构建器和可以提供给构建器的一系列选项的对象所替代。Glide 生成的API通过将选项对象和任何包含的集成库与构建器的选项合并，来创建单个流畅的API。 可以简单理解为，Glide v4 将Glide V3中Glide.with()实现的一系列复杂功能拆分成一些独立的API。</p><p>建议看官方文档，虽然需要点时间！</p><p>#####最后总结下Glide4.X对比Glide3.X的区别：</p><p>######1、选项(Options)<br>Glide v4 中的一个比较大的改动是Glide库处理选项(<code>centerCrop()</code>, <code>placeholder()</code> 等)的方式。在 v3 版本中，选项由一系列复杂的异构建造者(multityped builders)单独处理。在新版本中，由一个单一类型的唯一一个建造者接管一系列选项对象。Glide 的<a href="https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html" target="_blank" rel="noopener">generated API</a>进一步简化了这个操作：它会合并传入建造者的选项对象和任何已包含的集成库里的选项，以生成一个流畅的 API。</p><p>######2、RequestBuilder<br>对于这类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listener()</span><br><span class="line">thumbnail()</span><br><span class="line">load()</span><br><span class="line">into()</span><br></pre></td></tr></table></figure><p>在 Glide v4 版本中，只存在一个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html" target="_blank" rel="noopener"><code>RequestBuilder</code></a> 对应一个你正在试图加载的类型(<code>Bitmap</code>, <code>Drawable</code>, <code>GifDrawable</code> 等)。 <code>RequestBuilder</code> 可以直接访问对这个加载过程有影响的选项，包括你想加载的数据模型（url, uri等），可能存在的<a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#thumbnail-com.bumptech.glide.RequestBuilder-" target="_blank" rel="noopener"><code>缩略图</code></a>请求，以及任何的<a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#listener-com.bumptech.glide.request.RequestListener-" target="_blank" rel="noopener"><code>监听器</code></a>。<code>RequestBuilder</code>也是你使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#into-Y-" target="_blank" rel="noopener"><code>into()</code></a> 或者 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#preload-int-int-" target="_blank" rel="noopener"><code>preload()</code></a> 方法开始加载的地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RequestBuilder&lt;Drawable&gt; requestBuilder = Glide.with(fragment)</span><br><span class="line">    .load(url);</span><br><span class="line"></span><br><span class="line">requestBuilder</span><br><span class="line">    .thumbnail(Glide.with(fragment)</span><br><span class="line">        .load(thumbnailUrl))</span><br><span class="line">    .listener(requestListener)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure></p><p>######3、请求选项<br>对于这类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">centerCrop()</span><br><span class="line">placeholder()</span><br><span class="line">error()</span><br><span class="line">priority()</span><br><span class="line">diskCacheStrategy()</span><br></pre></td></tr></table></figure><p>大部分选项被移动到了一个单独的称为 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestOptions.html" target="_blank" rel="noopener"><code>RequestOptions</code></a> 的对象中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions options = new RequestOptions()</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.placeholder)</span><br><span class="line">    .error(R.drawable.error)</span><br><span class="line">    .priority(Priority.HIGH);</span><br></pre></td></tr></table></figure><p><code>RequestOptions</code> 允许你一次指定一系列的选项，然后对多个加载重用它们：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RequestOptions myOptions = new RequestOptions()</span><br><span class="line">    .fitCenter()</span><br><span class="line">    .override(100, 100);</span><br><span class="line"></span><br><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .apply(myOptions)</span><br><span class="line">    .into(drawableView);</span><br><span class="line"></span><br><span class="line">Glide.with(fragment)</span><br><span class="line">    .asBitmap()</span><br><span class="line">    .apply(myOptions)</span><br><span class="line">    .load(url)</span><br><span class="line">    .into(bitmapView);</span><br></pre></td></tr></table></figure><p>######4、变换<br>Glide v4 里的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/Transformation.html" target="_blank" rel="noopener"><code>Transformations</code></a> 现在会替换之前设置的任何变换。在 Glide v4 中，如果你想应用超过一个的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/Transformation.html" target="_blank" rel="noopener"><code>Transformation</code></a>，你需要使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/request/RequestOptions.html#transforms-com.bumptech.glide.load.Transformation...-" target="_blank" rel="noopener"><code>transforms()</code></a> 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">  .load(url)</span><br><span class="line">  .apply(new RequestOptions().transforms(new CenterCrop(), new RoundedCorners(20)))</span><br><span class="line">  .into(target);</span><br></pre></td></tr></table></figure><p>或使用 <a href="https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html" target="_blank" rel="noopener">generated API</a>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(fragment)</span><br><span class="line">  .load(url)</span><br><span class="line">  .transforms(new CenterCrop(), new RoundedCorners(20))</span><br><span class="line">  .into(target);</span><br></pre></td></tr></table></figure><p>######5、解码格式<br>在 Glide v3， 默认的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html" target="_blank" rel="noopener"><code>DecodeFormat</code></a> 是 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html#PREFER_RGB_565" target="_blank" rel="noopener"><code>DecodeFormat.PREFER_RGB_565</code></a>，它将使用 [<code>Bitmap.Config.RGB_565</code>]，除非图片包含或可能包含透明像素。对于给定的图片尺寸，<code>RGB_565</code> 只使用 [<code>Bitmap.Config.ARGB_8888</code>] 一半的内存，但对于特定的图片有明显的画质问题，包括条纹(banding)和着色(tinting)。为了避免<code>RGB_565</code>的画质问题，Glide 现在默认使用 <code>ARGB_8888</code>。结果是，图片质量变高了，但内存使用也增加了。</p><p>要将 Glide v4 默认的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html" target="_blank" rel="noopener"><code>DecodeFormat</code></a> 改回 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/410/com/bumptech/glide/load/DecodeFormat.html#PREFER_RGB_565" target="_blank" rel="noopener"><code>DecodeFormat.PREFER_RGB_565</code></a>，请在 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> 中应用一个 <code>RequestOption</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public final class YourAppGlideModule extends GlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line">    builder.setDefaultRequestOptions(new RequestOptions().format(DecodeFormat.PREFER_RGB_565));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModules</code></a> 的更多信息，请查阅 <a href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html" target="_blank" rel="noopener">配置</a> 页面。请注意，为了让 Glide 发现你的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> 实现，你必须确保添加了对 Glide 的注解解析器的依赖。关于如何设置这个库的更多信息，请查看 <a href="https://muyangmin.github.io/glide-docs-cn/doc/download-setup.html" target="_blank" rel="noopener">下载和设置</a>。</p><p>######6、过渡选项<br>对于这类方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crossFade()</span><br><span class="line">animate()</span><br></pre></td></tr></table></figure><p>控制从占位符到图片和/或缩略图到全图的交叉淡入和其他类型变换的选项，被移动到了 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html" target="_blank" rel="noopener"><code>TransitionOptions</code></a> 中。</p><p>要应用过渡（之前的动画），请使用下列选项中符合你请求的资源类型的一个：</p><ul><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/GenericTransitionOptions.html" target="_blank" rel="noopener"><code>GenericTransitionOptions</code></a></li><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/drawable/DrawableTransitionOptions.html" target="_blank" rel="noopener"><code>DrawableTransitionOptions</code></a></li><li><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/resource/bitmap/BitmapTransitionOptions.html" target="_blank" rel="noopener"><code>BitmapTransitionOptions</code></a></li></ul><p>如果你想移除任何默认的过渡，可以使用 <code>TransitionOptions.dontTransition()</code>]<a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/TransitionOptions.html#dontTransition--" target="_blank" rel="noopener">17</a> 。</p><p>过渡动画通过 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html" target="_blank" rel="noopener"><code>RequestBuilder</code></a> 应用到请求上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .transition(withCrossFade(R.anim.fade_in, 300));</span><br></pre></td></tr></table></figure><p>######7、交叉淡入 (Cross fade)<br>不同于 Glide v3，Glide v4 将不会默认应用交叉淡入或任何其他的过渡效果。每个请求必须手动应用过渡。</p><p>要为一个特定的加载应用一个交叉淡入变换效果，你可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import static com.bumptech.glide.load.resource.drawable.DrawableTransitionOptions.withCrossFade;</span><br><span class="line"></span><br><span class="line">Glide.with(fragment)</span><br><span class="line">  .load(url)</span><br><span class="line">  .transition(withCrossFade())</span><br><span class="line">  .into(imageView);</span><br></pre></td></tr></table></figure></p><p>或:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">  .load(url)</span><br><span class="line">  .transition(</span><br><span class="line">      new DrawableTransitionOptions</span><br><span class="line">        .crossFade())</span><br><span class="line">  .into(imageView);</span><br></pre></td></tr></table></figure></p><p>######8、Generated API<br>为了让使用 Glide v4 更简单轻松，Glide 现在也提供了一套可以为应用定制化生成的 API。应用可以通过包含一个标记了 [<code>AppGlideModule</code>][<a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener">2</a> 的实现来访问生成的 API。如果你不了解这是怎么工作的，可以查看 <a href="https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html" target="_blank" rel="noopener">Generated API</a> 。</p><p>Generated API添加了一个 <code>GlideApp</code> 类，该类提供了对 <code>RequestBuilder</code> 和 <code>RequestOptions</code> 子类的访问。<code>RequestOptions</code> 的子类包含了所有 <code>RequestOptions</code> 中的方法，以及 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/annotation/GlideExtension.html" target="_blank" rel="noopener"><code>GlideExtensions</code></a> 中定义的方法。<code>RequestBuilder</code> 的子类则提供了生成的 <code>RequestOptions</code> 中所有方法的访问，而不需要你再手动调用 <code>apply</code> 。举个例子：</p><p>在没有使用 Generated API 时，请求大概长这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .apply(centerCropTransform()</span><br><span class="line">        .placeholder(R.drawable.placeholder)</span><br><span class="line">        .error(R.drawable.error)</span><br><span class="line">        .priority(Priority.HIGH))</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><p>使用 Generated API，<code>RequestOptions</code> 的调用可以被内联：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GlideApp.with(fragment)</span><br><span class="line">    .load(url)</span><br><span class="line">    .centerCrop()</span><br><span class="line">    .placeholder(R.drawable.placeholder)</span><br><span class="line">    .error(R.drawable.error)</span><br><span class="line">    .priority(Priority.HIGH)</span><br><span class="line">    .into(imageView);</span><br></pre></td></tr></table></figure><p>你仍然可以使用生成的 <code>RequestOptions</code> 子类来应用相同的选项到多次加载中；但生成的 <code>RequestBuilder</code> 子类可能在多数情况下更为方便。</p><p>######9、类型(Type)与目标(Target)</p><h3 id="选择资源类型"><a href="#选择资源类型" class="headerlink" title="选择资源类型"></a>选择资源类型<a href="https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#%E9%80%89%E6%8B%A9%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener"></a></h3><p>Glide 允许你指定你想加载的资源类型。如果你指定了一个超类型，Glide 会尝试加载任何可用的子类型。比如，如果你请求的是 Drawable ，Glide 可能会加载一个 BitmapDrawable 或一个 GifDrawable 。而如果你请求的是一个 GifDrawable ，要么会加载出一个 GifDrawable，要么报错–只要图片不是 GIF 的话（即使它凑巧是一个完全有效的图片也是如此）。</p><p>默认请求的类型是 Drawable：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment).load(url)</span><br></pre></td></tr></table></figure><p>如果要明确指定请求 Bitmap：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment).asBitmap()</span><br></pre></td></tr></table></figure><p>如果要创建一个文件路径（本地图片的最佳选项）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment).asFile()</span><br></pre></td></tr></table></figure><p>如果要下载一个远程文件到缓存然后创建文件路径：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment).downloadOnly()</span><br><span class="line">// or if you have the url already:</span><br><span class="line">Glide.with(fragment).download(url);</span><br></pre></td></tr></table></figure><p>######10、Drawables<br>Glide v3 版本中的 <code>GlideDrawable</code> 类已经被移除，支持标准的Android <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="noopener"><code>Drawable</code></a>。 <code>GlideBitmapDrawable</code> 也已经被删除，由 <a href="https://developer.android.com/reference/android/graphics/drawable/BitmapDrawable.html" target="_blank" rel="noopener"><code>BitmapDrawable</code></a> 代替之。</p><p>如果你想知道某个 Drawable 是否是动画(animated)，可以检查它是否为 <a href="https://developer.android.com/reference/android/graphics/drawable/Animatable.html" target="_blank" rel="noopener"><code>Animatable</code></a> 的实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean isAnimated = drawable instanceof Animatable;</span><br></pre></td></tr></table></figure><p>######11、Targets<br><code>onResourceReady</code> 方法的签名做了一些修改。例如，对于 <code>Drawables</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onResourceReady(GlideDrawable drawable, GlideAnimation&lt;? super GlideDrawable&gt; anim)</span><br></pre></td></tr></table></figure><p>现在改为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onResourceReady(Drawable drawable, Transition&lt;? super Drawable&gt; transition);</span><br></pre></td></tr></table></figure><p>类似地, <code>onLoadFailed</code> 的签名也有一些变动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onLoadFailed(Exception e, Drawable errorDrawable)</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onLoadFailed(Drawable errorDrawable)</span><br></pre></td></tr></table></figure><p>如果你想要获得更多导致加载失败的错误信息，你可以使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/request/RequestListener.html" target="_blank" rel="noopener"><code>RequestListener</code></a> 。</p><p>######12、取消请求<br><code>Glide.clear(Target)</code> 方法被移动到了 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestManager.html" target="_blank" rel="noopener"><code>RequestManager</code></a> 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(fragment).clear(target)</span><br></pre></td></tr></table></figure><p>使用 <code>RequestManager</code> 清除之前由它启动的加载过程，通常能提高性能，虽然这并不是强制要求的。Glide v4 会为每一个 Activity 和 Fragment 跟踪请求，所以你需要在合适的层级去清除请求。</p><p>######13、配置<br>在 Glide v3 中，配置使用一个或多个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html" target="_blank" rel="noopener"><code>GlideModule</code></a> 来完成。而在 Glide v4 中，配置改为使用一个类似但稍微复杂的系统来完成。</p><p>关于这个新系统的细节，可以查看<a href="https://muyangmin.github.io/glide-docs-cn/doc/configuration.html" target="_blank" rel="noopener">配置</a>页面。</p><p>######14、应用程序<br>在早期版本中使用了一个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html" target="_blank" rel="noopener"><code>GlideModule</code></a> 的应用，可以将它转换为一个 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> 。</p><p>在 Glide v3 中，你可能会有一个像这样的 <code>GlideModule</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class GiphyGlideModule implements GlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line">    builder.setMemoryCache(new LruResourceCache(10 * 1024 * 1024));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(Context context, Registry registry) &#123;</span><br><span class="line">    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Glide v4 中，你需要将其转换成一个 <code>AppGlideModule</code> ，它看起来像这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class GiphyGlideModule extends AppGlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line">    builder.setMemoryCache(new LruResourceCache(10 * 1024 * 1024));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(Context context, Registry registry) &#123;</span><br><span class="line">    registry.append(Api.GifResult.class, InputStream.class, new GiphyModelLoader.Factory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>@GlideModule</code> 注解不能省略。</p><p>如果你的应用拥有多个 <code>GlideModule</code>，你需要把其中一个转换成 <code>AppGlideModule</code>，剩下的转换成 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html" target="_blank" rel="noopener"><code>LibraryGlideModule</code></a> 。除非存在<code>AppGlideModule</code> ，否则程序不会发现 <code>LibraryGlideModule</code> ，因此您不能仅使用 <code>LibraryGlideModule</code> 。</p><p>######15、程序库<br>拥有一个或多个 <code>GlideModule</code> 的程序库应该使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/LibraryGlideModule.html" target="_blank" rel="noopener"><code>LibraryGlideModule</code></a> 。程序库不应该使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> ，因为它在一个应用里只能有一个。因此，如果你试图在程序库里使用它，将不仅会妨碍这个库的用户设置自己的选项，还会在多个程序库都这么做时造成冲突。</p><p>例如，v3 版本中 Volley 集成库的 <code>GlideModule</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class VolleyGlideModule implements GlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void applyOptions(Context context, GlideBuilder builder) &#123;</span><br><span class="line">    // Do nothing.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(Context context, Registry registry) &#123;</span><br><span class="line">    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 v4 版本中可以转换成为一个 <code>LibraryGlideModule</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class VolleyLibraryGlideModule extends LibraryGlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public void registerComponents(Context context, Registry registry) &#123;</span><br><span class="line">    registry.replace(GlideUrl.class, InputStream.class, new VolleyUrlLoader.Factory(context));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######16、清单解析</p><p>为了简化迁移过程，尽管清单解析和旧的 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/360/com/bumptech/glide/module/GlideModule.html" target="_blank" rel="noopener"><code>GlideModule</code></a> 接口已被废弃，但它们在 v4 版本中仍被支持。<code>AppGlideModule</code>，<code>LibraryGlideModule</code>，与已废弃的 <code>GlideModule</code> 可以在一个应用中共存。</p><p>然而，为了避免检查元数据的性能天花板（以及相关的 bugs ），你可以在迁移完成后禁用掉清单解析，在你的 <code>AppGlideModule</code> 中复写一个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@GlideModule</span><br><span class="line">public class GiphyGlideModule extends AppGlideModule &#123;</span><br><span class="line">  @Override</span><br><span class="line">  public boolean isManifestParsingEnabled() &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>######17、using(), ModelLoader, StreamModelLoader.</p><h4 id="ModelLoader"><a href="#ModelLoader" class="headerlink" title="ModelLoader"></a>ModelLoader<a href="https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#modelloader" target="_blank" rel="noopener"></a></h4><p><a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.html" target="_blank" rel="noopener"><code>ModelLoader</code></a> API 在 v4 版本中仍然存在，并且它的设计目标仍然和它在 v3 中一样，但有一些细节变化。</p><p>第一个细节，<code>ModelLoader</code> 的子类型如 <code>StreamModelLoader</code> ，现在已没有存在的必要，用户可以直接实现 <code>ModelLoader</code> 。例如，一个<code>StreamModelLoader&lt;File&gt;</code> 类现在可以通过 <code>ModelLoader&lt;File, InputStream&gt;</code> 的方式来实现和引用。</p><p>第二， <code>ModelLoader</code> 现在并不直接返回 <code>DataFetcher</code>，而是返回 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/load/model/ModelLoader.LoadData.html" target="_blank" rel="noopener"><code>LoadData</code></a> 。[<code>LoadData</code>] 是一个非常简单的封装，包含一个磁盘缓存键和一个 <code>DataFetcher</code>。</p><p>第三， <code>ModelLoaders</code> 有一个 <code>handles()</code> 方法，这使你可以为同一个类型参数注册超过一个的 ModelLoader 。</p><p>将一个 <code>ModelLoader</code> 从 v3 API转换到 v4 API ，通常是很简单直接的。如果你在你的 v3 <code>ModelLoader</code> 中只是简单滴返回一个 <code>DataFetcher</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class MyModelLoader implements StreamModelLoader&lt;File&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public DataFetcher&lt;InputStream&gt; getResourceFetcher(File model, int width, int height) &#123;</span><br><span class="line">    return new MyDataFetcher(model);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么你在 v4 替代类上需要做的仅仅只是封装一下这个 data fetcher ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public final class MyModelLoader implements ModelLoader&lt;File, InputStream&gt; &#123;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public LoadData&lt;InputStream&gt; buildLoadData(File model, int width, int height,</span><br><span class="line">      Options options) &#123;</span><br><span class="line">    return new LoadData&lt;&gt;(model, new MyDataFetcher(model));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handles(File model) &#123;</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，除了 <code>DataFetcher</code> 之外，模型也被传递给 <code>LoadData</code> 作为缓存键的一部分。这个规则为某些特殊场景提供了更多对磁盘缓存键的控制。大部分实现可以直接将 model 传入 <code>LoadData</code> ，就像上面这样。</p><p>如果你仅仅是想为某些 model（而不是所有）使用你的 ModelLoader，你可以在你尝试加载 model 之前使用 <code>handles()</code> 方法来检查它。如果你从 <code>handles</code> 方法中返回了 <code>false</code> ，那么你的 <code>ModelLoader</code> 将不能加载指定的 model ，即使你的 <code>ModelLoader</code> 类型 (在这个例子里是 <code>File</code> 和 <code>InputStream</code>) 与之匹配。</p><p>举个例子，如果你在某个指定文件夹下写入了加密的图片，你可以使用 <code>handles</code> 方法来实现一个 <code>ModelLoader</code> 以从那个特定的文件夹下解密图片，但是并不用于加载其他文件夹下的 <code>File</code> ：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public final class MyModelLoader implements ModelLoader&lt;File, InputStream&gt; &#123;</span><br><span class="line">  private static final String ENCRYPTED_PATH = &quot;/my/encrypted/folder&quot;;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public LoadData&lt;InputStream&gt; buildLoadData(File model, int width, int height,</span><br><span class="line">      Options options) &#123;</span><br><span class="line">    return new LoadData&lt;&gt;(model, new MyDataFetcher(model));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override</span><br><span class="line">  public void handles(File model) &#123;</span><br><span class="line">    return model.getAbsolutePath().startsWith(ENCRYPTED_PATH);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="using"><a href="#using" class="headerlink" title="using()"></a><code>using()</code><a href="https://muyangmin.github.io/glide-docs-cn/doc/migrating.html#using" target="_blank" rel="noopener"></a></h4><p><code>using</code> API在 Glide v4 中被删除了，这是为了鼓励用户使用 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> 一次性地 <a href="https://muyangmin.github.io/glide-docs-cn/doc/generatedapi.html" target="_blank" rel="noopener">注册</a> 所有组件，避免对象重用(re-use, 原文如此 –译者注)。你无需每次加载图片时都创建一个新的 <code>ModelLoader</code> ；你应该在 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/module/AppGlideModule.html" target="_blank" rel="noopener"><code>AppGlideModule</code></a> 中注册一次，然后交给 Glide 在每次加载时检查 model (即你传入 <a href="https://muyangmin.github.io/glide-docs-cn/javadocs/400/com/bumptech/glide/RequestBuilder.html#load-java.lang.Object-" target="_blank" rel="noopener"><code>load()</code></a> 方法的对象)来决定什么时候使用你注册的 <code></code>ModelLoader` 。</p><p>为了确保你仅为特定的 model 使用你的 <code>ModelLoader</code> ，请像上面展示的那样实现 <code>handles</code> 方法：检查每个 model ，但仅在应当使用你的 <code>ModelLoader</code> 时才返回 true 。</p><p>##以上17点就是Glide4.X和Glide3.X的区别，还是建议看官方文档</p>]]></content>
      
      
        <tags>
            
            <tag> 基于Glide4.7.1二次封装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin中的协变、逆变和不变</title>
      <link href="/2018/04/14/Kotlin%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%98/"/>
      <url>/2018/04/14/Kotlin%E4%B8%AD%E7%9A%84%E5%8D%8F%E5%8F%98%E3%80%81%E9%80%86%E5%8F%98%E5%92%8C%E4%B8%8D%E5%8F%98/</url>
      <content type="html"><![CDATA[<p>共1083字，阅读需要2分钟</p><h3 id="泛型实参的继承关系对泛型类型的影响"><a href="#泛型实参的继承关系对泛型类型的影响" class="headerlink" title="泛型实参的继承关系对泛型类型的影响"></a>泛型实参的继承关系对泛型类型的影响</h3><h5 id="协变：泛型类型与实参的继承关系相同"><a href="#协变：泛型类型与实参的继承关系相同" class="headerlink" title="协变：泛型类型与实参的继承关系相同"></a>协变：泛型类型与实参的继承关系相同</h5><h5 id="逆变：泛型类型与实参的继承关系相反"><a href="#逆变：泛型类型与实参的继承关系相反" class="headerlink" title="逆变：泛型类型与实参的继承关系相反"></a>逆变：泛型类型与实参的继承关系相反</h5><h5 id="不变：泛型类型没有关系"><a href="#不变：泛型类型没有关系" class="headerlink" title="不变：泛型类型没有关系"></a>不变：泛型类型没有关系</h5><h5 id="协变点：返回值类型是泛型参数类型"><a href="#协变点：返回值类型是泛型参数类型" class="headerlink" title="协变点：返回值类型是泛型参数类型"></a>协变点：返回值类型是泛型参数类型</h5><h5 id="逆变点：入参类型是泛型参数类型"><a href="#逆变点：入参类型是泛型参数类型" class="headerlink" title="逆变点：入参类型是泛型参数类型"></a>逆变点：入参类型是泛型参数类型</h5><h5 id="UnsafeVariance：协变点违例，告诉编译器，没事，你就按照我的意思执行"><a href="#UnsafeVariance：协变点违例，告诉编译器，没事，你就按照我的意思执行" class="headerlink" title="@UnsafeVariance：协变点违例，告诉编译器，没事，你就按照我的意思执行"></a>@UnsafeVariance：协变点违例，告诉编译器，没事，你就按照我的意思执行</h5><a id="more"></a> <p>###1、泛型<br>什么是泛型？泛化的类型或者是类型的抽象，鸭子类型（看起来像鸭子，走起来也像鸭子，就是鸭子类型）在静态语言中的一种静态实现<br>1、抽象类，是这个类的本质，它是什么<br>2、接口，关心类能够做什么，行为能力</p><p>####举两个例子<br>两个数的比较大小<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 需要有对比的功能，没有的话就会报错a&lt;b</span><br><span class="line">//加入限制 Comparable 具有对比的功能</span><br><span class="line">fun&lt;T:Comparable&lt;T&gt;&gt; maxOf(a:T,b:T):T&#123;</span><br><span class="line">    return if (a&lt;b) b else a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a=2</span><br><span class="line">val b=3</span><br><span class="line">val maxOf = maxOf(2, 3)</span><br><span class="line"> println(&quot;shiming &quot;+maxOf)</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shiming 3</span><br></pre></td></tr></table></figure></p><p>让一个类具备对比的能<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data class Complex(val a:Double,val b:Double):Comparable&lt;Complex&gt;&#123;</span><br><span class="line">    override fun compareTo(other: Complex): Int &#123;</span><br><span class="line">        return (value()-other.value()).toInt()</span><br><span class="line">    &#125;</span><br><span class="line">    fun value():Double&#123;</span><br><span class="line">        return a*a+b*b</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;$a*$a+$b*$b=&quot;+(a*a+b*b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val Complex1=Complex(4.0,5.0)</span><br><span class="line"> val Complex2=Complex(5.0,6.0)</span><br><span class="line"> println(&quot;shiming Complex1=&quot;+Complex1)</span><br><span class="line"> println(&quot;shiming Complex2=&quot;+Complex2)</span><br><span class="line"> println(&quot;shiming&quot;+Complex1.compareTo(Complex2))</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">04-16 11:22:10.824 26429-26429/com.kotlin.demo I/System.out: shiming Complex1=4.0*a+5.0*b=41.0</span><br><span class="line">04-16 11:22:10.824 26429-26429/com.kotlin.demo I/System.out: shiming Complex2=5.0*a+6.0*b=61.0</span><br><span class="line">04-16 11:22:10.824 26429-26429/com.kotlin.demo I/System.out: shiming-20</span><br></pre></td></tr></table></figure></p><p>####通过Demo的测试的结果的发现：泛型不管你到底是什么，它只管你能够做什么事情</p><p>####定义多个泛型参数<br>kotlin中的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    (1..2).map &#123; println(&quot;shiming $it==&quot;+it) &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Returns a list containing the results of applying the given [transform] function</span><br><span class="line"> * to each element in the original collection. </span><br><span class="line">      (1..2).map调用的底层的方法</span><br><span class="line"> */</span><br><span class="line">public inline fun &lt;T, R&gt; Iterable&lt;T&gt;.map(transform: (T) -&gt; R): List&lt;R&gt; &#123;</span><br><span class="line">    return mapTo(ArrayList&lt;R&gt;(collectionSizeOrDefault(10)), transform)</span><br><span class="line">&#125;</span><br><span class="line">/** A function that takes 22 arguments. function中最多的参数22.一共有23个方法 */</span><br><span class="line">public interface Function22&lt;in P1, in P2, in P3, in P4, in P5, in P6, in P7, in P8, in P9, in P10, in P11, in P12, in P13, in P14, in P15, in P16, in P17, in P18, in P19, in P20, in P21, in P22, out R&gt; : Function&lt;R&gt; &#123;</span><br><span class="line">    /** Invokes the function with the specified arguments. */</span><br><span class="line">    public operator fun invoke(p1: P1, p2: P2, p3: P3, p4: P4, p5: P5, p6: P6, p7: P7, p8: P8, p9: P9, p10: P10, p11: P11, p12: P12, p13: P13, p14: P14, p15: P15, p16: P16, p17: P17, p18: P18, p19: P19, p20: P20, p21: P21, p22: P22): R</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin中的类传入泛型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data class ComplexNumber&lt; T : Number&gt;(val a:T,val b:T)&#123;</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;$a*$a+$b*$b&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####泛型的实现的机制</p><p>何为伪泛型（Java 、Kotlin）？编译完了，泛型就没有了（真正的原因就是最开始写Java编译器的几个人偷懒取巧，留下了历史问题，<a href="https://baike.baidu.com/item/Scala" target="_blank" rel="noopener">Martin Odersky</a>爆料。Martin Odersky是Typesafe的联合创始人，也是<a href="https://baike.baidu.com/item/Scala" target="_blank" rel="noopener">Scala</a>编程语言的发明者。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//按照重载的定义这两个方法应该编译的过的，但是Java和kotlin编译完了成了object或者是没有</span><br><span class="line">fun needList(list:List&lt;Double&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fun needList(list:List&lt;Int&gt;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译可以看到,卧槽我的泛型没有了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static final void needList(@NotNull List list) &#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(list, &quot;list&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static final void needList(@NotNull List list) &#123;</span><br><span class="line">   Intrinsics.checkParameterIsNotNull(list, &quot;list&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-3140138a6889c906.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没有编译通过"><br>何为真泛型（C#）？编译完了，还在<br>如果把以上的代码放在C#中，就不会报错，原因是C#的泛型不仅存在于编译器，也存在运行期</p><p>####java1.5才有的泛型特性，迫于现实的需求！用的人太多，但是C#第一个版本也没有泛型，但是用的人少，所以C#使用的是真泛型<br>但是有一种方式可以在编译器得到泛型类型:<br>reified让泛型参数具体化，定义在inline中 ，kotlin实现为伪泛型，需要这个关键字植入到调用出才可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//inline inline可用内联函数(inline function)消除这些额外内存开销,</span><br><span class="line">//说白了就是在调用处插入函数体代码,以此减少新建函数栈和对象的内存开销!</span><br><span class="line">inline fun&lt;reified T&gt; getT()&#123;</span><br><span class="line">    println(&quot;shiming&quot;+T::class.java)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getT&lt;String&gt;()</span><br><span class="line">getT&lt;Double&gt;()</span><br><span class="line">//通过反编译得到的结果，说白了，其实就是打印了，这样永远都不会丢失</span><br><span class="line">      String var21 = &quot;shiming&quot; + String.class;</span><br><span class="line">      System.out.println(var21);</span><br><span class="line">      var21 = &quot;shiming&quot; + Double.class;</span><br><span class="line">      System.out.println(var21);</span><br></pre></td></tr></table></figure></p><p>得到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">04-16 15:28:59.775 31782-31782/com.kotlin.demo I/System.out: shimingclass java.lang.String</span><br><span class="line">04-16 15:28:59.775 31782-31782/com.kotlin.demo I/System.out: shimingclass java.lang.Double</span><br></pre></td></tr></table></figure></p><p>在实际工作中可以这样用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">data class Person(val name:String,val age:Int)&#123;</span><br><span class="line">    //重写，得到json字符串</span><br><span class="line">    override fun toString(): String &#123;</span><br><span class="line">        return &quot;&#123;name=&quot;+&quot;\&quot;&quot;+name+&quot;\&quot;,&quot;+&quot;age=&quot;+age+&quot;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//例子 通过inline把这个前面的代码植入到后面</span><br><span class="line">// reified让泛型参数具体化，定义在inline中 ，kotlin实现为伪泛型，需要这个关键字植入到调用出才可以</span><br><span class="line">inline fun &lt;reified T&gt; Gson.fromJson(json:String):T=fromJson(json,T::class.java)</span><br><span class="line">//模拟网络请求返回的json数据，得到bean类</span><br><span class="line"> val person=Person(&quot;shiming&quot;,20)</span><br><span class="line"> println(&quot;shiming  &quot;+person)</span><br><span class="line">  val toString = person.toString()</span><br><span class="line">  val person1= Gson().fromJson&lt;Person&gt;(toString)</span><br><span class="line">  println(&quot;shiming person1&quot;+person1)</span><br><span class="line"></span><br><span class="line">//上面一段代码的反编译的结果，和java是一样的，执行的流程</span><br><span class="line">      Person person = new Person(&quot;shiming&quot;, 20);</span><br><span class="line">      String toString = &quot;shiming  &quot; + person;</span><br><span class="line">      System.out.println(toString);</span><br><span class="line">      toString = person.toString();</span><br><span class="line">      Gson $receiver$iv = new Gson();</span><br><span class="line">      Person person1 = (Person)$receiver$iv.fromJson(toString, Person.class);</span><br><span class="line">      String var25 = &quot;shiming person1&quot; + person1;</span><br><span class="line">      System.out.println(var25);</span><br></pre></td></tr></table></figure></p><p>###具体的关系<br>f(⋅)是逆变（contravariant）的，当A≤B时有f(B)≤f(A)成立；<br>f(⋅)是协变（covariant）的，当A≤B时有成立f(A)≤f(B)成立；<br>f(⋅)是不变（invariant）的，当A≤B时上述两个式子均不成立，即f(A)与f(B)相互之间没有继承关系。</p><p>###协变<br>在kotlin中List不是Java中的List，它只是只读的,查看源码如下List<out e=""> ，看见Out就是协变的，只读类型，List中根本没有add的方法，不可添加元素<br> //out 协变 Number 是Int的父类，协变点函数得返回类型<br> val numberList:List<number> = listOf<int>(1,58)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> public interface List&lt;out E&gt; : Collection&lt;E&gt; &#123;</span><br><span class="line">    // Query Operations</span><br><span class="line">    override val size: Int</span><br><span class="line"></span><br><span class="line">    override fun isEmpty(): Boolean</span><br><span class="line">   //告诉编译器 我知道，你不要管我知道怎么搞</span><br><span class="line">    override fun contains(element: @UnsafeVariance E): Boolean</span><br><span class="line">    override fun iterator(): Iterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    // Bulk Operations</span><br><span class="line">    override fun containsAll(elements: Collection&lt;@UnsafeVariance E&gt;): Boolean</span><br><span class="line"></span><br><span class="line">    // Positional Access Operations</span><br><span class="line">    /**</span><br><span class="line">     * Returns the element at the specified index in the list.、</span><br><span class="line">     返回值的类型是E</span><br><span class="line">     */</span><br><span class="line">    public operator fun get(index: Int): E</span><br><span class="line"></span><br><span class="line">    // Search Operations</span><br><span class="line">    /**</span><br><span class="line">     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified</span><br><span class="line">     * element is not contained in the list.</span><br><span class="line">     */</span><br><span class="line">    public fun indexOf(element: @UnsafeVariance E): Int</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified</span><br><span class="line">     * element is not contained in the list.</span><br><span class="line">     */</span><br><span class="line">    public fun lastIndexOf(element: @UnsafeVariance E): Int</span><br><span class="line"></span><br><span class="line">    // List Iterators</span><br><span class="line">    /**</span><br><span class="line">     * Returns a list iterator over the elements in this list (in proper sequence).</span><br><span class="line">     */</span><br><span class="line">    public fun listIterator(): ListIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].</span><br><span class="line">     */</span><br><span class="line">    public fun listIterator(index: Int): ListIterator&lt;E&gt;</span><br><span class="line"></span><br><span class="line">    // View</span><br><span class="line">    /**</span><br><span class="line">     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).</span><br><span class="line">     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.</span><br><span class="line">     *</span><br><span class="line">     * Structural changes in the base list make the behavior of the view undefined.</span><br><span class="line">     */</span><br><span class="line">    public fun subList(fromIndex: Int, toIndex: Int): List&lt;E&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></int></number></out></p><p>逆变：Comparable接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   //in 逆变 ，泛型的继承关系相反 逆变点就是函数参数的类型  Any是Int的父类</span><br><span class="line">  val intComparable:Comparable&lt;Int&gt; = object :Comparable&lt;Any&gt;&#123;</span><br><span class="line">            override fun compareTo(other: Any): Int &#123;</span><br><span class="line">                return 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">public interface Comparable&lt;in T&gt; &#123;</span><br><span class="line">    public operator fun compareTo(other: T): Int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不变：MutableList相当于Java中的|ArrayList，可读可写，不可变，泛型没有in 或者是out ，泛型的继承关系也没有具体的关系，前面是后面的子类或者是后面是前面的子类，都是不成立。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-929cfc0a004bba08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface MutableList&lt;E&gt; : List&lt;E&gt;, MutableCollection&lt;E&gt; &#123;</span><br><span class="line">    override fun add(element: E): Boolean</span><br><span class="line">    override fun remove(element: E): Boolean</span><br><span class="line">    override fun addAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    public fun addAll(index: Int, elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    override fun removeAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    override fun retainAll(elements: Collection&lt;E&gt;): Boolean</span><br><span class="line">    override fun clear(): Unit</span><br><span class="line">    public operator fun set(index: Int, element: E): E</span><br><span class="line">    public fun add(index: Int, element: E): Unit</span><br><span class="line">    public fun removeAt(index: Int): E</span><br><span class="line">    override fun listIterator(): MutableListIterator&lt;E&gt;</span><br><span class="line">    override fun listIterator(index: Int): MutableListIterator&lt;E&gt;</span><br><span class="line">    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;E&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###星投影：始终找最安全的解决方法，安全方式是定义泛型类型的这种投影，该泛型类型的每个具体实例化将是该投影的子类型</p><p>如果泛型类型具有多个类型参数，则每个类型参数都可以单独投影。<br>例如，如果类型被声明为 interface Function <in t,="" out="" u="">，可以想象以下星投影：<br>Function&lt;<em>, String&gt; 表示 Function<in nothing,="" string="">；<br>Function&lt;Int, </in></em>&gt; 表示 Function&lt;Int, out Any?&gt;；<br>Function&lt;<em>, </em>&gt; 表示 Function<in nothing,="" out="" any?="">。</in></in></p><p>可用的星投影的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> //out 协变 Number 是Int的子类，协变点函数得返回类型</span><br><span class="line">        val numberList:List&lt;*&gt; = listOf&lt;Int&gt;(1,58)</span><br><span class="line">        val any = numberList[1] //星投影，去找父类</span><br><span class="line">        //in 逆变 ，泛型的继承关系相反 逆变点就是函数参数的类型</span><br><span class="line">        val intComparable:Comparable&lt;*&gt; = object :Comparable&lt;Any&gt;&#123;</span><br><span class="line">            override fun compareTo(other: Any): Int &#123;</span><br><span class="line">                return 0</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //星投影，去找父类 Nothing</span><br><span class="line">        intComparable.compareTo()</span><br><span class="line"></span><br><span class="line">fun &lt;T&gt; hello()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">open class Hello&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//这样 就可以使用星投影</span><br><span class="line">class Hello33&lt;T&gt;</span><br><span class="line">//这样也可以使用星投影</span><br><span class="line">class Hello2:Hello&lt;Hello&lt;*&gt;&gt;()</span><br><span class="line">class Hello332:Hello&lt;Hello33&lt;*&gt;&gt;()</span><br></pre></td></tr></table></figure></p><p>在kotlin中调用java的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">        //这样也可以使用星投影</span><br><span class="line">  val raw:Raw&lt;*&gt; = Raw.getRaw()</span><br><span class="line">public class Raw&lt;T&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;老子是Raw&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    public static Raw getRaw()&#123;</span><br><span class="line">        return new Raw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不可以使用星投影的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        //不变的话，就根本没有继承关系，没有任何的关系 原因是这样不安全</span><br><span class="line">//        val list1:MutableList&lt;Number&gt; = mutableListOf&lt;Int&gt;(1,5,4)</span><br><span class="line">       list1.add(BigDecimal(1244444444))</span><br><span class="line">//        val list2:MutableList&lt;Int&gt; = mutableListOf&lt;Number&gt;(1,5,4)</span><br><span class="line"></span><br><span class="line">        //泛型的实参不要使用星号</span><br><span class="line">//        val numberList11d:List&lt;*&gt; = listOf&lt;*&gt;(1,58)</span><br><span class="line">//</span><br><span class="line">//        hello&lt;*&gt;()</span><br><span class="line">//</span><br><span class="line">//        val hello: Any = Hello&lt;*&gt;()</span><br><span class="line">fun &lt;T&gt; hello()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">open class Hello&lt;T&gt;&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##安卓中一个MvpDemo,使用到了星投影和协变！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package com.kotlin.demo.star_demo</span><br><span class="line"></span><br><span class="line">import org.jetbrains.annotations.NotNull</span><br><span class="line">import java.lang.reflect.ParameterizedType</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/14 15:08</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">//Mvp 中的V层 超级接口</span><br><span class="line">interface IView&lt;out P:Ipresenter&lt;IView&lt;P&gt;&gt;&gt;&#123;</span><br><span class="line">    val presenter:P</span><br><span class="line">&#125;</span><br><span class="line">//P层的超级接口</span><br><span class="line">interface Ipresenter&lt;out V:IView&lt;Ipresenter&lt;V&gt;&gt;&gt;&#123;</span><br><span class="line">//    @NotNull</span><br><span class="line">//    IView getView();</span><br><span class="line">    val view:V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">abstract class BaseView&lt;out P:BasePresenter&lt;BaseView&lt;P&gt;&gt;&gt;:IView&lt;P&gt;&#123;</span><br><span class="line">    override val presenter:P</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        presenter= findPresenterClass().newInstance()</span><br><span class="line">        presenter.view=this</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 得到相对于的Class的文件</span><br><span class="line">     */</span><br><span class="line">    private fun findPresenterClass():Class&lt;P&gt;&#123;</span><br><span class="line">        //不知道，使用星投影去接收  相当于  Class thisClass = this.getClass();</span><br><span class="line">        var thisClass:Class&lt;*&gt; = this.javaClass</span><br><span class="line">//        while(true) &#123;</span><br><span class="line">//            Type var10000 = thisClass.getGenericSuperclass();</span><br><span class="line">//            if(!(var10000 instanceof ParameterizedType)) &#123;</span><br><span class="line">//                var10000 = null;</span><br><span class="line">//            &#125;</span><br><span class="line">//            ParameterizedType var5 = (ParameterizedType)var10000;</span><br><span class="line">//            if(var5 != null) &#123;</span><br><span class="line">//                Type[] var6 = var5.getActualTypeArguments();</span><br><span class="line">//                if(var6 != null) &#123;</span><br><span class="line">//                    var10000 = (Type)ArraysKt.firstOrNull((Object[])var6);</span><br><span class="line">//                    if(var10000 != null) &#123;</span><br><span class="line">//                        Type var2 = var10000;</span><br><span class="line">//                        if(var2 == null) &#123;</span><br><span class="line">//                            throw new TypeCastException(&quot;null cannot be cast to non-null type java.lang.Class&lt;P&gt;&quot;);</span><br><span class="line">//                        &#125;</span><br><span class="line">//</span><br><span class="line">//                        return (Class)var2;</span><br><span class="line">//                    &#125;</span><br><span class="line">//                &#125;</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;</span><br><span class="line">        //以下的代码相当于上面的代码</span><br><span class="line">        while (true)&#123;</span><br><span class="line">            (thisClass.genericSuperclass as? ParameterizedType)</span><br><span class="line">                    ?.actualTypeArguments</span><br><span class="line">                    ?.firstOrNull()</span><br><span class="line">                    ?.let &#123;</span><br><span class="line">                        return it as Class&lt;P&gt;</span><br><span class="line">                    &#125;?.run&#123;</span><br><span class="line">                            thisClass=thisClass.superclass ?:throw IllegalAccessException()</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class BasePresenter&lt;out V:IView&lt;BasePresenter&lt;V&gt;&gt;&gt;:Ipresenter&lt;V&gt;&#123;</span><br><span class="line">    //lateinit 延迟初始化</span><br><span class="line">    //@UnsafeVariance 告诉编译器 我很安全 不要管我</span><br><span class="line">    override lateinit var view:@UnsafeVariance V</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MainView:BaseView&lt;MainPresenter&gt;()</span><br><span class="line"></span><br><span class="line">class MainPresenter:BasePresenter&lt;MainView&gt;()</span><br><span class="line"></span><br><span class="line">class Mvp&#123;</span><br><span class="line">    init &#123;</span><br><span class="line">        MainView().presenter.let(::println)</span><br><span class="line">        //相当于下面的代码</span><br><span class="line">//        BasePresenter var1 = (new MainView()).getPresenter();</span><br><span class="line">//        System.out.println(var1);</span><br><span class="line">        MainView().presenter.let &#123; println(&quot;shiming P=&quot;+it) &#125;</span><br><span class="line">        //相当于下面的代码</span><br><span class="line">//        var1 = (new MainView()).getPresenter();</span><br><span class="line">//        MainPresenter it = (MainPresenter)var1;</span><br><span class="line">//        String var3 = &quot;shiming P=&quot; + it;</span><br><span class="line">//        System.out.println(var3);</span><br><span class="line">//        (new MainPresenter()).getView();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####输出的结果是：shiming P=com.kotlin.demo.star_demo.MainPresenter@fc35795<br>以上就是大概的理解，谢谢！</p>]]></content>
      
      
        <tags>
            
            <tag> Kotlin中的协变、逆变和不变 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PLC通讯的安卓App</title>
      <link href="/2018/02/26/PLC%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%89%E5%8D%93App/"/>
      <url>/2018/02/26/PLC%E9%80%9A%E8%AE%AF%E7%9A%84%E5%AE%89%E5%8D%93App/</url>
      <content type="html"><![CDATA[<h4 id="认识中控板：华北工控-EMB-3550"><a href="#认识中控板：华北工控-EMB-3550" class="headerlink" title="认识中控板：华北工控 EMB-3550"></a>认识中控板：华北工控 EMB-3550</h4><p>基于Coretex-A17 ARM架构嵌入式All In One主板</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-919473b454fd8d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="工控板.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ea38ec24a0744489.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="侧视图.png"></p><a id="more"></a><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ded4876d0aa8ca7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="侧面图.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-1132b24da691c87c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="背面图"></p><p>#####EMB—3550详细的参数：<br>◆ 采用RK3288 Coretex-A17处理器（四核）<br>◆ 板载2GB DDR3 高速内存，板载8GB EMMC flash<br>◆ 提供HDMI、VGA、LVDS多种显示端口，支持独立多显<br>◆ 提供5x COM，6x USB，1x USB OTG，1x LAN，1x WIFI，1x TF卡槽，Line out/Mic（板载5W双输出功放），<br>◆ 提供1x Mini PCIe（可支持WiFi、3G模块），1x SIM卡槽（可支持3G网络）<br>◆ 主板集成度高、板型紧凑、All In One 设计，尺寸仅为120mm*120mm</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-89f4173ed2a9be2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="详细的参数的信息.png"></p><p>实物图<br><img src="http://upload-images.jianshu.io/upload_images/5363507-6288b563a0cef4af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="把板子当做一个安卓手机"></p><p>最后总结一下，我们只需要把这个设备当做手机，虽然这样，但是我在开发过程中也遇到了好多麻烦，比如说，这段的代码在手机上运行就没有什么问题，在板子上运行就直接奔溃，板子会莫名其妙的息屏，当订购板子的设备多了，会发现每一块的板子的都不一样，你说崩溃不？当然，这些都是后话了，这个板子要求两点：Root过，最好安卓的系统在5.0以下，因为那会的安卓对权限好像不是太敏感</p><p>####认识PLC：PLC控制器实质是一种专用于工业控制的计算机，其硬件结构基本上与微型计算机相同<br>PLC控制系统，Programmable Logic Controller，可编程逻辑控制器，专为工业生产设计的一种数字运算操作的电子装置，它采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算，顺序控制，定时，计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。是工业控制的核心部分。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-db28b736cdd99618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-730e20aca8adaa1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><h4 id="中央处理单元"><a href="#中央处理单元" class="headerlink" title="中央处理单元"></a>中央处理单元</h4><p>中央处理单元(CPU)是PLC控制器的控制中枢。它按照PLC控制器系统程序赋予的功能接收并存储从编程器键入的用户程序和数据；检查电源、存储器、I/O以及警戒定时器的状态，并能诊断用户程序中的语法错误。当PLC控制器投入运行时，首先它以扫描的方式接收现场各输入装置的状态和数据，并分别存入I/O映象区，然后从用户程序存储器中逐条读取用户程序，经过命令解释后按指令的规定执行逻辑或算数运算的结果送入I/O映象区或数据寄存器内。等所有的用户程序执行完毕之后，最后将I/O映象区的各输出状态或输出寄存器内的数据传送到相应的输出装置，如此循环运行，直到停止运行。为了进一步提高PLC控制器的可靠性，近年来对大型PLC还采用双CPU构成冗余系统，或采用三CPU的表决式系统。这样，即使某个CPU出现故障，整个系统仍能正常运行。</p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h4><p>存放系统软件的存储器称为系统程序存储器。<br>存放应用软件的存储器称为用户程序存储器。</p><h4 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h4><p>PLC控制器的电源在整个系统中起着十分重要得作用。如果没有一个良好的、可靠的电源系统是无法正常工作的，因此PLC的制造商对电源的设计和制造也十分重视。一般交流电压波动在+10%(+15%)范围内，可以不采取其它措施而将PLC控制器直接连接到交流电网上去。</p><h4 id="程式输入装置"><a href="#程式输入装置" class="headerlink" title="程式输入装置"></a>程式输入装置</h4><p>负责提供操作者输入、修改、监视程式用作的功能</p><h4 id="输入输出回路"><a href="#输入输出回路" class="headerlink" title="输入输出回路"></a>输入输出回路</h4><p>负责接收外部输入元件信号和负责接收外部输出元件信号.</p><p>###最后关于PLC，说明一下：我对这块也不熟悉，毕竟是工业上的东西，希望未来可以深入了解，上面的两张图来源于百度，可以对比发现其中的关键点是modbus通讯，我们通过modbus和PLC交互，连接的方式是LAN端口，实际上，现在在GitHub上开源的Modbus的例子特别多，所以很好的掌握上层的通讯</p><p>####认识App需要的三方依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">compile fileTree(include: [&apos;*.jar&apos;], dir: &apos;libs&apos;)</span><br><span class="line">compile &apos;com.android.support:appcompat-v7:23.2.1&apos;</span><br><span class="line">compile &apos;com.squareup.okhttp3:okhttp-urlconnection:3.2.0&apos;</span><br><span class="line">compile &apos;com.path:android-priority-jobqueue:1.1.2&apos;</span><br><span class="line">//任务调度</span><br><span class="line">compile &apos;org.greenrobot:eventbus:3.0.0&apos;</span><br><span class="line">compile &apos;com.kyleduo.switchbutton:library:1.4.4&apos;</span><br><span class="line">compile &apos;io.reactivex:rxandroid:1.2.1&apos;</span><br><span class="line">compile &apos;io.reactivex:rxjava:1.1.6&apos;</span><br><span class="line">compile &apos;com.google.code.gson:gson:2.8.0&apos;</span><br><span class="line">compile &apos;com.squareup.okhttp3:okhttp:3.2.0&apos;</span><br><span class="line">compile &apos;com.alibaba:fastjson:1.2.21&apos;</span><br><span class="line">//    debugCompile &apos;com.amitshekhar.android:debug-db:0.2.0&apos;   //Android Debug Database 是一个用于在Android应用中调试数据库和分享参数的强大的库。</span><br><span class="line">compile &apos;com.amitshekhar.android:debug-db:1.0.0&apos;//这个很nice 是一个用于在Android应用中调试数据库和分享参数的强大的库。</span><br></pre></td></tr></table></figure></p><p>◆  okhttp:网络加载的依赖，这个不用说，搞过开发的都知道<br>◆（抛砖引玉）  <a href="https://link.jianshu.com/?t=https://github.com/yigit/android-priority-jobqueue" target="_blank" rel="noopener">android-priority-jobqueue</a>：是一个后台任务队列框架，可以对任务进行磁盘缓存，当网络恢复连接的时候继续执行任务。</p><p>######优点如下：<br>便于解耦Application的业务逻辑，让你的代码更加健壮，易于重构和测试。<br>不处理AsyncTask的生命周期。<br> Job Queue关心优先Jobs，检测网络连接，并行运行等。<br>可以延迟jobs。<br>分组jobs来确保串行执行。<br>默认情况下，Job Queue监控网络连接（所以你不需要担心），当设备处于离线状态，需要网络的jobs不会运行，直到网络重新连接。<br>◆  switchbutton：按钮<br>◆  Rxandroid   Rxjava：不解释<br>◆  debug-db：<a href="https://github.com/amitshekhariitbhu" target="_blank" rel="noopener">AMIT SHEKHAR</a>开源了<a href="https://github.com/amitshekhariitbhu/Android-Debug-Database" target="_blank" rel="noopener">Android-Debug-Database</a>，利用这个库，我们可以通过浏览器方便的查看的数据库。主要是调试用，因为有很多的数据会存到我们的数据库中<br><img src="http://upload-images.jianshu.io/upload_images/5363507-98637c90119d4077.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图中的url地址可以使用浏览器打开"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-0af4d354df45a40c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打开的效果如下"></p><p>####串口和ModBus通信</p><p>#####串口<br>1、串行接口简称串口，也称串行通信接口或串行通讯接口通常指COM接口，是采用串行通信方式的扩展接口。串行接口(Serial Interface) 是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。<br>2、串行接口(Serial Interface) 是指数据一位一位地顺序传送，其特点是通信线路简单，只要一对传输线就可以实现双向通信（可以直接利用电话线作为传输线），从而大大降低了成本，特别适用于远距离通信，但传送速度较慢。一条信息的各位数据被逐位按顺序传送的通讯方式称为串行通讯。串行通讯的特点是：数据位的传送，按位顺序进行，最少只需一根传输线即可完成；成本低但传送速度慢。</p><p>中控板提供了5个串口，在我的项目中使用到两个<br><img src="http://upload-images.jianshu.io/upload_images/5363507-907aec9a521b762b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>#####内置扫描头，记录下扫描的信息，同时保存到数据库中</p><p>#####外置扫描头，扫描提供给用户的二维码，通过扫描得到的信息，和数据库中信息相匹配，匹配到了，下发指令给PLC，PLC通知下位机做机械动作，通过联系的动作指令，把用户需要的信息反馈给用户。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-a32dab3d88003e0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程图01.png"></p><p>#####ModBus通信</p><p>java的modbus实现库<a href="https://github.com/infiniteautomation/modbus4j" target="_blank" rel="noopener">Git地址</a></p><p>Modbus是由Modicon（现为施耐德电气公司的一个品牌）在1979年发明的，是全球第一个真正用于工业现场的总线协议。<br>ModBus网络是一个工业通信系统，由带智能终端的可编程序控制器和计算机通过公用线路或局部专用线路连接而成。其系统结构既包括硬件、亦包括软件。它可应用于各种数据采集和过程监控。</p><p>######Modbus具有以下几个特点：<br>（1）标准、开放，用户可以免费、放心地使用Modbus协议，不需要交纳许可证费，也不会侵犯知识产权。目前，支持Modbus的厂家超过400家，支持Modbus的产品超过600种。<br>（2）Modbus可以支持多种电气接口，如RS-232、RS-485等，还可以在各种介质上传送，如双绞线、光纤、无线等。<br>（3）Modbus的帧格式简单、紧凑，通俗易懂。用户使用容易，厂商开发简单。</p><p>######传输方式<br>在ModBus系统中有2种传输模式可选择。这2种传输模式与从机PC通信的能力是同等的。选择时应视所用ModBus主机而定，每个ModBus系统只能使用一种模式，不允许2种模式混用。一种模式是ASCII（美国信息交换码），另一种模式是RTU远程终端设备。<br>1、ASCII模式<br>当控制器设为在Modbus网络上以ASCII（美国标准信息交换代码）模式通信，一个信息中的每8个比特作为2个ASCII字符传输，如数值63H用ASCII方式时，需发送两个字节，即ASCII“6”（0110110）和ASCII”3“（0110011），ASCII字符占用的位数有7位和8位，国际通用7位为多。这种方式的主要优点是字符发送的时间间隔可达到1秒而不产生错误。<br>2、RTU模式<br>当控制器设为在Modbus网络上以RTU模式通信，在消息中的每个8Bit字节按照原值传送，不做处理，如63H，RTU将直接发送01100011。这种方式的主要优点是：数据帧传送之间没有间隔，相同波特率下传输数据的密度要比ASCII高，传输速度更快。</p><p>######代码实现<br>jar包，网上很多，基本上找得到，两个jar相互相成<br><img src="http://upload-images.jianshu.io/upload_images/5363507-4205e69a352897f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖的jar包"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//&quot;192.168.1.11&quot;能变更的东西，尽量写活</span><br><span class="line"> String plcIpAddress = AppSP.getStringValue(AppSP.PLC_IP_ADDRESS, Constant.DEFAULT_PLCIP);</span><br><span class="line"> String plcPort = AppSP.getStringValue(AppSP.PLC_PORT, Constant.DEFAULT_PLC_PORT);//PLC端口号默认502</span><br><span class="line"> plcNO = Integer.parseInt(AppSP.getStringValue(AppSP.PLC_NO, &quot;1&quot;));//默认PLC站号为1</span><br><span class="line"> if (plcIpAddress.equals(&quot;&quot;) || plcPort.equals(&quot;&quot;)) &#123;</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> IpParameters ipParameters = new IpParameters();</span><br><span class="line"> ipParameters.setHost(plcIpAddress);</span><br><span class="line"> ipParameters.setPort(Integer.parseInt(plcPort));</span><br><span class="line"> if (master != null) &#123;</span><br><span class="line">     if (master.isInitialized()) &#123;</span><br><span class="line">         master.destroy();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ModbusFactory modbusFactory = new ModbusFactory();</span><br><span class="line"> // 参数1：IP和端口信息 参数2：保持连接激活</span><br><span class="line"> master = modbusFactory.createTcpMaster(ipParameters, true);</span><br><span class="line"> master.setTimeout(2000);</span><br><span class="line"> //modbus重连次数</span><br><span class="line"> master.setRetries(10);</span><br><span class="line"> new Thread() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         super.run();</span><br><span class="line">         try &#123;</span><br><span class="line">             master.init();</span><br><span class="line">             //连接成功，复位</span><br><span class="line">             mainHandler.post(new Runnable() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void run() &#123;</span><br><span class="line">                     WaittingActivity.start(getContext(), getContext().getString(R.string.msg_machine_is_all_returninng));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;);</span><br><span class="line">             setStatus(AppStatus.NORMAL);</span><br><span class="line">         &#125; catch (ModbusInitException e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">             setStatus(AppStatus.PLC_CONNECT_LOST);</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">             master.destroy();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;.start();</span><br></pre></td></tr></table></figure><p>写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 同步方式批量写数据到保持寄存器  功能代码：16 (0x10)</span><br><span class="line">   *</span><br><span class="line">   * @param master</span><br><span class="line">   * @param slaveId</span><br><span class="line">   * @param start</span><br><span class="line">   * @param values</span><br><span class="line">   */</span><br><span class="line">  public static int writeHRegs(final ModbusMaster master, final int slaveId, final int start, final short[] values) &#123;</span><br><span class="line"></span><br><span class="line">      if (master == null) &#123;</span><br><span class="line">          return -1;</span><br><span class="line">      &#125;</span><br><span class="line">      try &#123;</span><br><span class="line">          LogPrint.print_modbus(&quot; 同步写数据到保持寄存器D&quot;, &quot;add:&quot; + start + &quot;-value:&quot; + NumberUtil.toInt(values));</span><br><span class="line">          WriteRegistersRequest request = new WriteRegistersRequest(slaveId, start, values);</span><br><span class="line">          WriteRegistersResponse response = (WriteRegistersResponse) master.send(request);</span><br><span class="line">          if (!response.isException()) &#123;</span><br><span class="line">              return 0;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              return -1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (ModbusTransportException e) &#123;</span><br><span class="line">          onModbusTransportException(e, start);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return -1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>读<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 读取保持寄存器 功能代码 03</span><br><span class="line">   *</span><br><span class="line">   * @param master</span><br><span class="line">   * @param slaveId</span><br><span class="line">   * @param addr</span><br><span class="line">   * @return</span><br><span class="line">   */</span><br><span class="line">  public static int readHReg(final ModbusMaster master, int slaveId, int addr) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          LogPrint.print_modbus(&quot;同步读保持寄存器D&quot;, &quot;add:&quot; + addr);</span><br><span class="line">          ReadHoldingRegistersRequest request2 = new ReadHoldingRegistersRequest(slaveId, addr, 1);</span><br><span class="line">          ReadHoldingRegistersResponse response2 = (ReadHoldingRegistersResponse) master.send(request2);</span><br><span class="line">          if (!response2.isException()) &#123;</span><br><span class="line">              return response2.getShortData()[0];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          if (e instanceof ModbusTransportException) &#123;</span><br><span class="line">              onModbusTransportException((ModbusTransportException) e, addr);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####工作流程图如下，需要在新标签打开图片，放大才看的清楚些<br><img src="http://upload-images.jianshu.io/upload_images/5363507-cdfcc6fd6520bd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Modbus流程图.png"></p><p>####modbus到底是怎样的通讯的呢？<br>这是通讯app的控制面板，讲一个开门流程<br><img src="http://upload-images.jianshu.io/upload_images/5363507-fd7135a82d5b04c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="device-2018-02-26-175123.png"><br>点击开门开关<br> SwitchExecutor.openDoor();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> LogToFile.getInstane().write(LogToFile.SWITCH, &quot;开门&quot;);</span><br><span class="line">Observable openDoor = Observable.create(new Observable.OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void call(Subscriber&lt;? super Integer&gt; subscriber) &#123;</span><br><span class="line">        SwitchTask switchTask = new SwitchTask(DOOR, true);</span><br><span class="line">        int result = switchTask.work(PLCRegAddr.OPEN_DOOR_COMP);</span><br><span class="line">        switch (result) &#123;</span><br><span class="line">            case EXEC_SUCCESS:</span><br><span class="line">                doorState = true;</span><br><span class="line">                LogToFile.getInstane().write(LogToFile.SWITCH, &quot;开门成功&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case EXEC_TIME_OUT:</span><br><span class="line">                PLCTaskBase.showMsg(&quot;开门执行超时&quot;);</span><br><span class="line">                LogToFile.getInstane().write(LogToFile.SWITCH, &quot;开门执行超时&quot;);</span><br><span class="line">                break;</span><br><span class="line">            case WAIT_TIME_OUT:</span><br><span class="line">                PLCTaskBase.showMsg(&quot;开门等待超时&quot;);</span><br><span class="line">                LogToFile.getInstane().write(LogToFile.SWITCH, &quot;开门等待超时&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        subscriber.onCompleted();</span><br><span class="line">        SwitchMessage message = new SwitchMessage(result, DOOR);</span><br><span class="line">        message.setAction(true);</span><br><span class="line">        EventBus.getDefault().post(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">subscription = openDoor.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        .subscribeOn(Schedulers.io())</span><br><span class="line">        .subscribe(observer);</span><br></pre></td></tr></table></figure></p><p>SwitchTask类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public SwitchTask(int type, boolean value) &#123;</span><br><span class="line">      this.setaGyrate(false);</span><br><span class="line">      this.type = type;</span><br><span class="line">      this.value = value;</span><br><span class="line">      MainApplication.setIsBusying(false);//全局变量，告知设备正在忙</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>work做什么工作<br>public static final int OPEN_DOOR_COMP = 6034;<br>switchTask.work(PLCRegAddr.OPEN_DOOR_COMP);<br>    1、检查设备是否旋转，因为我们自己的项目中设备能够旋转，如果在旋转，就必须停止<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (aGyrate)&#123;</span><br><span class="line">     //如果A轴在,停止</span><br><span class="line">    GyRateTask.getInstance().stop(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2、检查PLC，连接是否正常<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (MainApplication.getMaster()==null)&#123;</span><br><span class="line">    showMsg(&quot;主机与PLC的连接已经丢失请检查&quot;);</span><br><span class="line">    return WAIT_TIME_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3、检查设备PLC是否空闲<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (MainApplication.isBusying())&#123;</span><br><span class="line">    return MACHINE_ISBUSY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4、设置设备正在忙，马上将要做其他的动作，要不然设备阻塞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MainApplication.setIsBusying(true);</span><br></pre></td></tr></table></figure></p><p>5、发送上机为就绪命令,参数解释，主机master ，PLC站号，指令id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModbusBridge.writeCoilRegister(MainApplication.getMaster(),MainApplication.getPlcNO(), PLCRegAddr.LCS_READY,true);</span><br></pre></td></tr></table></figure></p><p>   6、读取PLC返回消息，检查是否准备好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">while(!isReady)&#123;</span><br><span class="line">    //超时判断</span><br><span class="line">    if (waitTime&gt;waitTimeOut)&#123;</span><br><span class="line">        MainApplication.setIsBusying(false);</span><br><span class="line">        return WAIT_TIME_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    isReady=ModbusBridge.readCoilRegister(MainApplication.getMaster(),MainApplication.getPlcNO(), PLCRegAddr.PLC_READY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>  7、 核心发送开门指令的代码区域<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ModbusBridge.writeCoilRegister(MainApplication.getMaster(),MainApplication.getPlcNO(), PLCRegAddr.CLOSE_LEFT_DOOR,false);</span><br><span class="line">            ModbusBridge.writeCoilRegister(MainApplication.getMaster(),MainApplication.getPlcNO(), PLCRegAddr.OPEN_LEFT_DOOR,true);</span><br></pre></td></tr></table></figure></p><p> 8、读取PLC返回的消息，检查是否完成          </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">boolean isComplete=false;</span><br><span class="line">       while (!isComplete)&#123;</span><br><span class="line">           if(execTime&gt;execTimeOut)&#123;</span><br><span class="line">               reSetRegister();</span><br><span class="line">               if (aGyrate)&#123;</span><br><span class="line">                   GyrateSP.putStopTime(MainApplication.getTimestamp());</span><br><span class="line">               &#125;</span><br><span class="line">               MainApplication.setIsBusying(false);</span><br><span class="line">               return EXEC_TIME_OUT;</span><br><span class="line">           &#125;</span><br><span class="line">           isComplete=ModbusBridge.readCoilRegister(MainApplication.getMaster(),MainApplication.getPlcNO(),compAddr);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>流程图，需要在另外网页打开看的清楚一点<br><img src="http://upload-images.jianshu.io/upload_images/5363507-9d18431ccc413ad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="App开门流程.png"></p><p>#####以上就是一个完成的PLC开门的流程，可以看成一个水管放水的样子，我知道水管形态-PLC站号，同时知道需要往哪里放水-通讯地址，同时反馈给我们一个响应是否接收到到了，没有接收到，客服端再次的尝试，好吧这个比喻也不太明确，看做IP通讯也可以<br>分享点PLC的资料，如果有兴趣的话<br>链接: <a href="https://pan.baidu.com/s/1c3UpPL2" target="_blank" rel="noopener">https://pan.baidu.com/s/1c3UpPL2</a> 密码: w952</p><p>#####安卓App启动流程图<br>说着比较枯燥，画了一张图来说明！<br><img src="http://upload-images.jianshu.io/upload_images/5363507-579ba794cbcb18f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="APP启动的流程图.png"></p><p>#####App和服务器的交互流程<br>画了一张图，只能粗略的解释下整个流程<br><img src="http://upload-images.jianshu.io/upload_images/5363507-59debc53686f3ed0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="App和服务器的交互流程.png"></p><p>以上就是差不多整个流程，仅限分享使用</p>]]></content>
      
      
        <tags>
            
            <tag> PLC </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓画笔笔锋的实现探索（三）田字格Demo</title>
      <link href="/2018/02/24/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%EF%BC%89%E7%94%B0%E5%AD%97%E6%A0%BCDemo/"/>
      <url>/2018/02/24/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%89%EF%BC%89%E7%94%B0%E5%AD%97%E6%A0%BCDemo/</url>
      <content type="html"><![CDATA[<h3 id="Demo的下载地址"><a href="#Demo的下载地址" class="headerlink" title="Demo的下载地址"></a>Demo的下载地址</h3><p><img src="http://upload-images.jianshu.io/upload_images/5363507-fd626ece6fbccfb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载地址"><br><a id="more"></a></p><h3 id="效果图：如果对的效果不太明确的地方，请移步上两篇文章"><a href="#效果图：如果对的效果不太明确的地方，请移步上两篇文章" class="headerlink" title="效果图：如果对的效果不太明确的地方，请移步上两篇文章"></a>效果图：如果对的效果不太明确的地方，请移步上两篇文章</h3><p><img src="http://upload-images.jianshu.io/upload_images/5363507-408927f77c209be3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><p>####Demo中做了哪些事情<br>1、提供画板，以及收起画板的动作<br>2、插入空格<br>3、换行<br>4、删除或者长按删除<br>5、切换笔的样式<br>6、根据手指抬起来自动插入已绘制的图形到EditText中<br>7、待续</p><p>####1、提供画板，以及收起画板的动作<br>使用DrawViewLayout 继承FrameLayout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class DrawViewLayout extends FrameLayout implements View.OnClickListener, View.OnLongClickListener &#123;</span><br><span class="line"></span><br><span class="line">    private RelativeLayout mShowKeyboard;</span><br><span class="line">    private RelativeLayout mGotoPreviousStep;</span><br><span class="line">    private RelativeLayout mClearCanvas;</span><br><span class="line">    private NewDrawPenView mDrawView;</span><br><span class="line">    private RelativeLayout mSaveBitmap;</span><br><span class="line">    private ViewStub mViewStub;</span><br><span class="line">    private View mChild;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    private ImageView mUpOrDownIcon;</span><br><span class="line">    private LayoutInflater mInflater;</span><br><span class="line">    private int mPenConfig;</span><br><span class="line">    private boolean mIsShowKeyB;</span><br><span class="line"></span><br><span class="line">    public DrawViewLayout(@NonNull Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public DrawViewLayout(@NonNull Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mContext = context;</span><br><span class="line">        initView();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        mInflater = LayoutInflater.from(getContext());</span><br><span class="line">        mChild = mInflater.inflate(R.layout.brush_weight_layout, this, false);</span><br><span class="line">        addView(mChild);</span><br><span class="line">        mShowKeyboard = (RelativeLayout) findViewById(R.id.rll_show_keyb_container);</span><br><span class="line">        mGotoPreviousStep = (RelativeLayout) findViewById(R.id.rll_show_space_container);//空格</span><br><span class="line">        mClearCanvas = (RelativeLayout) findViewById(R.id.rll_show_newline_container);</span><br><span class="line">        mSaveBitmap = (RelativeLayout) findViewById(R.id.rll_show_delete_container);</span><br><span class="line">        mViewStub = (ViewStub) findViewById(R.id.draw_view);</span><br><span class="line">        //需要关心的selector的id</span><br><span class="line">        mUpOrDownIcon = (ImageView) findViewById(R.id.rll_show_keyb_container_icon);</span><br><span class="line">        setOnClickListenerT();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>布局文件使用的ViewStub轻量级的控件:使用Viewstub的在不需要弹出键盘的时候，渲染不占内存<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;ViewStub</span><br><span class="line">    android:id=&quot;@+id/draw_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;@dimen/dp_280&quot;</span><br><span class="line">    android:layout_gravity=&quot;center&quot;</span><br><span class="line">    android:layout_marginLeft=&quot;@dimen/dp_40&quot;</span><br><span class="line">    android:layout_marginRight=&quot;@dimen/dp_40&quot;</span><br><span class="line">    android:layout_marginTop=&quot;@dimen/dp_10&quot;</span><br><span class="line">    android:layout_marginBottom=&quot;@dimen/dp_10&quot;</span><br><span class="line">    android:layout=&quot;@layout/draw_view_layout&quot;</span><br><span class="line">    android:visibility=&quot;visible&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>判断是否填充过，没有的话就不填充，第一版设计的时候，产品经理说不用进入页面就弹出软件盘，那使用ViewStub，只要没有弹出来，渲染不占内存，后续产品经理说要弹出来，所以这里进入的时候，我都设计出弹出键盘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  if (mViewStub.getParent() != null) &#123;</span><br><span class="line">            mViewStub.inflate();</span><br><span class="line">       &#125;</span><br><span class="line">//隐藏软键盘</span><br><span class="line">  if (mDrawView.getVisibility() == GONE) &#123;</span><br><span class="line">            mIsShowKeyB=true;</span><br><span class="line">            mViewStub.setVisibility(VISIBLE);</span><br><span class="line">            mUpOrDownIcon.setSelected(true);</span><br><span class="line">            Toast.makeText(mContext,&quot;显示键盘&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            mDrawView.setVisibility(VISIBLE);</span><br><span class="line">        &#125; else if (mDrawView.getVisibility() == VISIBLE) &#123;</span><br><span class="line">            mIsShowKeyB=false;</span><br><span class="line">            Toast.makeText(mContext,&quot;隐藏键盘&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">            mDrawView.setVisibility(GONE);</span><br><span class="line">            mViewStub.setVisibility(GONE);</span><br><span class="line">            mUpOrDownIcon.setSelected(false);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>####2、插入空格<br>在这里说个开发中的趣事，当说要插入一个空格的时候，无非就是往EditText中插入一个空格吧，就用代码插入，但是后面ui说，你咋插入的空格那么小，我说本来就只有插入这样小啊，我能咋办，我也很绝望，后续使用的是插入一张空白的图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void needSpace() &#123;</span><br><span class="line">     NewDrawPenView view = mDrawViewLayout.getSaveBitmap();</span><br><span class="line">     if (view != null) &#123;</span><br><span class="line">         if (view.getHasDraw()) &#123;</span><br><span class="line">             mBitmap = view.getBitmap();</span><br><span class="line">             mHandler.post(runnableUi);</span><br><span class="line">             //保持一个联系</span><br><span class="line">             mHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">                 @Override</span><br><span class="line">                 public void run() &#123;</span><br><span class="line">                     mIsCreateBitmap = true;</span><br><span class="line">                     if (mCreatBimap == null) &#123;</span><br><span class="line">                         mCreatBimap = creatBimap();</span><br><span class="line">                     &#125;</span><br><span class="line">                     mHandler.post(runnableUi);</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;, 100);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             mIsCreateBitmap = true;</span><br><span class="line">             if (mCreatBimap == null) &#123;</span><br><span class="line">                 mCreatBimap = creatBimap();</span><br><span class="line">             &#125;</span><br><span class="line">             mHandler.post(runnableUi);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     mHandler.removeCallbacks(runnable);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>创建一个空白的bitmap  这里其实不用创建一个和手机设备一样大的空白的bitmap，只创建一个和文本生成的字体一样大的就行了，总感觉浪费性能，哈哈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建一个bitmap </span><br><span class="line">    private Bitmap creatBimap() &#123;</span><br><span class="line">        ColorDrawable drawable = new ColorDrawable(Color.TRANSPARENT);</span><br><span class="line">        DisplayMetrics dm = new DisplayMetrics();</span><br><span class="line">        getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">        Bitmap bitmap = Bitmap.createBitmap(dm.widthPixels, dm.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">        Canvas canvas = new Canvas(bitmap);</span><br><span class="line">        drawable.draw(canvas);</span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>把bitmap插入到edittext的线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnableUi = new Runnable() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          if (mIsCreateBitmap) &#123;</span><br><span class="line">              //110</span><br><span class="line">              mBitmapResize = BitmapDrawUtils.resizeImage(mCreatBimap, mAllHandDrawSize, mAllHandDrawSize);</span><br><span class="line">              mIsCreateBitmap = false;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              mBitmapResize = BitmapDrawUtils.resizeImage(mBitmap, mAllHandDrawSize, mAllHandDrawSize);</span><br><span class="line">          &#125;</span><br><span class="line">          if (mBitmapResize != null) &#123;</span><br><span class="line">              //根据Bitmap对象创建ImageSpan对象</span><br><span class="line">              ImageSpan imageSpan = new ImageSpan(FieldCharacterShapeActivity.this, mBitmapResize);</span><br><span class="line">              //创建一个SpannableString对象，以便插入用ImageSpan对象封装的图像</span><br><span class="line">              full_name = LAST_NAME + System.currentTimeMillis();</span><br><span class="line">              String s =FONT_NAME_HEAD + full_name + FONT_NAME_TAIL;</span><br><span class="line">              SpannableString spannableString = new SpannableString(s);</span><br><span class="line">              //  用ImageSpan对象替换face</span><br><span class="line">              spannableString.setSpan(imageSpan, 0, s.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);</span><br><span class="line">              //将选择的图片追加到EditText中光标所在位置</span><br><span class="line">              //                EditText ed = mSvContent.getFocusEditText();</span><br><span class="line">              EditText ed = mRetContent.getLastFocusEdit();</span><br><span class="line">              int index = ed.getSelectionStart(); //获取光标所在位置</span><br><span class="line">              Editable edit_text = ed.getEditableText();</span><br><span class="line">              if (index &lt; 0 || index &gt;= edit_text.length()) &#123;</span><br><span class="line">                  edit_text.append(spannableString);</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                  edit_text.insert(index, spannableString);</span><br><span class="line">              &#125;</span><br><span class="line">              testStorage();</span><br><span class="line">          &#125;</span><br><span class="line">          mDrawViewLayout.clearScreen();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">     * 图片缩放</span><br><span class="line">     * @param originalBitmap 原始的Bitmap</span><br><span class="line">     * @param newWidth 自定义宽度</span><br><span class="line">     * @return 缩放后的Bitmap</span><br><span class="line">     */</span><br><span class="line">    public static Bitmap resizeImage(Bitmap originalBitmap, int newWidth, int newHeight)&#123;</span><br><span class="line">        if (originalBitmap==null||originalBitmap.getWidth()==0||originalBitmap.getHeight()==0)&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        int width = originalBitmap.getWidth();</span><br><span class="line">        int height = originalBitmap.getHeight();</span><br><span class="line">        //定义欲转换成的宽、高</span><br><span class="line">//            int newWidth = 200;</span><br><span class="line">//            int newHeight = 200;</span><br><span class="line">        //计算宽、高缩放率</span><br><span class="line">        float scanleWidth = (float)newWidth/width;</span><br><span class="line">        float scanleHeight = (float)newHeight/height;</span><br><span class="line">        //创建操作图片用的matrix对象 Matrix</span><br><span class="line">        Matrix matrix = new Matrix();</span><br><span class="line">        matrix.postScale(scanleWidth,scanleHeight);</span><br><span class="line">        // 创建新的图片Bitmap</span><br><span class="line">        Bitmap resizedBitmap = Bitmap.createBitmap(originalBitmap,0,0,width,height,matrix,true);</span><br><span class="line">        return resizedBitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>####3、换行<br>获取ScrollView最后的一个EditText，对了，这里没说，由于，需要滑动，所以自定义了一个ScrollView，可以插入很多控件，图片，文字和语音等等，好多的控件，由于这里不需要那么多，所以只保留了一个EditText<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 这里是换行的需要</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public void creatNewLine() &#123;</span><br><span class="line">    EditText ed = mRetContent.getLastFocusEdit();</span><br><span class="line">    int index = ed.getSelectionStart();</span><br><span class="line">    Editable editable = ed.getText();</span><br><span class="line">    editable.insert(index, &quot;\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####4、删除或者长按删除</p><p>代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void deleteOnClick() &#123;</span><br><span class="line">    if (mRetContent.getLastFocusEdit().getSelectionStart() == 0) &#123;</span><br><span class="line">        mRetContent.onBackspacePress(mRetContent.getLastFocusEdit());</span><br><span class="line">        if (mHandler!=null) &#123;</span><br><span class="line">            mHandler.removeCallbacks(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        SystemUtils.sendKeyCode(67);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * &lt;pre&gt;</span><br><span class="line">    * 使用Instrumentation接口：对于非自行编译的安卓系统，无法获取系统签名，只能在前台模拟按键，不能后台模拟</span><br><span class="line">    * 注意:调用Instrumentation的sendKeyDownUpSync方法必须另起一个线程，否则无效</span><br><span class="line">    * @param keyCode</span><br><span class="line">    *            按键事件(KeyEvent)的按键值</span><br><span class="line">    * &lt;/pre&gt;</span><br><span class="line">    */</span><br><span class="line">   public static void sendKeyCode(final int keyCode) &#123;</span><br><span class="line">       new Thread(new Runnable() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                   // 创建一个Instrumentation对象</span><br><span class="line">                   Instrumentation inst = new Instrumentation();</span><br><span class="line">                   // 调用inst对象的按键模拟方法</span><br><span class="line">                   inst.sendKeyDownUpSync(keyCode);</span><br><span class="line">               &#125; catch (Exception e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>长按删除的事件呢，其实无非就是让这个方法不断的执行SystemUtils.sendKeyCode(67);在这里我使用枚举的单利模式，其实这样做不太好，因为枚举的单利比较消耗内存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.pen.field_character;</span><br><span class="line"></span><br><span class="line">import android.annotation.SuppressLint;</span><br><span class="line">import android.os.Handler;</span><br><span class="line">import android.os.Message;</span><br><span class="line"></span><br><span class="line">import com.shiming.pen.R;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line">import java.util.concurrent.ScheduledExecutorService;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @version v1.0 create at 2017/9/13</span><br><span class="line"> * @des 使用模式为enum的单利模式</span><br><span class="line"> */</span><br><span class="line">public enum Executor &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    private ScheduledExecutorService mScheduledExecutorService;</span><br><span class="line">    private DrawViewLayout.IActionCallback mCallback;</span><br><span class="line"></span><br><span class="line">    public void setCallback(DrawViewLayout.IActionCallback callback) &#123;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private Handler handler = new Handler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            int viewId = msg.what;</span><br><span class="line">            switch (viewId) &#123;</span><br><span class="line">                case R.id.rll_show_delete_container:</span><br><span class="line">                    if (mCallback == null)</span><br><span class="line">                        return;</span><br><span class="line">                    mCallback.deleteOnLongClick();</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public void upData(int id) &#123;</span><br><span class="line">        final int vid = id;</span><br><span class="line">        //只有一个线程，用来调度执行将来的任务</span><br><span class="line">        mScheduledExecutorService = Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">        //多少时间执行一次</span><br><span class="line">        mScheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                Message msg = new Message();</span><br><span class="line">                msg.what = vid;</span><br><span class="line">                handler.sendMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 0, 100, TimeUnit.MILLISECONDS);    //每间隔100ms发送Message</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stop() &#123;</span><br><span class="line">        if (mScheduledExecutorService != null) &#123;</span><br><span class="line">            mScheduledExecutorService.shutdownNow();</span><br><span class="line">            mScheduledExecutorService = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的方法这里<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void deleteOnLongClick() &#123;</span><br><span class="line">      if (mRetContent.getLastFocusEdit().getSelectionStart() == 0) &#123;</span><br><span class="line">          mRetContent.onBackspacePress(mRetContent.getLastFocusEdit());</span><br><span class="line">          if (mHandler!=null) &#123;</span><br><span class="line">              mHandler.removeCallbacks(runnable);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          SystemUtils.sendKeyCode(67);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####5、切换笔的样式<br>这里笔的样式能有三种的情况，钢笔，水彩笔，和橡皮擦，由于我这里每次都自动的保存了图片，所以最后一次都是橡皮擦的模式，所以我只要判断不是Pen的模式，就给它赋予这种的模式，同时还需更具点击事件的变化而变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onClick(View v) &#123;</span><br><span class="line">      int penConfig = mDrawViewLayout.getPenConfig();</span><br><span class="line">      switch (v.getId())&#123;</span><br><span class="line">          case R.id.btn_change_pen:</span><br><span class="line">              if (penConfig== IPenConfig.STROKE_TYPE_PEN)&#123;</span><br><span class="line">                  penConfig=IPenConfig.STROKE_TYPE_BRUSH;</span><br><span class="line">              &#125;else &#123;</span><br><span class="line">                  penConfig=IPenConfig.STROKE_TYPE_PEN;</span><br><span class="line">              &#125;</span><br><span class="line">              mDrawViewLayout.setPenConfig(penConfig);</span><br><span class="line">              break;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void setPenConfig(int penConfig) &#123;</span><br><span class="line">    mDrawView.setCanvasCode(penConfig);</span><br><span class="line">     mPenConfig=penConfig;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>最底层的方法 在这里 ，关键的地方需要invalidate一次，这样自定义view才知道需要变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void setCanvasCode(int canvasCode) &#123;</span><br><span class="line">    mCanvasCode = canvasCode;</span><br><span class="line">    switch (mCanvasCode) &#123;</span><br><span class="line">        case IPenConfig.STROKE_TYPE_PEN:</span><br><span class="line">            mStokeBrushPen = new SteelPen(mContext);</span><br><span class="line">            break;</span><br><span class="line">        case IPenConfig.STROKE_TYPE_BRUSH:</span><br><span class="line">            mStokeBrushPen = new BrushPen(mContext);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    //设置</span><br><span class="line">    if (mStokeBrushPen.isNull())&#123;</span><br><span class="line">        mStokeBrushPen.setPaint(mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####6、根据手指抬起来自动插入已绘制的图形到EditText中<br>在onTouchEvent事件中，记录手指抬起来的时间，同时记录下必须需要停止的时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">      mIsCanvasDraw = true;</span><br><span class="line">      //测试过程中，当使用到event的时候，产生了没有收到事件的问题，所以在这里需要obtian的一下</span><br><span class="line">      MotionEvent event2 = MotionEvent.obtain(event);</span><br><span class="line">      switch (event2.getActionMasked()) &#123;</span><br><span class="line">          case MotionEvent.ACTION_DOWN:</span><br><span class="line">              //每次都是这个笔，因为项目里面就只有这个笔，如果多了，这里需要改动</span><br><span class="line">              setCanvasCode(CANVAS_NORMAL);</span><br><span class="line">              mVisualStrokePen.onDown(mVisualStrokePen.createMotionElement(event2));</span><br><span class="line">              mGetTimeListner.stopTime();</span><br><span class="line">              break;</span><br><span class="line">          case MotionEvent.ACTION_MOVE:</span><br><span class="line">              mVisualStrokePen.onMove(mVisualStrokePen.createMotionElement(event2));</span><br><span class="line">              mGetTimeListner.stopTime();</span><br><span class="line">              break;</span><br><span class="line">          case MotionEvent.ACTION_UP:</span><br><span class="line">              long time = System.currentTimeMillis();</span><br><span class="line">              mGetTimeListner.getTime(time);</span><br><span class="line">              mVisualStrokePen.onUp(mVisualStrokePen.createMotionElement(event2),mCanvas);</span><br><span class="line">              break;</span><br><span class="line">          default:</span><br><span class="line">              break;</span><br><span class="line">      &#125;</span><br><span class="line">      invalidate();</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>接口回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mDrawView.setGetTimeListener(new NewDrawPenView.TimeListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void getTime(long l) &#123;</span><br><span class="line">        mIActionCallback.getUptime(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void stopTime() &#123;</span><br><span class="line">        mIActionCallback.stopTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>需要做什么，其实就是一个任务<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void getUptime(long l) &#123;</span><br><span class="line">    mOldTime = l;</span><br><span class="line">    mHandler.postDelayed(runnable, 100);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void stopTime() &#123;</span><br><span class="line">    mHandler.removeCallbacks(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当大于时间了，就使用handler发送一个消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final Runnable runnable = new Runnable() &#123;</span><br><span class="line">     @Override</span><br><span class="line">     public void run() &#123;</span><br><span class="line">         long l1 = System.currentTimeMillis();</span><br><span class="line">         if ((l1 - mOldTime) &gt; HADN_DRAW_TIME) &#123;</span><br><span class="line">             mHandler.removeCallbacks(runnable);</span><br><span class="line">             Message msg = mHandler.obtainMessage();</span><br><span class="line">             msg.obj = true;</span><br><span class="line">             msg.what = 0x123;</span><br><span class="line">             mHandler.sendMessage(msg);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             mHandler.postDelayed(this, 100);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><p>处理handler消息，关键就是这个  mBitmap = view.clearBlank(100);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@SuppressLint(&quot;HandlerLeak&quot;)//麻痹</span><br><span class="line">   private Handler mHandler = new Handler() &#123;</span><br><span class="line">       @Override</span><br><span class="line">       public void handleMessage(Message msg) &#123;</span><br><span class="line">           super.handleMessage(msg);</span><br><span class="line">           int what = msg.what;</span><br><span class="line">           switch (what) &#123;</span><br><span class="line">               case 0x123:</span><br><span class="line">                   try &#123;</span><br><span class="line">                       boolean obj = (boolean) msg.obj;</span><br><span class="line">                       if (obj) &#123;</span><br><span class="line">                           NewDrawPenView view = mDrawViewLayout.getSaveBitmap();</span><br><span class="line">                           if (view != null) &#123;</span><br><span class="line">                               //边距强行扫描</span><br><span class="line">                               mBitmap = view.clearBlank(100);</span><br><span class="line">                               mHandler.post(runnableUi);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                   &#125; finally &#123;</span><br><span class="line">                       mHandler.removeCallbacks(runnable);</span><br><span class="line">                   &#125;</span><br><span class="line">                   break;</span><br><span class="line">               case 0x124:</span><br><span class="line">                   mRetContent.setVisibilityEdit(View.VISIBLE);</span><br><span class="line">                   mRetContent.setVisibilityClose(View.VISIBLE);</span><br><span class="line">                   mRetContent.getLastFocusEdit().setCursorVisible(true);</span><br><span class="line">                   mRetContent.getLastFocusEdit().requestFocus();</span><br><span class="line">                   break;</span><br><span class="line">               case 0x125:</span><br><span class="line">                   break;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;;</span><br></pre></td></tr></table></figure></p><p>关于这个方法clearBlank（int  ），这个方法不是我写的，我又一次研究别人的一个Demo，测试下了这个效果非常牛逼，本来这个方法打算废弃掉，但是最后觉得太可惜了，写这个田字格的Demo又提出来了。其实还有种方法可以实现，就是我们知道画布的大小，同时也知道，需要生成的小图的大小，我们可以动态的算，这就是另外一种方法，在不同设备上有点小许差异，但是也还可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 逐行扫描 清楚边界空白。功能是生成一张bitmap位于正中间，不是位于顶部，此关键的是我们画布需要</span><br><span class="line">    * 成透明色才能生效</span><br><span class="line">    * @param blank 边距留多少个像素</span><br><span class="line">    * @return tks github E-signature</span><br><span class="line">    */</span><br><span class="line">   public Bitmap clearBlank(int blank) &#123;</span><br><span class="line">       if (mBitmap != null) &#123;</span><br><span class="line">           int HEIGHT = mBitmap.getHeight();//1794</span><br><span class="line">           int WIDTH = mBitmap.getWidth();//1080</span><br><span class="line">           int top = 0, left = 0, right = 0, bottom = 0;</span><br><span class="line">           int[] pixs = new int[WIDTH];</span><br><span class="line">           boolean isStop;</span><br><span class="line">           for (int y = 0; y &lt; HEIGHT; y++) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, WIDTH, 0, y, WIDTH, 1);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line"></span><br><span class="line">                       top = y;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int y = HEIGHT - 1; y &gt;= 0; y--) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, WIDTH, 0, y, WIDTH, 1);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       bottom = y;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           pixs = new int[HEIGHT];</span><br><span class="line">           for (int x = 0; x &lt; WIDTH; x++) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, 1, x, 0, 1, HEIGHT);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       left = x;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int x = WIDTH - 1; x &gt; 0; x--) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, 1, x, 0, 1, HEIGHT);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       right = x;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (blank &lt; 0) &#123;</span><br><span class="line">               blank = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           left = left - blank &gt; 0 ? left - blank : 0;</span><br><span class="line">           top = top - blank &gt; 0 ? top - blank : 0;</span><br><span class="line">           right = right + blank &gt; WIDTH - 1 ? WIDTH - 1 : right + blank;</span><br><span class="line">           bottom = bottom + blank &gt; HEIGHT - 1 ? HEIGHT - 1 : bottom + blank;</span><br><span class="line">           return Bitmap.createBitmap(mBitmap, left, top, right - left, bottom - top);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##最后，谢谢提出问题的大佬</p><p>##GitHub：<a href="https://github.com/Shimingli/WritingPen" target="_blank" rel="noopener">https://github.com/Shimingli/WritingPen</a></p>]]></content>
      
      
        <tags>
            
            <tag> 田字格Demo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年</title>
      <link href="/2018/01/25/2018/"/>
      <url>/2018/01/25/2018/</url>
      <content type="html"><![CDATA[<ul><li>最近换了工作，一下子负责了两个App，一个硬件的一个商城的，突然感觉这应该是来深圳3年了，这才是最累的时候，早上6点就被吵醒，晚上11点下班，突然感觉好累</li><li>哈哈哈！ 好好工作吧，心跳最重要</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓画笔笔锋的实现探索（二）</title>
      <link href="/2017/10/18/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2017/10/18/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<ul><li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</li></ul><h4 id="1、下图的效果的实现看这篇文章：http-www-jianshu-com-p-6746d68ef2c3"><a href="#1、下图的效果的实现看这篇文章：http-www-jianshu-com-p-6746d68ef2c3" class="headerlink" title="1、下图的效果的实现看这篇文章：http://www.jianshu.com/p/6746d68ef2c3"></a>1、下图的效果的实现看这篇文章：<a href="http://www.jianshu.com/p/6746d68ef2c3" target="_blank" rel="noopener">http://www.jianshu.com/p/6746d68ef2c3</a></h4><p><img src="http://upload-images.jianshu.io/upload_images/5363507-5c24ce51a1e6f311.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20171018135736.jpg"><br><a id="more"></a></p><h4 id="2、水彩笔效果一"><a href="#2、水彩笔效果一" class="headerlink" title="2、水彩笔效果一"></a>2、水彩笔效果一</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不设置</span><br><span class="line">paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class="line">//使用原图的资源文件为</span><br><span class="line">mOriginBitmap = BitmapFactory.decodeResource( mContext.getResources(), R.mipmap.brush);</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5363507-255d0ef05ebc1698.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20171018135732.jpg"></p><p>####3、水彩笔效果二，使用原图的资源文件为R.mipmap.cicrle<br><img src="http://upload-images.jianshu.io/upload_images/5363507-83b7c51278773bb7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20171018135726.jpg"></p><p>####4、水彩笔效果三，使用原图的资源文件为R.mipmap.tranglie<br><img src="http://upload-images.jianshu.io/upload_images/5363507-06e3e68bf6c7c2ac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20171018135715.jpg"></p><p>####5、设置paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));的效果<br><img src="http://upload-images.jianshu.io/upload_images/5363507-e38949e0ff3b45ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20171018143623.jpg"></p><p>##如何实现的细节在上篇文章有很仔细的说明，可先看上篇文章</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-265b8025187b7d76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###1.代码上我抽取了一个基类，主要是方便后面的扩展<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @version v1.0 create at 2017/10/17</span><br><span class="line"> * @des 处理draw和touch事件的基类</span><br><span class="line"> */</span><br><span class="line">public abstract class BasePen &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 绘制</span><br><span class="line">     *</span><br><span class="line">     * @param canvas</span><br><span class="line">     */</span><br><span class="line">    public abstract  void draw(Canvas canvas);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 接受并处理onTouchEvent</span><br><span class="line">     *</span><br><span class="line">     * @param event</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public  boolean onTouchEvent(MotionEvent event,Canvas canvas)&#123;</span><br><span class="line">         return false;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###2、关于BasePenExtend集成BasePen<br>draw方法的抽取，和上篇文章一样，当接触到的点很少的时候，不用去绘制，由于在实现水彩笔的时候，使用一只笔的时候会导致整个画布的笔的透明度发生改变，所以提供了一个抽象的方法让子类去实现，SteelPen和BrushPen中唯一在draw的差别就是多了一只paint。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void draw(Canvas canvas) &#123;</span><br><span class="line">       mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">       //点的集合少 不去绘制</span><br><span class="line">       if (mHWPointList == null || mHWPointList.size() &lt; 1)</span><br><span class="line">           return;</span><br><span class="line">       //当控制点的集合很少的时候，需要画个小圆，但是需要算法</span><br><span class="line">       if (mHWPointList.size() &lt; 2) &#123;</span><br><span class="line">           ControllerPoint point = mHWPointList.get(0);</span><br><span class="line">           //由于此问题在算法上还没有实现，所以暂时不给他画圆圈</span><br><span class="line">           //canvas.drawCircle(point.x, point.y, point.width, mPaint);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           mCurPoint = mHWPointList.get(0);</span><br><span class="line">           drawNeetToDo(canvas);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">    * 这里由于在设置笔的透明度，会导致整个线，或者说整个画布的的颜透明度随着整个笔的透明度而变化，</span><br><span class="line">    * 所以在这里考虑是不是说，绘制毛笔的时候，每次都给它new 一个paint ，但是这里我还没有找到更好的办法</span><br><span class="line">    *</span><br><span class="line">    * @param canvas</span><br><span class="line">    */</span><br><span class="line">   // TODO: 2017/10/17  这个问题  待解决</span><br><span class="line">   protected abstract void drawNeetToDo(Canvas canvas);</span><br></pre></td></tr></table></figure></p><p>onTouchEvent事件在NewDrawPenView调用，这里实现就可以了，注意这个问题就行，event会被下一次事件重用，这里必须生成新的，否则会有问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public boolean onTouchEvent(MotionEvent event,Canvas canvas) &#123;</span><br><span class="line">     // event会被下一次事件重用，这里必须生成新的，否则会有问题</span><br><span class="line">     MotionEvent event2 = MotionEvent.obtain(event);</span><br><span class="line">     switch (event.getActionMasked()) &#123;</span><br><span class="line">         case MotionEvent.ACTION_DOWN:</span><br><span class="line">             onDown(createMotionElement(event2));</span><br><span class="line">             return true;</span><br><span class="line">         case MotionEvent.ACTION_MOVE:</span><br><span class="line">             onMove(createMotionElement(event2));</span><br><span class="line">             return true;</span><br><span class="line">         case MotionEvent.ACTION_UP:</span><br><span class="line">             onUp(createMotionElement(event2),canvas);</span><br><span class="line">             return true;</span><br><span class="line">         default:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">     return super.onTouchEvent(event,canvas);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>onDown事件的实现，由于在自定义View中，MotionEvent.ACTION_DOWN:事件的触发要比onDraw早，当实现水彩笔的时候，我在想每次能不能使用一只新的笔，那么改变笔的透明度的时候，画布其他上上的笔画的就不会发生改变，所以暴露了一个方法，让子类去实现，不从写的话，这个笔就会为null！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 按下的事件</span><br><span class="line">   * @param mElement</span><br><span class="line">   */</span><br><span class="line">  public void onDown(MotionElement mElement)&#123;</span><br><span class="line">      if (mPaint==null)&#123;</span><br><span class="line">          throw new NullPointerException(&quot;paint 笔不可能为null哦&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (getNewPaint(mPaint)!=null)&#123;</span><br><span class="line">          Paint paint=getNewPaint(mPaint);</span><br><span class="line">          mPaint=paint;</span><br><span class="line">          //当然了，不要因为担心内存泄漏，在每个变量使用完成后都添加xxx=null，</span><br><span class="line">          // 对于消除过期引用的最好方法，就是让包含该引用的变量结束生命周期，而不是显示的清空</span><br><span class="line">          paint=null;</span><br><span class="line">          System.out.println(&quot;shiming 当绘制的时候是否为新的paint&quot;+mPaint+&quot;原来的对象是否销毁了paint==&quot;+paint);</span><br><span class="line">      &#125;</span><br><span class="line">      mPointList.clear();</span><br><span class="line">      //如果在brush字体这里接受到down的事件，把下面的这个集合清空的话，那么绘制的内容会发生改变</span><br><span class="line">      //不清空的话，也不可能</span><br><span class="line">      mHWPointList.clear();</span><br><span class="line">      //记录down的控制点的信息</span><br><span class="line">      ControllerPoint curPoint = new ControllerPoint(mElement.x, mElement.y);</span><br><span class="line">      //如果用笔画的画我的屏幕，记录他宽度的和压力值的乘，但是哇，</span><br><span class="line">      if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">          mLastWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          //如果是手指画的，我们取他的0.8</span><br><span class="line">          mLastWidth = 0.8 * mBaseWidth;</span><br><span class="line">      &#125;</span><br><span class="line">      //down下的点的宽度</span><br><span class="line">      curPoint.width = (float) mLastWidth;</span><br><span class="line">      mLastVel = 0;</span><br><span class="line">      mPointList.add(curPoint);</span><br><span class="line">      //记录当前的点</span><br><span class="line">      mLastPoint = curPoint;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">protected  Paint getNewPaint(Paint paint)&#123;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>onMove事件其实实现原理和上篇文章一样，但是呢，当绘制水彩笔的时候，有个透明度的关系，所以需要交给子类去实现.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 手指移动的事件</span><br><span class="line">    * @param mElement</span><br><span class="line">    */</span><br><span class="line">   public void onMove(MotionElement mElement)&#123;</span><br><span class="line"></span><br><span class="line">       ControllerPoint curPoint = new ControllerPoint(mElement.x, mElement.y);</span><br><span class="line">       double deltaX = curPoint.x - mLastPoint.x;</span><br><span class="line">       double deltaY = curPoint.y - mLastPoint.y;</span><br><span class="line">       //deltaX和deltay平方和的二次方根 想象一个例子 1+1的平方根为1.4 （x²+y²）开根号</span><br><span class="line">       double curDis = Math.hypot(deltaX, deltaY);</span><br><span class="line">       //我们求出的这个值越小，画的点或者是绘制椭圆形越多，这个值越大的话，绘制的越少，笔就越细，宽度越小</span><br><span class="line">       double curVel = curDis * IPenConfig.DIS_VEL_CAL_FACTOR;</span><br><span class="line">       double curWidth;</span><br><span class="line">       //点的集合少，我们得必须改变宽度,每次点击的down的时候，这个事件</span><br><span class="line">       if (mPointList.size() &lt; 2) &#123;</span><br><span class="line">           if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">               curWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               curWidth = calcNewWidth(curVel, mLastVel, curDis, 1.5,</span><br><span class="line">                       mLastWidth);</span><br><span class="line">           &#125;</span><br><span class="line">           curPoint.width = (float) curWidth;</span><br><span class="line">           mBezier.init(mLastPoint, curPoint);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           mLastVel = curVel;</span><br><span class="line">           if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">               curWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //由于我们手机是触屏的手机，滑动的速度也不慢，所以，一般会走到这里来</span><br><span class="line">               //阐明一点，当滑动的速度很快的时候，这个值就越小，越慢就越大，依靠着mlastWidth不断的变换</span><br><span class="line">               curWidth = calcNewWidth(curVel, mLastVel, curDis, 1.5,</span><br><span class="line">                       mLastWidth);</span><br><span class="line">           &#125;</span><br><span class="line">           curPoint.width = (float) curWidth;</span><br><span class="line">           mBezier.addNode(curPoint);</span><br><span class="line">       &#125;</span><br><span class="line">       //每次移动的话，这里赋值新的值</span><br><span class="line">       mLastWidth = curWidth;</span><br><span class="line"></span><br><span class="line">       mPointList.add(curPoint);</span><br><span class="line">       moveNeetToDo(curDis);</span><br><span class="line">       mLastPoint = curPoint;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 移动的时候，这里由于需要透明度的处理，交给子类</span><br><span class="line">    * @param</span><br><span class="line">    */</span><br><span class="line">   protected abstract void moveNeetToDo(double f);</span><br></pre></td></tr></table></figure></p><p>在上篇文章中我们有详细介绍calcNewWidth（）方法的作用：当滑动的速度很快的时候，这个值就越小，越慢就越大，依靠着mlastWidth不断的变换，如何变化的呢？在代码中做了很详细的解释<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public double calcNewWidth(double curVel, double lastVel, double curDis,</span><br><span class="line">                               double factor, double lastWidth) &#123;</span><br><span class="line">       double calVel = curVel * 0.6 + lastVel * (1 - 0.6);</span><br><span class="line">       //返回指定数字的自然对数</span><br><span class="line">       //手指滑动的越快，这个值越小，为负数</span><br><span class="line">       double vfac = Math.log(factor * 2.0f) * (-calVel);</span><br><span class="line">       //此方法返回值e，其中e是自然对数的基数。</span><br><span class="line">       //Math.exp(vfac) 变化范围为0 到1 当手指没有滑动的时候 这个值为1 当滑动很快的时候无线趋近于0</span><br><span class="line">       //在次说明下，当手指抬起来，这个值会变大，这也就说明，抬起手太慢的话，笔锋效果不太明显</span><br><span class="line">       //这就说明为什么笔锋的效果不太明显</span><br><span class="line">       double calWidth = mBaseWidth * Math.exp(vfac);</span><br><span class="line">       //滑动的速度越快的话，mMoveThres也越大</span><br><span class="line">       double mMoveThres = curDis * 0.01f;</span><br><span class="line">       //对之值最大的地方进行控制</span><br><span class="line">       if (mMoveThres &gt; IPenConfig.WIDTH_THRES_MAX) &#123;</span><br><span class="line">           mMoveThres = IPenConfig.WIDTH_THRES_MAX;</span><br><span class="line">       &#125;</span><br><span class="line">       //滑动的越快的话，第一个判断会走</span><br><span class="line">       if (Math.abs(calWidth - mBaseWidth) / mBaseWidth &gt; mMoveThres) &#123;</span><br><span class="line"></span><br><span class="line">           if (calWidth &gt; mBaseWidth) &#123;</span><br><span class="line">               calWidth = mBaseWidth * (1 + mMoveThres);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               calWidth = mBaseWidth * (1 - mMoveThres);</span><br><span class="line">           &#125;</span><br><span class="line">           //滑动的越慢的话，第二个判断会走</span><br><span class="line">       &#125; else if (Math.abs(calWidth - lastWidth) / lastWidth &gt; mMoveThres) &#123;</span><br><span class="line"></span><br><span class="line">           if (calWidth &gt; lastWidth) &#123;</span><br><span class="line">               calWidth = lastWidth * (1 + mMoveThres);</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               calWidth = lastWidth * (1 - mMoveThres);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return calWidth;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>最后一步绘制，只需要要判断现在的点和触摸点的位置一样就不用去绘制，其余的交个子类去实现即可，在这里我有一个问题没有解决，在onDown事件下，就是一直按着屏幕某个点的时候，这个方法会一直走，意思就是说，用户的行为没有发生绘制笔，但是呢，代码一直在绘制，不断重复的绘制，可能在性能上不太友好！还需优化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 当现在的点和触摸点的位置在一起的时候不用去绘制</span><br><span class="line"> * @param canvas</span><br><span class="line"> * @param point</span><br><span class="line"> * @param paint</span><br><span class="line"> */</span><br><span class="line">protected void drawToPoint(Canvas canvas, ControllerPoint point, Paint paint) &#123;</span><br><span class="line">    if ((mCurPoint.x == point.x) &amp;&amp; (mCurPoint.y == point.y)) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //毛笔的效果和钢笔的不太一样，交给自己去实现</span><br><span class="line">    doNeetToDo(canvas,point,paint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##关于BrushPen</p><p>####初始化是从资源文件中获取bitmap，在我个人的测试中，当资源文件如果形状很多种的时候，会构建很多中的笔画的效果，非常有意思，如上面的图例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public BrushPen(Context context) &#123;</span><br><span class="line">      super(context);</span><br><span class="line">      initTexture();</span><br><span class="line">  &#125;</span><br><span class="line"> /**</span><br><span class="line">   * 感谢公司的ui大哥  小伍哥 免费给的切图</span><br><span class="line">   * R.mipmap.tranglie 设置的时候有点像三角形的笔锋</span><br><span class="line">   * R.mipmap.cicrle    圆形的笔锋效果</span><br><span class="line">   * R.mipmap.six        六边形有点怪怪的，可以测试一下</span><br><span class="line">   * R.drawable.brush  这个才是用起来比较舒服，如果你的笔锋要很尖的话，叫ui爸爸给你裁剪这种图 越尖越好</span><br><span class="line">   */</span><br><span class="line">  private void initTexture() &#123;</span><br><span class="line">      //通过资源文件生成的原始的bitmap区域 后面的资源图有些更加有意识的东西</span><br><span class="line">      mOriginBitmap = BitmapFactory.decodeResource(</span><br><span class="line">              mContext.getResources(), R.mipmap.brush);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####setBitmap(bitmap)方法，主要是得到需要绘制的rect的区域，这个没什么，一些列的操作的时候，但是这里有个很有趣的现象， paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));以下的话源自网络不是我说的，哈哈：PorterDuffXfermode其实就是简单的图形交并集计算，比如重叠的部分删掉或者叠加等等，事实上呢！PorterDuffXfermode的计算绝非是根据于此！如下图所示，最常见的应用就是蒙板绘制，利用源图作为蒙板“抠出”目标图上的图像。</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-69b64f0ac0d1909e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####Xfermode国外有大神称之为过渡模式，这种翻译比较贴切但恐怕不易理解，大家也可以直接称之为图像混合模式，这是我在上篇文章介绍的，抛砖引玉下，地址：<a href="http://www.cnblogs.com/tianzhijiexian/p/4297172.html" target="_blank" rel="noopener">http://www.cnblogs.com/tianzhijiexian/p/4297172.html</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 主要是得到需要绘制的rect的区域</span><br><span class="line"> * @param bitmap</span><br><span class="line"> */</span><br><span class="line">private void setBitmap(Bitmap bitmap) &#123;</span><br><span class="line">    Canvas canvas = new Canvas();</span><br><span class="line">    mBitmap = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(),</span><br><span class="line">            Bitmap.Config.ARGB_8888);</span><br><span class="line">    //用指定的方式填充位图的像素。</span><br><span class="line">    mBitmap.eraseColor(Color.rgb(Color.red(mPaint.getColor()),</span><br><span class="line">            Color.green(mPaint.getColor()), Color.blue(mPaint.getColor())));</span><br><span class="line">    //用画布制定位图绘制</span><br><span class="line">    canvas.setBitmap(mBitmap);</span><br><span class="line">    Paint paint = new Paint();</span><br><span class="line">    //如果把这行代码注释掉这里生成的东西更加有意思</span><br><span class="line">    paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));</span><br><span class="line">    canvas.drawBitmap(bitmap, 0, 0, paint);</span><br><span class="line"></span><br><span class="line">    //src 代表需要绘制的区域</span><br><span class="line">    mOldRect.set(0, 0, mBitmap.getWidth()/4, mBitmap.getHeight()/4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####根据笔的宽度的变化，笔的透明度要和发生变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 更具笔的宽度的变化，笔的透明度要和发生变化</span><br><span class="line"> * @param point</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private ControllerPoint getWithPointAlphaPoint(ControllerPoint point) &#123;</span><br><span class="line">    ControllerPoint nPoint = new ControllerPoint();</span><br><span class="line">    nPoint.x = point.x;</span><br><span class="line">    nPoint.y = point.y;</span><br><span class="line">    nPoint.width = point.width;</span><br><span class="line">    int alpha = (int) (255 * point.width / mBaseWidth / 2);</span><br><span class="line">    if (alpha &lt; 10) &#123;</span><br><span class="line">        alpha = 10;</span><br><span class="line">    &#125; else if (alpha &gt; 255) &#123;</span><br><span class="line">        alpha = 255;</span><br><span class="line">    &#125;</span><br><span class="line">    nPoint.alpha = alpha;</span><br><span class="line">    return nPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####这里才是关键的地方，原理就是不断的绘制Bitmap，通过Bitmap构建成为一根线，同时绘制区域的大小，直接导致笔的宽度的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">protected void drawLine(Canvas canvas, double x0, double y0, double w0,</span><br><span class="line">                           int a0, double x1, double y1, double w1, int a1, Paint paint) &#123;</span><br><span class="line">       double curDis = Math.hypot(x0 - x1, y0 - y1);</span><br><span class="line">       int factor = 2;</span><br><span class="line">       if (paint.getStrokeWidth() &lt; 6) &#123;</span><br><span class="line">           factor = 1;</span><br><span class="line">       &#125; else if (paint.getStrokeWidth() &gt; 60) &#123;</span><br><span class="line">           factor = 3;</span><br><span class="line">       &#125;</span><br><span class="line">       int steps = 1 + (int) (curDis / factor);</span><br><span class="line">       double deltaX = (x1 - x0) / steps;</span><br><span class="line">       double deltaY = (y1 - y0) / steps;</span><br><span class="line">       double deltaW = (w1 - w0) / steps;</span><br><span class="line">       double deltaA = (a1 - a0) / steps;</span><br><span class="line">       double x = x0;</span><br><span class="line">       double y = y0;</span><br><span class="line">       double w = w0;</span><br><span class="line">       double a = a0;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; steps; i++) &#123;</span><br><span class="line">           if (w &lt; 1.5)</span><br><span class="line">               w = 1.5;</span><br><span class="line">           //根据点的信息计算出需要把bitmap绘制在什么地方</span><br><span class="line">           mNeedDrawRect.set((float) (x - w / 2.0f), (float) (y - w / 2.0f),</span><br><span class="line">                   (float) (x + w / 2.0f), (float) (y + w / 2.0f));</span><br><span class="line">           //每次到这里来的话，这个笔的透明度就会发生改变，但是呢，这个笔不用同一个的话，有点麻烦</span><br><span class="line">           //我在这里做了个不是办法的办法，每次呢？我都从新new了一个新的笔，每次循环就new一个，内存就有很多的笔了</span><br><span class="line">           //这里new 新的笔  我放到外面去做了</span><br><span class="line">           //Paint newPaint = new Paint(paint);</span><br><span class="line">           //当这里很小的时候，透明度就会很小，个人测试在3.0左右比较靠谱</span><br><span class="line">           paint.setAlpha((int) (a / 3.0f));</span><br><span class="line">           //第一个Rect 代表要绘制的bitmap 区域，第二个 Rect 代表的是要将bitmap 绘制在屏幕的什么地方</span><br><span class="line">           canvas.drawBitmap(mBitmap, mOldRect, mNeedDrawRect, paint);</span><br><span class="line">           x += deltaX;</span><br><span class="line">           y += deltaY;</span><br><span class="line">           w += deltaW;</span><br><span class="line">           a += deltaA;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##关于SteelPen，由于在上篇文章已经很详细的介绍了，这里就不在多少，需要的话，移步上篇文章：<a href="http://www.jianshu.com/p/6746d68ef2c3" target="_blank" rel="noopener">http://www.jianshu.com/p/6746d68ef2c3</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.pen.new_code;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.graphics.Canvas;</span><br><span class="line">import android.graphics.Paint;</span><br><span class="line">import android.graphics.RectF;</span><br><span class="line"></span><br><span class="line">import com.shiming.pen.old_code.ControllerPoint;</span><br><span class="line"></span><br><span class="line">import static com.shiming.pen.new_code.IPenConfig.STEPFACTOR;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @version v1.0 create at 2017/10/17</span><br><span class="line"> * @des 钢笔</span><br><span class="line"> */</span><br><span class="line">public class SteelPen extends BasePenExtend &#123;</span><br><span class="line"></span><br><span class="line">    public SteelPen(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void drawNeetToDo(Canvas canvas) &#123;</span><br><span class="line">        for (int i = 1; i &lt; mHWPointList.size(); i++) &#123;</span><br><span class="line">            ControllerPoint point = mHWPointList.get(i);</span><br><span class="line">            drawToPoint(canvas, point, mPaint);</span><br><span class="line">            mCurPoint = point;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void moveNeetToDo(double curDis) &#123;</span><br><span class="line">        int steps = 1 + (int) curDis / STEPFACTOR;</span><br><span class="line">        double step = 1.0 / steps;</span><br><span class="line">        for (double t = 0; t &lt; 1.0; t += step) &#123;</span><br><span class="line">            ControllerPoint point = mBezier.getPoint(t);</span><br><span class="line">            mHWPointList.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void doNeetToDo(Canvas canvas, ControllerPoint point, Paint paint) &#123;</span><br><span class="line">        drawLine(canvas, mCurPoint.x, mCurPoint.y, mCurPoint.width, point.x,</span><br><span class="line">                point.y, point.width, paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 其实这里才是关键的地方，通过画布画椭圆，每一个点都是一个椭圆，这个椭圆的所有细节，逐渐构建出一个完美的笔尖</span><br><span class="line">     * 和笔锋的效果,我觉得在这里需要大量的测试，其实就对低端手机进行排查，看我们绘制的笔的宽度是多少，绘制多少个椭圆</span><br><span class="line">     * 然后在低端手机上不会那么卡，当然你哪一个N年前的手机给我，那也的卡，只不过需要适中的范围里面</span><br><span class="line">     *</span><br><span class="line">     * @param canvas</span><br><span class="line">     * @param x0</span><br><span class="line">     * @param y0</span><br><span class="line">     * @param w0</span><br><span class="line">     * @param x1</span><br><span class="line">     * @param y1</span><br><span class="line">     * @param w1</span><br><span class="line">     * @param paint</span><br><span class="line">     */</span><br><span class="line">    private void drawLine(Canvas canvas, double x0, double y0, double w0, double x1, double y1, double w1, Paint paint) &#123;</span><br><span class="line">        //求两个数字的平方根 x的平方+y的平方在开方记得X的平方+y的平方=1，这就是一个园</span><br><span class="line">        double curDis = Math.hypot(x0 - x1, y0 - y1);</span><br><span class="line">        int steps = 1;</span><br><span class="line">        if (paint.getStrokeWidth() &lt; 6) &#123;</span><br><span class="line">            steps = 1 + (int) (curDis / 2);</span><br><span class="line">        &#125; else if (paint.getStrokeWidth() &gt; 60) &#123;</span><br><span class="line">            steps = 1 + (int) (curDis / 4);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            steps = 1 + (int) (curDis / 3);</span><br><span class="line">        &#125;</span><br><span class="line">        double deltaX = (x1 - x0) / steps;</span><br><span class="line">        double deltaY = (y1 - y0) / steps;</span><br><span class="line">        double deltaW = (w1 - w0) / steps;</span><br><span class="line">        double x = x0;</span><br><span class="line">        double y = y0;</span><br><span class="line">        double w = w0;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; steps; i++) &#123;</span><br><span class="line">            //都是用于表示坐标系中的一块矩形区域，并可以对其做一些简单操作</span><br><span class="line">            //精度不一样。Rect是使用int类型作为数值，RectF是使用float类型作为数值。</span><br><span class="line">            //            Rect rect = new Rect();</span><br><span class="line">            RectF oval = new RectF();</span><br><span class="line">            oval.set((float) (x - w / 4.0f), (float) (y - w / 2.0f), (float) (x + w / 4.0f), (float) (y + w / 2.0f));</span><br><span class="line">            //            oval.set((float)(x+w/4.0f), (float)(y+w/4.0f), (float)(x-w/4.0f), (float)(y-w/4.0f));</span><br><span class="line">            //最基本的实现，通过点控制线，绘制椭圆</span><br><span class="line">            canvas.drawOval(oval, paint);</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">            w += deltaW;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##最后说明几点：</p><p>####1、当一直处于onDown事件的时候，就是按着屏幕不动的时候，最后绘制的关键方法也一直在走，消耗内存，需要优化</p><p>####2、绘制水彩笔的时候：这里由于在设置笔的透明度，会导致整个线，或者说整个画布的的颜透明度随着整个笔的透明度而变化， 所以在这里考虑是不是说，绘制毛笔的时候，每次都给它new 一个paint ，但是这里我还没有找到更好的办法，也需要优化</p><p>####3、关于扩展性的问题，目前这个Demo仅提供了三种的功能，后续会加上返回上一步，设置笔的颜色和宽度，在手指抬起来自动生成一张bitmap，设置画布等功能</p><p>#Git地址，欢迎点赞，欢迎提问，谢谢：<a href="https://github.com/Shimingli/WritingPen" target="_blank" rel="noopener">https://github.com/Shimingli/WritingPen</a></p>]]></content>
      
      
        <tags>
            
            <tag> 安卓画笔笔锋的实现探索（二） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自己实现Jni，生成so库，实现高效率的高斯模糊效果</title>
      <link href="/2017/09/26/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0Jni%EF%BC%8C%E7%94%9F%E6%88%90so%E5%BA%93%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/"/>
      <url>/2017/09/26/%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0Jni%EF%BC%8C%E7%94%9F%E6%88%90so%E5%BA%93%EF%BC%8C%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E7%8E%87%E7%9A%84%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h2 id="看效果"><a href="#看效果" class="headerlink" title="看效果"></a>看效果</h2><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ac94f6a250b7ab80.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170927142832.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-c1a17ae6f1d16d03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170927142827.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-297cec9fdf894877.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170927142824.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-e81127e1886efb12.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170927142820.jpg"><br><a id="more"></a></p><p>##为什么要做，因为在实现模糊图上，当radios过大的话不同手机设备上可能会导致OutOfMemoryError,高斯模糊在安卓上实现的算法，一般的手机还不能够完成，所以在想能不能把实现模糊图的过程让jni来玩成，通过自己找些开源的算法，然后生成自己需要的so库，这就是写这个Demo的原因</p><p>####个人封装的Glide框架，在实现很模糊的效果上，在锤子手机渲染不出来，因为计算的次数太多了，这是代码的地址：<a href="http://www.jianshu.com/p/9080483bac91" target="_blank" rel="noopener">http://www.jianshu.com/p/9080483bac91</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br></pre></td><td class="code"><pre><span class="line">//本地图片，模糊处理</span><br><span class="line">        ImageLoader.getInstance().displayImageInResource(this, R.mipmap.test, mImageView_5, new BlurBitmapTransformation(this, 200));</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     * 当设置过大的radius 容易内存溢出</span><br><span class="line">     * at iamgeloader.client.tranform.BlurBitmapTransformation.blur(BlurBitmapTransformation.java:80)</span><br><span class="line">     * @param source</span><br><span class="line">     * @param radius</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    private Bitmap blur(Bitmap source, int radius) &#123;</span><br><span class="line">        Bitmap bitmap = source.copy(source.getConfig(), true);</span><br><span class="line">        int w = source.getWidth();</span><br><span class="line">        int h = source.getHeight();</span><br><span class="line">        int[] pix = new int[w * h];</span><br><span class="line">//        像素颜色写入位图</span><br><span class="line">//        要跳过的像素[ [] ]中的条目数</span><br><span class="line">//*行（必须是=位图的宽度）。</span><br><span class="line">//        从每行读取的像素数</span><br><span class="line">//        要读取的行数。</span><br><span class="line">        bitmap.getPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="line"></span><br><span class="line">        int wm = w - 1;</span><br><span class="line">        int hm = h - 1;</span><br><span class="line">        int wh = w * h;</span><br><span class="line">        int div = radius + radius + 1;</span><br><span class="line"></span><br><span class="line">        int r[] = new int[wh];</span><br><span class="line">        int g[] = new int[wh];</span><br><span class="line">        int b[] = new int[wh];</span><br><span class="line">        int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;</span><br><span class="line">        int vmin[] = new int[Math.max(w, h)];</span><br><span class="line"></span><br><span class="line">        int divsum = (div + 1) &gt;&gt; 1;</span><br><span class="line">        divsum *= divsum;</span><br><span class="line">        int dv[] = new int[256 * divsum];</span><br><span class="line">        for (i = 0; i &lt; 256 * divsum; i++) &#123;</span><br><span class="line">            dv[i] = (i / divsum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        yw = yi = 0;</span><br><span class="line"></span><br><span class="line">        int[][] stack = new int[div][3];</span><br><span class="line">        int stackPointer;</span><br><span class="line">        int stackStart;</span><br><span class="line">        int[] sir;</span><br><span class="line">        int rbs;</span><br><span class="line">        int r1 = radius + 1;</span><br><span class="line">        int routSum, goutSum, boutSum;</span><br><span class="line">        int rinSum, ginSum, binSum;</span><br><span class="line"></span><br><span class="line">        for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">            rinSum = ginSum = binSum = routSum = goutSum = boutSum = rsum = gsum = bsum = 0;</span><br><span class="line">            for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">                p = pix[yi + Math.min(wm, Math.max(i, 0))];</span><br><span class="line">                sir = stack[i + radius];</span><br><span class="line">//    12&amp;5 的值是多少？答：12转成二进制数是1100（前四位省略了），</span><br><span class="line">// 5转成二进制数是0101，则运算后的结果为0100即4  这是两侧为数值时；</span><br><span class="line">                sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">                sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">                sir[2] = (p &amp; 0x0000ff);</span><br><span class="line">                rbs = r1 - Math.abs(i);</span><br><span class="line">                rsum += sir[0] * rbs;</span><br><span class="line">                gsum += sir[1] * rbs;</span><br><span class="line">                bsum += sir[2] * rbs;</span><br><span class="line">                if (i &gt; 0) &#123;</span><br><span class="line">                    rinSum += sir[0];</span><br><span class="line">                    ginSum += sir[1];</span><br><span class="line">                    binSum += sir[2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    routSum += sir[0];</span><br><span class="line">                    goutSum += sir[1];</span><br><span class="line">                    boutSum += sir[2];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stackPointer = radius;</span><br><span class="line"></span><br><span class="line">            for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line"></span><br><span class="line">                r[yi] = dv[rsum];</span><br><span class="line">                g[yi] = dv[gsum];</span><br><span class="line">                b[yi] = dv[bsum];</span><br><span class="line"></span><br><span class="line">                rsum -= routSum;</span><br><span class="line">                gsum -= goutSum;</span><br><span class="line">                bsum -= boutSum;</span><br><span class="line"></span><br><span class="line">                stackStart = stackPointer - radius + div;</span><br><span class="line">                sir = stack[stackStart % div];</span><br><span class="line"></span><br><span class="line">                routSum -= sir[0];</span><br><span class="line">                goutSum -= sir[1];</span><br><span class="line">                boutSum -= sir[2];</span><br><span class="line"></span><br><span class="line">                if (y == 0) &#123;</span><br><span class="line">                    vmin[x] = Math.min(x + radius + 1, wm);</span><br><span class="line">                &#125;</span><br><span class="line">                p = pix[yw + vmin[x]];</span><br><span class="line"></span><br><span class="line">                sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">                sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">                sir[2] = (p &amp; 0x0000ff);</span><br><span class="line"></span><br><span class="line">                rinSum += sir[0];</span><br><span class="line">                ginSum += sir[1];</span><br><span class="line">                binSum += sir[2];</span><br><span class="line"></span><br><span class="line">                rsum += rinSum;</span><br><span class="line">                gsum += ginSum;</span><br><span class="line">                bsum += binSum;</span><br><span class="line"></span><br><span class="line">                stackPointer = (stackPointer + 1) % div;</span><br><span class="line">                sir = stack[(stackPointer) % div];</span><br><span class="line"></span><br><span class="line">                routSum += sir[0];</span><br><span class="line">                goutSum += sir[1];</span><br><span class="line">                boutSum += sir[2];</span><br><span class="line"></span><br><span class="line">                rinSum -= sir[0];</span><br><span class="line">                ginSum -= sir[1];</span><br><span class="line">                binSum -= sir[2];</span><br><span class="line"></span><br><span class="line">                yi++;</span><br><span class="line">            &#125;</span><br><span class="line">            yw += w;</span><br><span class="line">        &#125;</span><br><span class="line">        for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line">            rinSum = ginSum = binSum = routSum = goutSum = boutSum = rsum = gsum = bsum = 0;</span><br><span class="line">            yp = -radius * w;</span><br><span class="line">            for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">                yi = Math.max(0, yp) + x;</span><br><span class="line"></span><br><span class="line">                sir = stack[i + radius];</span><br><span class="line"></span><br><span class="line">                sir[0] = r[yi];</span><br><span class="line">                sir[1] = g[yi];</span><br><span class="line">                sir[2] = b[yi];</span><br><span class="line"></span><br><span class="line">                rbs = r1 - Math.abs(i);</span><br><span class="line"></span><br><span class="line">                rsum += r[yi] * rbs;</span><br><span class="line">                gsum += g[yi] * rbs;</span><br><span class="line">                bsum += b[yi] * rbs;</span><br><span class="line"></span><br><span class="line">                if (i &gt; 0) &#123;</span><br><span class="line">                    rinSum += sir[0];</span><br><span class="line">                    ginSum += sir[1];</span><br><span class="line">                    binSum += sir[2];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    routSum += sir[0];</span><br><span class="line">                    goutSum += sir[1];</span><br><span class="line">                    boutSum += sir[2];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (i &lt; hm) &#123;</span><br><span class="line">                    yp += w;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            yi = x;</span><br><span class="line">            stackPointer = radius;</span><br><span class="line">            for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">                // Preserve alpha channel: ( 0xff000000 &amp; pix[yi] )</span><br><span class="line">                //在该位置点出现一个萌白的点</span><br><span class="line">                pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum];</span><br><span class="line"></span><br><span class="line">                rsum -= routSum;</span><br><span class="line">                gsum -= goutSum;</span><br><span class="line">                bsum -= boutSum;</span><br><span class="line"></span><br><span class="line">                stackStart = stackPointer - radius + div;</span><br><span class="line">                sir = stack[stackStart % div];</span><br><span class="line"></span><br><span class="line">                routSum -= sir[0];</span><br><span class="line">                goutSum -= sir[1];</span><br><span class="line">                boutSum -= sir[2];</span><br><span class="line"></span><br><span class="line">                if (x == 0) &#123;</span><br><span class="line">                    vmin[y] = Math.min(y + r1, hm) * w;</span><br><span class="line">                &#125;</span><br><span class="line">                p = x + vmin[y];</span><br><span class="line"></span><br><span class="line">                sir[0] = r[p];</span><br><span class="line">                sir[1] = g[p];</span><br><span class="line">                sir[2] = b[p];</span><br><span class="line"></span><br><span class="line">                rinSum += sir[0];</span><br><span class="line">                ginSum += sir[1];</span><br><span class="line">                binSum += sir[2];</span><br><span class="line"></span><br><span class="line">                rsum += rinSum;</span><br><span class="line">                gsum += ginSum;</span><br><span class="line">                bsum += binSum;</span><br><span class="line"></span><br><span class="line">                stackPointer = (stackPointer + 1) % div;</span><br><span class="line">                sir = stack[stackPointer];</span><br><span class="line"></span><br><span class="line">                routSum += sir[0];</span><br><span class="line">                goutSum += sir[1];</span><br><span class="line">                boutSum += sir[2];</span><br><span class="line"></span><br><span class="line">                rinSum -= sir[0];</span><br><span class="line">                ginSum -= sir[1];</span><br><span class="line">                binSum -= sir[2];</span><br><span class="line"></span><br><span class="line">                yi += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        bitmap.setPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="line"></span><br><span class="line">        return bitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>####创建.c文件，创建jni文件夹，这里我们是没有so库的，所以我们要通过androidStudio生成so库</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-74e5d05d6ef22bc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####配置ndk正确的方法<br><img src="http://upload-images.jianshu.io/upload_images/5363507-67165df6eb690eec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>这里是正确的配置地址</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-8aba48543758ea36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####Android.mk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LOCAL_PATH := $(call my-dir)</span><br><span class="line"></span><br><span class="line">include $(CLEAR_VARS)</span><br><span class="line">#编译生成的文件的类库叫什么名字</span><br><span class="line">LOCAL_MODULE    := ShimingImageBlur</span><br><span class="line">#要编译的c文件</span><br><span class="line">LOCAL_SRC_FILES := com_shiming_imageloader_jnitest_JniUtils.cpp</span><br><span class="line"></span><br><span class="line">include $(BUILD_SHARED_LIBRARY)</span><br></pre></td></tr></table></figure></p><p>####Application.mk<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#jni打包的C语言类库默认仅支持 arm架构，需要在jni目录下创建 Android.mk 文件添加如下代码可以支持x86架构</span><br><span class="line">#或者是 ：=all</span><br><span class="line">APP_ABI :=armeabi armeabi-v7a x86</span><br></pre></td></tr></table></figure></p><p>####com_shiming_imageloader_jnitest_JniUtils.cpp 这里必须要注意一个问题JniUtils使我们的java类全地址，一定要加上Java_在前面，要不然生成的so库,会找不到方法，直接报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;com_shiming_imageloader_jnitest_JniUtils.h&quot;</span><br><span class="line">#include &quot;ShimingImageBlur.c&quot;</span><br><span class="line">#include &lt;android/log.h&gt;</span><br><span class="line"></span><br><span class="line">//用c++实现的，方法名必须为本地方法的全类名改为下划线</span><br><span class="line">//第一个参数为java虚拟机的内存地址的二级指正，用于本地方法与java虚拟机在内存中的交互</span><br><span class="line">//第二个参数为一个java对象，即是那个对象调用了这个c的方法 ，</span><br><span class="line">//后面的参数就是我们java的方法参数</span><br><span class="line">JNIEXPORT void JNICALL Java_com_shiming_imageloader_jnitest_JniUtils_blurIntArray</span><br><span class="line">(JNIEnv *env, jclass obj, jintArray arrIn, jint w, jint h, jint r)</span><br><span class="line">&#123;</span><br><span class="line">jint *pix;</span><br><span class="line">pix = env-&gt;GetIntArrayElements(arrIn, 0);</span><br><span class="line">if (pix == NULL)</span><br><span class="line">return;</span><br><span class="line">//Start</span><br><span class="line">pix = StackBlur(pix, w, h, r);</span><br><span class="line">//End</span><br><span class="line">//int size = w * h;</span><br><span class="line">//jintArray result = env-&gt;NewIntArray(size);</span><br><span class="line">//env-&gt;SetIntArrayRegion(result, 0, size, pix);</span><br><span class="line">env-&gt;ReleaseIntArrayElements(arrIn, pix, 0);</span><br><span class="line">//return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####com_shiming_imageloader_jnitest_JniUtils.h 在这里也是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* DO NOT EDIT THIS FILE - it is machine generated */</span><br><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">/* Header for class com_shiming_imageloader_jni_JniUtils */</span><br><span class="line"></span><br><span class="line">#ifndef _Included_com_shiming_imageloader_jnitest_JniUtils</span><br><span class="line">#define _Included_com_shiming_imageloader_jnitest_JniUtils</span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">#endif</span><br><span class="line">/*</span><br><span class="line"> * Class:     Java_com_shiming_imageloader_jnitest_JniUtils</span><br><span class="line"> * Method:    blurIntArray</span><br><span class="line"> * Signature: ([IIII)V</span><br><span class="line"> * 可千万要加上 Java_的前缀 ，要不然找不到啊</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">JNIEXPORT void JNICALL Java_com_shiming_imageloader_jnitest_JniUtils_blurIntArray</span><br><span class="line">  (JNIEnv *, jclass, jintArray, jint, jint, jint);</span><br><span class="line"></span><br><span class="line">#ifdef __cplusplus</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p><p>####ShimingImageBlur.c 这里面的算法，是我参考了git上一个开源的项目的算法在git上搜索：ImageBlur即可，但是我用不到那么的方法，所以只需要这个，实现高斯模糊的，其实这个算法和上面的java实现的模糊效果有相同之处，但是我还不能说的太明白，见谅</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;malloc.h&gt;</span><br><span class="line"></span><br><span class="line">#define ABS(a) ((a)&lt;(0)?(-a):(a))</span><br><span class="line">#define MAX(a,b) ((a)&gt;(b)?(a):(b))</span><br><span class="line">#define MIN(a,b) ((a)&lt;(b)?(a):(b))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static int* StackBlur(int* pix, int w, int h, int radius) &#123;</span><br><span class="line">int wm = w - 1;</span><br><span class="line">int hm = h - 1;</span><br><span class="line">int wh = w * h;</span><br><span class="line">int div = radius + radius + 1;</span><br><span class="line">    // 指针</span><br><span class="line">int *r = (int *)malloc(wh * sizeof(int));</span><br><span class="line">int *g = (int *)malloc(wh * sizeof(int));</span><br><span class="line">int *b = (int *)malloc(wh * sizeof(int));</span><br><span class="line">int rsum, gsum, bsum, x, y, i, p, yp, yi, yw;</span><br><span class="line"></span><br><span class="line">int *vmin = (int *)malloc(MAX(w,h) * sizeof(int));</span><br><span class="line"></span><br><span class="line">int divsum = (div + 1) &gt;&gt; 1;</span><br><span class="line">divsum *= divsum;</span><br><span class="line">int *dv = (int *)malloc(256 * divsum * sizeof(int));</span><br><span class="line">for (i = 0; i &lt; 256 * divsum; i++) &#123;</span><br><span class="line">dv[i] = (i / divsum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">yw = yi = 0;</span><br><span class="line"></span><br><span class="line">int(*stack)[3] = (int(*)[3])malloc(div * 3 * sizeof(int));</span><br><span class="line">int stackpointer;</span><br><span class="line">int stackstart;</span><br><span class="line">int *sir;</span><br><span class="line">int rbs;</span><br><span class="line">int r1 = radius + 1;</span><br><span class="line">int routsum, goutsum, boutsum;</span><br><span class="line">int rinsum, ginsum, binsum;</span><br><span class="line"></span><br><span class="line">for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">p = pix[yi + (MIN(wm, MAX(i, 0)))];</span><br><span class="line">sir = stack[i + radius];</span><br><span class="line">sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">sir[2] = (p &amp; 0x0000ff);</span><br><span class="line"></span><br><span class="line">rbs = r1 - ABS(i);</span><br><span class="line">rsum += sir[0] * rbs;</span><br><span class="line">gsum += sir[1] * rbs;</span><br><span class="line">bsum += sir[2] * rbs;</span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">rinsum += sir[0];</span><br><span class="line">ginsum += sir[1];</span><br><span class="line">binsum += sir[2];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">routsum += sir[0];</span><br><span class="line">goutsum += sir[1];</span><br><span class="line">boutsum += sir[2];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">stackpointer = radius;</span><br><span class="line"></span><br><span class="line">for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line"></span><br><span class="line">r[yi] = dv[rsum];</span><br><span class="line">g[yi] = dv[gsum];</span><br><span class="line">b[yi] = dv[bsum];</span><br><span class="line"></span><br><span class="line">rsum -= routsum;</span><br><span class="line">gsum -= goutsum;</span><br><span class="line">bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">stackstart = stackpointer - radius + div;</span><br><span class="line">sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">routsum -= sir[0];</span><br><span class="line">goutsum -= sir[1];</span><br><span class="line">boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">if (y == 0) &#123;</span><br><span class="line">vmin[x] = MIN(x + radius + 1, wm);</span><br><span class="line">&#125;</span><br><span class="line">p = pix[yw + vmin[x]];</span><br><span class="line"></span><br><span class="line">sir[0] = (p &amp; 0xff0000) &gt;&gt; 16;</span><br><span class="line">sir[1] = (p &amp; 0x00ff00) &gt;&gt; 8;</span><br><span class="line">sir[2] = (p &amp; 0x0000ff);</span><br><span class="line"></span><br><span class="line">rinsum += sir[0];</span><br><span class="line">ginsum += sir[1];</span><br><span class="line">binsum += sir[2];</span><br><span class="line"></span><br><span class="line">rsum += rinsum;</span><br><span class="line">gsum += ginsum;</span><br><span class="line">bsum += binsum;</span><br><span class="line"></span><br><span class="line">stackpointer = (stackpointer + 1) % div;</span><br><span class="line">sir = stack[(stackpointer) % div];</span><br><span class="line"></span><br><span class="line">routsum += sir[0];</span><br><span class="line">goutsum += sir[1];</span><br><span class="line">boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">rinsum -= sir[0];</span><br><span class="line">ginsum -= sir[1];</span><br><span class="line">binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">yi++;</span><br><span class="line">&#125;</span><br><span class="line">yw += w;</span><br><span class="line">&#125;</span><br><span class="line">for (x = 0; x &lt; w; x++) &#123;</span><br><span class="line">rinsum = ginsum = binsum = routsum = goutsum = boutsum = rsum = gsum = bsum = 0;</span><br><span class="line">yp = -radius * w;</span><br><span class="line">for (i = -radius; i &lt;= radius; i++) &#123;</span><br><span class="line">yi = MAX(0, yp) + x;</span><br><span class="line"></span><br><span class="line">sir = stack[i + radius];</span><br><span class="line"></span><br><span class="line">sir[0] = r[yi];</span><br><span class="line">sir[1] = g[yi];</span><br><span class="line">sir[2] = b[yi];</span><br><span class="line"></span><br><span class="line">rbs = r1 - ABS(i);</span><br><span class="line"></span><br><span class="line">rsum += r[yi] * rbs;</span><br><span class="line">gsum += g[yi] * rbs;</span><br><span class="line">bsum += b[yi] * rbs;</span><br><span class="line"></span><br><span class="line">if (i &gt; 0) &#123;</span><br><span class="line">rinsum += sir[0];</span><br><span class="line">ginsum += sir[1];</span><br><span class="line">binsum += sir[2];</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">routsum += sir[0];</span><br><span class="line">goutsum += sir[1];</span><br><span class="line">boutsum += sir[2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (i &lt; hm) &#123;</span><br><span class="line">yp += w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">yi = x;</span><br><span class="line">stackpointer = radius;</span><br><span class="line">for (y = 0; y &lt; h; y++) &#123;</span><br><span class="line">// Preserve alpha channel: ( 0xff000000 &amp; pix[yi] )</span><br><span class="line">pix[yi] = (0xff000000 &amp; pix[yi]) | (dv[rsum] &lt;&lt; 16) | (dv[gsum] &lt;&lt; 8) | dv[bsum];</span><br><span class="line"></span><br><span class="line">rsum -= routsum;</span><br><span class="line">gsum -= goutsum;</span><br><span class="line">bsum -= boutsum;</span><br><span class="line"></span><br><span class="line">stackstart = stackpointer - radius + div;</span><br><span class="line">sir = stack[stackstart % div];</span><br><span class="line"></span><br><span class="line">routsum -= sir[0];</span><br><span class="line">goutsum -= sir[1];</span><br><span class="line">boutsum -= sir[2];</span><br><span class="line"></span><br><span class="line">if (x == 0) &#123;</span><br><span class="line">vmin[y] = MIN(y + r1, hm) * w;</span><br><span class="line">&#125;</span><br><span class="line">p = x + vmin[y];</span><br><span class="line"></span><br><span class="line">sir[0] = r[p];</span><br><span class="line">sir[1] = g[p];</span><br><span class="line">sir[2] = b[p];</span><br><span class="line"></span><br><span class="line">rinsum += sir[0];</span><br><span class="line">ginsum += sir[1];</span><br><span class="line">binsum += sir[2];</span><br><span class="line"></span><br><span class="line">rsum += rinsum;</span><br><span class="line">gsum += ginsum;</span><br><span class="line">bsum += binsum;</span><br><span class="line"></span><br><span class="line">stackpointer = (stackpointer + 1) % div;</span><br><span class="line">sir = stack[stackpointer];</span><br><span class="line"></span><br><span class="line">routsum += sir[0];</span><br><span class="line">goutsum += sir[1];</span><br><span class="line">boutsum += sir[2];</span><br><span class="line"></span><br><span class="line">rinsum -= sir[0];</span><br><span class="line">ginsum -= sir[1];</span><br><span class="line">binsum -= sir[2];</span><br><span class="line"></span><br><span class="line">yi += w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    //记得要释放掉</span><br><span class="line">free(r);</span><br><span class="line">free(g);</span><br><span class="line">free(b);</span><br><span class="line">free(vmin);</span><br><span class="line">free(dv);</span><br><span class="line">free(stack);</span><br><span class="line">return(pix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有个算法和这个有异曲同工之妙，作用是把bitmap扫描，把Color.TRANSPARENT排除掉生成了一张位于正中的bitmap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">private int mBackColor = Color.TRANSPARENT;</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">    * 逐行扫描 清楚边界空白。</span><br><span class="line">    *</span><br><span class="line">    * @param blank 边距留多少个像素</span><br><span class="line">    * @return tks github E-signature</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">   public Bitmap clearBlank(int blank) &#123;</span><br><span class="line">       if (mBitmap != null) &#123;</span><br><span class="line">           int HEIGHT = mBitmap.getHeight();</span><br><span class="line">           int WIDTH = mBitmap.getWidth();</span><br><span class="line">           int top = 0, left = 0, right = 0, bottom = 0;</span><br><span class="line">           int[] pixs = new int[WIDTH];</span><br><span class="line">           boolean isStop;</span><br><span class="line">           for (int y = 0; y &lt; HEIGHT; y++) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, WIDTH, 0, y, WIDTH, 1);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line"></span><br><span class="line">                       top = y;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int y = HEIGHT - 1; y &gt;= 0; y--) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, WIDTH, 0, y, WIDTH, 1);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       bottom = y;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           pixs = new int[HEIGHT];</span><br><span class="line">           for (int x = 0; x &lt; WIDTH; x++) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, 1, x, 0, 1, HEIGHT);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       left = x;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for (int x = WIDTH - 1; x &gt; 0; x--) &#123;</span><br><span class="line">               mBitmap.getPixels(pixs, 0, 1, x, 0, 1, HEIGHT);</span><br><span class="line">               isStop = false;</span><br><span class="line">               for (int pix : pixs) &#123;</span><br><span class="line">                   if (pix != mBackColor) &#123;</span><br><span class="line">                       right = x;</span><br><span class="line">                       isStop = true;</span><br><span class="line">                       break;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (isStop) &#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           if (blank &lt; 0) &#123;</span><br><span class="line">               blank = 0;</span><br><span class="line">           &#125;</span><br><span class="line">           left = left - blank &gt; 0 ? left - blank : 0;</span><br><span class="line">           top = top - blank &gt; 0 ? top - blank : 0;</span><br><span class="line">           right = right + blank &gt; WIDTH - 1 ? WIDTH - 1 : right + blank;</span><br><span class="line">           bottom = bottom + blank &gt; HEIGHT - 1 ? HEIGHT - 1 : bottom + blank;</span><br><span class="line">           return Bitmap.createBitmap(mBitmap, left, top, right - left, bottom - top);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return null;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-fd1f56e0d351912f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####JniUtils类,加载本地方法，本地方法的方法名要和jni中一样,引用so库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 参照：MediaPlayer的写法</span><br><span class="line">      static &#123;</span><br><span class="line">      System.loadLibrary(&quot;media_jni&quot;);</span><br><span class="line">      native_init();</span><br><span class="line">       &#125;</span><br><span class="line">     */</span><br><span class="line">    static &#123;</span><br><span class="line">        /**</span><br><span class="line">         * #编译生成的文件的类库叫什么名字</span><br><span class="line">         LOCAL_MODULE    := ShimingImageBlur</span><br><span class="line">         必须和Android.mk中的一样，生成的so库虽然会加上libShimingImageBlur.so 但是调用得到</span><br><span class="line">         */</span><br><span class="line">        System.loadLibrary(&quot;ShimingImageBlur&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>####设置图片的view模糊 ，使用getViewTreeObserver(）监听在绘画完成前，获取缓存的bitmap<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// Register a callback to be invoked when the view tree is about to be drawn</span><br><span class="line">       //翻译注册一个回调，view将要drawn，意思还没有drawn上去</span><br><span class="line">       view.getViewTreeObserver().addOnPreDrawListener(new ViewTreeObserver.OnPreDrawListener() &#123;</span><br><span class="line">           /**</span><br><span class="line">            * 再绘图前加上</span><br><span class="line">            * @return</span><br><span class="line">            */</span><br><span class="line">           @Override</span><br><span class="line">           public boolean onPreDraw() &#123;</span><br><span class="line">               view.getViewTreeObserver().removeOnPreDrawListener(this);</span><br><span class="line">               //buildDrawingCache(false);</span><br><span class="line">               //如果绘制无效，则强制构建绘图缓存，</span><br><span class="line">               view.buildDrawingCache();</span><br><span class="line"></span><br><span class="line">               Bitmap bmp = view.getDrawingCache();</span><br><span class="line">               blur(bmp, view,flag);</span><br><span class="line">               //通常cache会占用一定量的内存，所以必须销毁</span><br><span class="line">               view.destroyDrawingCache();</span><br><span class="line">               //返回 true 继续绘制，返回false取消。 如果返回为false的，页面就不会绘制了</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p>####下一步进行的方法吗，在这里有个问题，      ((ImageView)view).setImageDrawable(blurDrawable); 这里有个问题，当我们调用次数过多的时候，这个方法显示不出来图片， 我还不知道为什么？todo 源于知乎上的一句话：简单地理解为 Bitmap 储存的是 像素信息，Drawable 储存的是 对 Canvas 的一系列操作。而 BitmapDrawable 储存的是「把 Bitmap 渲染到 Canvas 上」这个操作，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 模糊图片</span><br><span class="line">   *  @param blurFactor 模糊因子</span><br><span class="line">   * @param blurRadius 模糊半径</span><br><span class="line">   * @param bitmap     图片</span><br><span class="line">   * @param view       view</span><br><span class="line">   * @param flag 是否需要jni里面的算法 </span><br><span class="line">   */</span><br><span class="line">  public static void blur(float blurFactor, float blurRadius, Bitmap bitmap, final View view, boolean flag) &#123;</span><br><span class="line"></span><br><span class="line">      Bitmap overlay = Bitmap.createBitmap((int) (view.getMeasuredWidth() / blurFactor),</span><br><span class="line">              (int) (view.getMeasuredHeight() / blurFactor), Bitmap.Config.ARGB_8888);</span><br><span class="line">       overlay.getHeight();</span><br><span class="line">      overlay.getWidth();</span><br><span class="line">      Canvas canvas = new Canvas(overlay);</span><br><span class="line">      //如果我们需要放大1倍，即 scale(2, 2);缩放的中心点默认也是canvas的左上角，所以先要进行坐标平移，才能去缩放</span><br><span class="line">      //平移，将画布的坐标原点向左右方向移动x，向上下方向移动y.canvas的默认位置是在（0,0）</span><br><span class="line">      canvas.translate(-view.getLeft() / blurFactor, -view.getTop() / blurFactor);</span><br><span class="line">      canvas.scale(1 / blurFactor, 1 / blurFactor);</span><br><span class="line">      Paint paint = new Paint();</span><br><span class="line">      //抗锯齿</span><br><span class="line">      paint.setFlags(Paint.FILTER_BITMAP_FLAG);</span><br><span class="line">      canvas.drawBitmap(bitmap, 0, 0, paint);</span><br><span class="line">      //这里的overlay已经包含了信息</span><br><span class="line">      //是否需要jni的计算</span><br><span class="line">      if (flag) &#123;</span><br><span class="line">          overlay = doBlurJniArray(overlay, (int) blurRadius, true);</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapDrawable blurDrawable = new BitmapDrawable(MyApp.getInstance().getApplicationContext()</span><br><span class="line">              .getResources(), overlay);</span><br><span class="line">      if (view instanceof ImageView) &#123;</span><br><span class="line">          ((ImageView)view).setImageDrawable(blurDrawable);</span><br><span class="line">          System.out.println(&quot;shiming  blurDrawable&quot; +blurDrawable);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          view.setBackgroundDrawable(blurDrawable);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####核心的方法对pix进行操作，JniUtils.blurIntArray(pix, w, h, radius); 在通过   bitmap.setPixels(pix, 0, w, 0, 0, w, h); 和java实现所用的方法一样，但是性能上提升的不是一点两点，很流畅,而且在显示的效果上有很明显的不一样，如上图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  *</span><br><span class="line">  * @param sentBitmap</span><br><span class="line">  * @param radius</span><br><span class="line">  * @param canReuseInBitmap</span><br><span class="line">  * @return</span><br><span class="line">  *</span><br><span class="line"> 参数 :http://ranlic.iteye.com/blog/1313735</span><br><span class="line"> pixels      接收位图颜色值的数组</span><br><span class="line"> offset      写入到pixels[]中的第一个像素索引值</span><br><span class="line"> stride      pixels[]中的行间距个数值(必须大于等于位图宽度)。可以为负数</span><br><span class="line"> x          　从位图中读取的第一个像素的x坐标值。</span><br><span class="line"> y           从位图中读取的第一个像素的y坐标值</span><br><span class="line"> width    　　从每一行中读取的像素宽度</span><br><span class="line"> height 　　　读取的行数</span><br><span class="line">         异常</span><br><span class="line"> IilegalArgumentExcepiton       如果x，y，width，height越界或stride的绝对值小于位图宽度时将被抛出。</span><br><span class="line"> ArrayIndexOutOfBoundsException          如果像素数组太小而无法接收指定书目的像素值时将被抛出。</span><br><span class="line"> */</span><br><span class="line"> private static Bitmap doBlurJniArray(Bitmap sentBitmap, int radius, boolean canReuseInBitmap) &#123;</span><br><span class="line">     Bitmap bitmap;</span><br><span class="line">     if (canReuseInBitmap) &#123;</span><br><span class="line">         bitmap = sentBitmap;</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         bitmap = sentBitmap.copy(sentBitmap.getConfig(), true);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     if (radius &lt; 1) &#123;</span><br><span class="line">         return (null);</span><br><span class="line">     &#125;</span><br><span class="line">     int w = bitmap.getWidth();</span><br><span class="line">     int h = bitmap.getHeight();</span><br><span class="line">     int[] pix = new int[w * h];</span><br><span class="line">     bitmap.getPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="line">     //pix数组，所有的关键的逻辑都是这个pix的操作，这里我们去交给了so.库去处理了，所以这里才是关键</span><br><span class="line">     JniUtils.blurIntArray(pix, w, h, radius);</span><br><span class="line">     bitmap.setPixels(pix, 0, w, 0, 0, w, h);</span><br><span class="line">     return (bitmap);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>####如何生成so库,在build.gradle</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-5dde711d043f48ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        //ndk编译生成.so文件</span><br><span class="line">        // 只要是第一次生成了so库的文件，那么以后就不用生成这个文件，记住一定要记住，如果需要生成so文件</span><br><span class="line">        //需要把外面的目录的jni移动到和mian目录下和Java同级的目录下</span><br><span class="line">//        ndk &#123;</span><br><span class="line">//            moduleName &quot;ShimingImageBlur&quot;         //生成的so名字</span><br><span class="line">//            abiFilters &quot;armeabi&quot;, &quot;armeabi-v7a&quot;, &quot;x86&quot;  //输出指定三种abi体系结构下的so库。</span><br><span class="line">//        &#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/5363507-6e0e9527b313631a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####这里才是so库生成正确的目录地址，一定是生成完成了，然后复制出来放在libs目录下</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-a524e10e9812c107.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-45513de0f48af443.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>##这个就生成了自己需要的so文件了，然后就可以使用了，哈哈，建议可以实际操作下，然后学点c，就可以实现jni了，哈哈，我吹牛了！</p><p>##git：<a href="https://github.com/Shimingli/ImageLoader" target="_blank" rel="noopener">https://github.com/Shimingli/ImageLoader</a></p>]]></content>
      
      
        <tags>
            
            <tag> Jni </tag>
            
            <tag> So库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义卡片效果的ViewGroup</title>
      <link href="/2017/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%A1%E7%89%87%E6%95%88%E6%9E%9C%E7%9A%84ViewGroup/"/>
      <url>/2017/09/23/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%A1%E7%89%87%E6%95%88%E6%9E%9C%E7%9A%84ViewGroup/</url>
      <content type="html"><![CDATA[<h2 id="不逼逼，看效果！两边有点露出来的效果，比如腾讯视频App的上方的效果，都是轻量级的控件，请勿见怪，总体时间花费大约9个小时，其中找Bug找了3个小时，哈哈！"><a href="#不逼逼，看效果！两边有点露出来的效果，比如腾讯视频App的上方的效果，都是轻量级的控件，请勿见怪，总体时间花费大约9个小时，其中找Bug找了3个小时，哈哈！" class="headerlink" title="不逼逼，看效果！两边有点露出来的效果，比如腾讯视频App的上方的效果，都是轻量级的控件，请勿见怪，总体时间花费大约9个小时，其中找Bug找了3个小时，哈哈！"></a>不逼逼，看效果！两边有点露出来的效果，比如腾讯视频App的上方的效果，都是轻量级的控件，请勿见怪，总体时间花费大约9个小时，其中找Bug找了3个小时，哈哈！</h2><p><img src="http://upload-images.jianshu.io/upload_images/5363507-8ad5b63a07dad73f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170904213432.jpg"><br><a id="more"></a></p><ul><li>第一个效果是正常的滑动情况<br><img src="http://upload-images.jianshu.io/upload_images/5363507-ce7c0fa257533994.gif?imageMogr2/auto-orient/strip" alt="xiao.gif"></li><li>第二个效果是禁止滑动情况，同时呢，有一个回弹的效果，四川话讲这个很巴适<br><img src="http://upload-images.jianshu.io/upload_images/5363507-fd86e9fec575c1a4.gif?imageMogr2/auto-orient/strip" alt="xiao.gif"><br>##分享两个东西<ul><li>今天发现的一个Android UI 开发效率的 UI 库：<a href="https://github.com/QMUI/QMUI_Android" target="_blank" rel="noopener">https://github.com/QMUI/QMUI_Android</a>   </li><li>这个我都不好意思分享，嘿嘿，周天就做这个，做完了发现根本没有什么东西可以分享，所以就写了现在这个博客，等我以后研究下hexo，才来更新<br><a href="https://shimingli.github.io/" target="_blank" rel="noopener">https://shimingli.github.io/</a></li></ul></li></ul><p>##写在前面的话：如果我手写慢一点，多看看一下api，我就不会把两个api写错了，由于手滑写错了，导致我这篇博客现在才来写，兴奋感都快磨完了。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-dfa1376367aa27eb.gif?imageMogr2/auto-orient/strip" alt="72F75ABC3304DD06A39EB5A18180F6CE.gif"></p><ul><li>这辈子我都不会忘记这个值了，getScaledTouchSlop()是一个距离，表示滑动的时候，手的移动要大于这个距离才开始移动控件。viewpager就是用这个距离来判断用户是否翻页，只不过呢<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfiguration.get(mContext).getScaledTouchSlop()</span><br></pre></td></tr></table></figure></li></ul><hr><p>原理如下： mTouchSlop = configuration.getScaledPagingTouchSlop();就是这个值，但是你可能会说有毛的的关系啊，别急<br><img src="http://upload-images.jianshu.io/upload_images/5363507-fa2d83618ec0929f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>往ViewConfiguration类看记住这个值<br><img src="http://upload-images.jianshu.io/upload_images/5363507-55e3fe09f76552f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-3f0eed8d739c16fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>看这个值mTouchSlop，对吧只不过在ViewPager判断是否需要移动的时候，这个距离是*2。</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-df28f20936b2d39c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h2 id="由于我这里需要更高的精度，所以获取了这个值getScaledTouchSlop"><a href="#由于我这里需要更高的精度，所以获取了这个值getScaledTouchSlop" class="headerlink" title="由于我这里需要更高的精度，所以获取了这个值getScaledTouchSlop()"></a>由于我这里需要更高的精度，所以获取了这个值getScaledTouchSlop()</h2><ul><li>可千万不要拿到getScaledDoubleTapSlop()这个值了啊！<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//第一次触摸和第二次触摸之间的距离,Distance in pixels between the first touch and second touch</span><br><span class="line">   ViewConfiguration.get(mContext).getScaledDoubleTapSlop();</span><br></pre></td></tr></table></figure></li></ul><p>##继承ViewGroup,重写构造方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CardViewPager extends ViewGroup&#123;</span><br><span class="line"></span><br><span class="line"> public CardViewPager(Context context) &#123;</span><br><span class="line">        this(context,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CardViewPager(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        init(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##初始化init<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   private void init(Context context) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        //滑动的对象</span><br><span class="line">        mScroller = new Scroller(mContext);</span><br><span class="line">        //getScaledTouchSlop是一个距离，表示滑动的时候，手的移动要大于这个距离才开始移动控件。</span><br><span class="line">        // 如果小于这个距离就不触发移动控件，如viewpager就是用这个距离来判断用户是否翻页</span><br><span class="line">//        mScaledDoubleTapSlop = ViewConfiguration.get(mContext).getScaledTouchSlop();</span><br><span class="line">        mScaledDoubleTapSlop = ViewConfiguration.get(mContext).getScaledPagingTouchSlop();</span><br><span class="line">        //第一次触摸和第二次触摸之间的距离,Distance in pixels between the first touch and second touch</span><br><span class="line">        ViewConfiguration.get(mContext).getScaledDoubleTapSlop();</span><br><span class="line">        FIRST_width = dp2px(mContext, 10);</span><br><span class="line">        TWO_GAP_WIDTH = FIRST_width * 2;</span><br><span class="line">        THREE_GAP_WIDTH = FIRST_width * 3;</span><br><span class="line">        FOUR_GAP_WIDTH = FIRST_width * 4;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>##onMeasure,重写测量这里记住widthMeasureSpec、heightMeasureSpec是一个32位的int值，其中高两位是物理模式，低的30位才是控件的宽度和高度的信息。<br>  MeasureSpec.EXACTLY：父视图希望子视图的大小应该是specSize中指定的。<br> MeasureSpec.AT_MOST：子视图的大小最多是specSize中指定的值，也就是说不建议子视图的大小超过specSize中给定的值。<br> MeasureSpec.UNSPECIFIED：我们可以随意指定视图的大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">       //这才是真正的宽度和高度</span><br><span class="line">       int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">       int heighSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">       //设置测量的大小</span><br><span class="line">       setMeasuredDimension(widthSize,heighSize);</span><br><span class="line">       //测量孩子的大小</span><br><span class="line">       mChildCount = getChildCount();</span><br><span class="line">       for (int i=0;i&lt;mChildCount;i++)&#123;</span><br><span class="line">           //这里需要把模式也传入进去</span><br><span class="line">           getChildAt(i).measure(widthMeasureSpec,heightMeasureSpec);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##onLayout重新布局:将孩子的view布局，这里横向的布局，一个字View接着右边,这是设计之初的方法，自己先明白到底是怎么样布局，就好像我明白的方式，是个伟大的ui妹子说，看这个app，就是这样，哈哈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * @param changed</span><br><span class="line">     * @param l 左上角的left</span><br><span class="line">     * @param t top</span><br><span class="line">     * @param r  右下角right</span><br><span class="line">     * @param b bottom值</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void onLayout(boolean changed, int l, int t, int r, int b) &#123;</span><br><span class="line">        View child;</span><br><span class="line">        int widthLeft=0;</span><br><span class="line">        for (int i=0;i&lt;mChildCount;i++)&#123;</span><br><span class="line">            child = getChildAt(i);</span><br><span class="line">            //得到第一个孩子的宽度，两边都减去了两个参数，记住是这个4倍值</span><br><span class="line">            int measuredWidth = child.getMeasuredWidth() - FOUR_GAP_WIDTH;</span><br><span class="line">            int measuredHeight = child.getMeasuredHeight();</span><br><span class="line">            //是第一个孩子</span><br><span class="line">            if (i==0)&#123;</span><br><span class="line">                child.layout(widthLeft+TWO_GAP_WIDTH,0,widthLeft+TWO_GAP_WIDTH+measuredWidth,measuredHeight);</span><br><span class="line">                //改变向左的值</span><br><span class="line">                widthLeft+=measuredWidth+THREE_GAP_WIDTH;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                child.layout(widthLeft, 0, widthLeft + measuredWidth, measuredHeight);</span><br><span class="line">                widthLeft += measuredWidth + FIRST_width;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>####效果虽然看了，但是真正理解的layout的话，还需明白其中的原理，这里我不讲了的太细，献上美图一张，嗦嘎，原理就是，不是每一个屏幕都在装着一个我们的卡片，我们每次移动的时候，也不是移动一个屏幕，而是通过运算的方式，移动到恰好能够看到两边10dp的值，这里的要转成像素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp2px(mContext, 10);</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-af8c440ead2eccfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>关于像素px我还想说说: context.getResources().getDisplayMetrics().density;density显示器的逻辑密度，这是【独立的像素密度单位（首先明白dp是个单位）】的一个缩放因子，在屏幕密度大约为160dpi的屏幕上，一个dp等于一个px,这个提供了系统显示器的一个基线. 例如：屏幕为240<em>320的手机屏幕，其尺寸为 1.5”</em>2”  也就是1.5英寸乘2英寸的屏幕 它的dpi（屏幕像素密度，也就是每英寸的像素数，dpi是dot per inch的缩写）大约就为160dpi， 所以在这个手机上dp和px的长度（可以说是长度，最起码从你的视觉感官上来说是这样的）是相等的。 因此在一个屏幕密度为160dpi的手机屏幕上density的值为1，而在120dpi的手机上为0.75等等.例如：一个240<em>320的屏幕尽管他的屏幕尺寸为1.8”</em>1.3”,（我算了下这个的dpi大约为180dpi多点）但是它的density还是1(也就是说取了近似值) 然而，如果屏幕分辨率增加到320<em>480 但是屏幕尺寸仍然保持1.5”</em>2” 的时候（和最开始的例子比较）<br> 这个手机的density将会增加（可能会增加到1.5）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static int dp2px(Context context, float dpValue) &#123;</span><br><span class="line">       ///这个得到的不应该叫做密度，应该是密度的一个比例。不是真实的屏幕密度，</span><br><span class="line">       /// 而是相对于某个值的屏幕密度。也可以说是相对密度</span><br><span class="line">       final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">       return (int) (dpValue * scale + 0.5f);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##拦截事件:当大于了需要移动控件的距离的话，就需要把这个事件拦截自己处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public boolean onInterceptTouchEvent(MotionEvent ev) &#123;</span><br><span class="line">       switch (ev.getAction())&#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               int x = (int) ev.getX();</span><br><span class="line">               mLastMotionX = x ;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">               x= (int) ev.getX();</span><br><span class="line">               //滑动的距离</span><br><span class="line">               int delX = mLastMotionX - x;</span><br><span class="line">               //如果说距离大于这个距离的话，就需要滚动了，拦截事件</span><br><span class="line">               if (Math.abs(delX)&gt;mScaledDoubleTapSlop)&#123;</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return super.onInterceptTouchEvent(ev);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##处理事件:在down的事件一定需要拦截，才能记录坐标<br>  返回值为True，代表拦截这次事件，直接进入到ViewGroup的onTouchEvent中，就不会进入到View的onTouchEvent了<br>  返回值为False，代表不拦截这次事件，不进入到ViewGroup的onTouchEvent中，直接进入到View的onTouchEvent中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       //如果没有孩子的话，不需要拦截</span><br><span class="line">       if (getChildCount()==0)&#123;</span><br><span class="line">           return false;</span><br><span class="line">       &#125;</span><br><span class="line">       //监听滑动的速度</span><br><span class="line">       obtainTracker(event);</span><br><span class="line">       switch (event.getAction())&#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               if (!mScroller.isFinished())&#123;</span><br><span class="line">                   //停止动画</span><br><span class="line">                   mScroller.abortAnimation();</span><br><span class="line">               &#125;</span><br><span class="line">               int x = (int) event.getX();</span><br><span class="line">               mLastMotionX=x;</span><br><span class="line">               //不管怎么怎么样这个事件都必须拦截</span><br><span class="line">               return true;</span><br><span class="line"></span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">                x = (int) event.getX();</span><br><span class="line">               int desX = mLastMotionX - x;</span><br><span class="line">               //这个距离大于了屏幕的10/1的话，就给他赋值10/1</span><br><span class="line">               if (!isAllowScroll&amp;&amp;desX&gt;getWidth()/10)&#123;</span><br><span class="line">                   desX=getWidth()/10;</span><br><span class="line">                   //如果设置了不可以滑动的，这个flag需要到up事件单独处理</span><br><span class="line">                   mCanScrolled = true;</span><br><span class="line">               &#125;</span><br><span class="line">               //只需计算x的距离</span><br><span class="line">               mVelocityTracker.computeCurrentVelocity(1000,ViewConfiguration.getMaximumFlingVelocity());</span><br><span class="line">               mXVelocity = (int) mVelocityTracker.getXVelocity();</span><br><span class="line">               //如果说距离滑动太小，或者是只有一个屏幕的话，就不往下去做操作了</span><br><span class="line">               if (Math.abs(desX)&lt;mScaledDoubleTapSlop||(desX&gt;=0&amp;&amp;</span><br><span class="line">                       mCurScreen==mChildCount-1)||(desX&lt;=0&amp;&amp;mCurScreen==0))&#123;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               //能到这里来的话，就必须往手指方向慢慢滚动了</span><br><span class="line">               scrollTo(getChildAt(mCurScreen).getLeft()+desX,0);</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_UP:</span><br><span class="line">               //mXVelocity为正数的话，这个是往left滚</span><br><span class="line">               if (isAllowScroll&amp;&amp;mXVelocity&gt;MAX_VELOCITY_VALUE&amp;&amp;mCurScreen&gt;0)&#123;</span><br><span class="line">                   scrollScreen(mCurScreen-1);</span><br><span class="line">               &#125;else if (isAllowScroll&amp;&amp;mXVelocity&lt;-MAX_VELOCITY_VALUE&amp;&amp;mCurScreen&lt;mChildCount-1)&#123;</span><br><span class="line">                   scrollScreen(mCurScreen+1);</span><br><span class="line">              //当设置了不能滑动时候，并且手指滑动的Move的距离已经超过了屏幕的10/1，有一个回弹的效果，左右摇摆</span><br><span class="line">               &#125;else if (mCanScrolled)&#123;</span><br><span class="line">                   springToDestination();</span><br><span class="line">               &#125;else&#123;</span><br><span class="line">                   snapToDestination();</span><br><span class="line">               &#125;</span><br><span class="line">               //最后不要忘记了释放</span><br><span class="line">               releaseVelocityTracker();</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return super.onTouchEvent(event);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##滑动到指定的屏幕,在记住两个地方，就不需要滑动了，一个是在最右和最左端。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private void scrollScreen(int whichScreen) &#123;</span><br><span class="line">       //防止超出了最大的孩子的数量</span><br><span class="line">       int min = Math.min(whichScreen, mChildCount - 1);</span><br><span class="line">       whichScreen = Math.max(0, min);</span><br><span class="line">       //getScrollX() 就是当前view的左上角相对于母视图的左上角的X轴偏移量。</span><br><span class="line">       //在这里当getScrollX==0的时候，等于后面的whichScreen*getWidth()那么就滑动到第一页了</span><br><span class="line">       //后续就不需要滑动了，也不需要重新绘制了</span><br><span class="line">       // TODO: 2017/9/3 这里只在最左不能进去滑动了，其实在最右端也是不能够去滑动了，带解决</span><br><span class="line">       if (getScrollX()!=whichScreen*getWidth())&#123;</span><br><span class="line">           int deltaX = whichScreen * (getWidth() - THREE_GAP_WIDTH) - getScrollX();</span><br><span class="line">           mCurScreen = whichScreen;</span><br><span class="line">           mScroller.startScroll(getScrollX(), 0, deltaX, 0, Math.abs(deltaX));</span><br><span class="line">           invalidate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>但是在这里我留下一个问题，但是在这里我留下一个问题在我的手机上我测试了1到5个孩子的情况分别数据如下：<br>getScrollX()和whichScreen*getWidth()<br>     1个屏幕是0  0——–0<br>     2个屏幕是90 990  ——-1080<br>     3个屏是 120<br>     4个屏  =270 2970  ——-3240<br>     5个屏  =380  3960  ——-4320<br>     当我们滑动到最有端的时候，其实也是不能够去滑动了，但是我这个方法呢是能够 走到if当中的，而且对应关系也不太明确，这个问题我还得想想。</p><p>##还需要理解一个东西getScrollX()到底是什么值？再次献上我的美作，哈哈，反正我是明白了，我怕讲不明白，所以先看图，然后抓日记，一下就明白!</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-53e2ed2e6329a2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>##监听滑动的速度，在上篇笔锋效果里面有讲到过，还是Viewpager里面的东西,记住要释放这个算是监听吧！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   //监听滑动的速度</span><br><span class="line">      obtainTracker(event);</span><br><span class="line"></span><br><span class="line">  private void obtainTracker(MotionEvent event) &#123;</span><br><span class="line">      if (mVelocityTracker==null) &#123;</span><br><span class="line">          mVelocityTracker = VelocityTracker.obtain();</span><br><span class="line">      &#125;</span><br><span class="line">      //绑定事件</span><br><span class="line">      mVelocityTracker.addMovement(event);</span><br><span class="line">  &#125;</span><br><span class="line">/**</span><br><span class="line">   * 释放监听滑动速度方法</span><br><span class="line">   */</span><br><span class="line">  private void releaseVelocityTracker() &#123;</span><br><span class="line">      if (mVelocityTracker != null) &#123;</span><br><span class="line">          mVelocityTracker.recycle();</span><br><span class="line">          mVelocityTracker = null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>##其实你就把上面的工作全部都做好了，你会发现还是不能够翻页，来吧去Viewpager看看，再去度娘看看<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 计算滚动的位置</span><br><span class="line">   */</span><br><span class="line">  @Override</span><br><span class="line">  public void computeScroll() &#123;</span><br><span class="line">      super.computeScroll();</span><br><span class="line">      //返回值为boolean，mScroller.computeScrollOffset()==true说明滚动尚未完成，false说明滚动已经完成。</span><br><span class="line">      if (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">          scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">          postInvalidate();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-b65df02b20499072.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>个人翻译就是在viewpager中需要重新计算滑动的位置<br><img src="http://upload-images.jianshu.io/upload_images/5363507-f9b51f5e11529f03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>##回弹滑动目的屏,这里就是需要有点动画的效果，先回到原来的位置，然后左右摇摆摇摆！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 回弹滑动目的屏</span><br><span class="line">     */</span><br><span class="line">    private void springToDestination() &#123;</span><br><span class="line">        System.out.println(&quot;shiming  ==springToDestination&quot;);</span><br><span class="line">        int screenWidth = getWidth();</span><br><span class="line">        int whichScreen = (getScrollX() + screenWidth / 2) / screenWidth;</span><br><span class="line">        whichScreen = Math.max(0, Math.min(whichScreen, mChildCount - 1));</span><br><span class="line">        final int deltaX = whichScreen * (getWidth() - THREE_GAP_WIDTH) - getScrollX();</span><br><span class="line">        mCurScreen = whichScreen;</span><br><span class="line">        //先给我滚动到原来的位置</span><br><span class="line">        springToScroll(deltaX * 1.0f, Math.abs(deltaX));</span><br><span class="line">        //向右的给我摆动两下</span><br><span class="line">        postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                springToScroll(-deltaX * 0.3f, Math.abs(deltaX));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, Math.abs(deltaX));</span><br><span class="line">        //让后给我向左摆动两下</span><br><span class="line">        postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                springToScroll(deltaX * 0.3f, Math.abs(deltaX));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, Math.abs(deltaX * 2));</span><br><span class="line">        mCanScrolled = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">     *  getScrollX() 水平方向滚动的偏移值，以像素为单位。正值表明滚动将向左滚动</span><br><span class="line">     　　startY 垂直方向滚动的偏移值，以像素为单位。正值表明滚动将向上滚动</span><br><span class="line">     　　(int) deltaX 水平方向滑动的距离，正值会使滚动向左滚动</span><br><span class="line">     　 0  垂直方向滑动的距离，正值会使滚动向上滚动</span><br><span class="line">     * @param deltaX</span><br><span class="line">     * @param duration</span><br><span class="line">     */</span><br><span class="line">    private void springToScroll(float deltaX, int duration) &#123;</span><br><span class="line">        mScroller.startScroll(getScrollX(), 0, (int) deltaX, 0, duration);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>##好了，以上，我写的写的都要睡早了，代码有些注释还比较详细一点，如有需要看代码吧，由于工程逻辑上，还有很多复杂的代码，我这里就提取了一部分，以供学习之用，谢谢！<br>地址Git：<a href="https://github.com/Shimingli/CardViewPager" target="_blank" rel="noopener">https://github.com/Shimingli/CardViewPager</a></p>]]></content>
      
      
        <tags>
            
            <tag> 自定义卡片效果的ViewGroup </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓画笔笔锋的实现探索（一）</title>
      <link href="/2017/08/26/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2017/08/26/%E5%AE%89%E5%8D%93%E7%94%BB%E7%AC%94%E7%AC%94%E9%94%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%8E%A2%E7%B4%A2%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      <content type="html"><![CDATA[<ul><li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</li></ul><h2 id="不逼逼，看效果，感觉我的书法还阔以，哈哈-！"><a href="#不逼逼，看效果，感觉我的书法还阔以，哈哈-！" class="headerlink" title="不逼逼，看效果，感觉我的书法还阔以，哈哈!！"></a>不逼逼，看效果，感觉我的书法还阔以，哈哈!！</h2><p>设置笔宽度为60，效果如下<br><img src="http://upload-images.jianshu.io/upload_images/5363507-f1d4934949530f78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170910184918.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-8b622187caa4fca5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>这个效果明显一点，哈哈，是不是很有大师的写字风格<br><img src="http://upload-images.jianshu.io/upload_images/5363507-76230a0761ef9dda.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170902142924.jpg"><br><a id="more"></a></p><h4 id="实现这个效果，大体用了40个小时，熬了3天夜，我未来的女朋友给我作证，看了无数的文档，在git上有个哥们用opengGl3-0实现比我这个更牛逼的效果，但是发现在低端手机上会报错，原因是不支持openGL3-0，导致Apk装入失败，1-0的api有看不懂，你说我能怎么办，我也很绝望啊！同时感觉opengl更加节手机性能，but我错了，在低端手机上使用opengl简直就是噩梦，卡的一逼，算了不提了，此功能的实现还是基于安卓的Paint，通过事件去绘制路径。"><a href="#实现这个效果，大体用了40个小时，熬了3天夜，我未来的女朋友给我作证，看了无数的文档，在git上有个哥们用opengGl3-0实现比我这个更牛逼的效果，但是发现在低端手机上会报错，原因是不支持openGL3-0，导致Apk装入失败，1-0的api有看不懂，你说我能怎么办，我也很绝望啊！同时感觉opengl更加节手机性能，but我错了，在低端手机上使用opengl简直就是噩梦，卡的一逼，算了不提了，此功能的实现还是基于安卓的Paint，通过事件去绘制路径。" class="headerlink" title="实现这个效果，大体用了40个小时，熬了3天夜，我未来的女朋友给我作证，看了无数的文档，在git上有个哥们用opengGl3.0实现比我这个更牛逼的效果，但是发现在低端手机上会报错，原因是不支持openGL3.0，导致Apk装入失败，1.0的api有看不懂，你说我能怎么办，我也很绝望啊！同时感觉opengl更加节手机性能，but我错了，在低端手机上使用opengl简直就是噩梦，卡的一逼，算了不提了，此功能的实现还是基于安卓的Paint，通过事件去绘制路径。"></a>实现这个效果，大体用了40个小时，熬了3天夜，我未来的女朋友给我作证，看了无数的文档，在git上有个哥们用opengGl3.0实现比我这个更牛逼的效果，但是发现在低端手机上会报错，原因是不支持openGL3.0，导致Apk装入失败，1.0的api有看不懂，你说我能怎么办，我也很绝望啊！同时感觉opengl更加节手机性能，but我错了，在低端手机上使用opengl简直就是噩梦，卡的一逼，算了不提了，此功能的实现还是基于安卓的Paint，通过事件去绘制路径。</h4><p>##1.创建DrawPenView类继承View</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-7094aaa5fa65811f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####初始化笔,笔锋的效果，我个人尝试了使用三个笔，每次绘制的时候，三个笔一起绘制，根据手指的滑动速率的快慢去使其中的某个笔不用绘制，但是这个效果稀烂，所以view的还是用一只笔即可，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mPaint = new Paint();</span><br><span class="line">mPaint.setColor(Color.parseColor(&quot;#FF4081&quot;));</span><br><span class="line">mPaint.setStrokeWidth(14);</span><br><span class="line">mPaint.setStyle(Paint.Style.STROKE);</span><br><span class="line">mPaint.setStrokeCap(Paint.Cap.ROUND);//结束的笔画为圆心</span><br><span class="line">mPaint.setStrokeJoin(Paint.Join.ROUND);//连接处元</span><br><span class="line">mPaint.setAlpha(0xFF);</span><br><span class="line">mPaint.setAntiAlias(true);</span><br><span class="line">mPaint.setStrokeMiter(1.0f);</span><br></pre></td></tr></table></figure></p><p>####初始化bitmap，和画布，画布在这里主要是生成一张bitmap的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private void initParameter(Context context) &#123;</span><br><span class="line">      mContext = context;</span><br><span class="line">      DisplayMetrics dm = new DisplayMetrics();</span><br><span class="line">      ((Activity) mContext).getWindowManager().getDefaultDisplay().getMetrics(dm);</span><br><span class="line">      mBitmap = Bitmap.createBitmap(dm.widthPixels, dm.heightPixels, Bitmap.Config.ARGB_8888);</span><br><span class="line">      //笔的控制类</span><br><span class="line">      mVisualStrokePen=new VisualStrokePen(mContext);</span><br><span class="line">      initPaint(mContext);</span><br><span class="line">      initCanvas();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private void initCanvas() &#123;</span><br><span class="line">      mCanvas = new Canvas(mBitmap);</span><br><span class="line">      //设置画布的颜色的问题</span><br><span class="line">      mCanvas.drawColor(Color.TRANSPARENT);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####重写onDraw（）方法:由于项目需要，在这里我仅仅提供了两个方法：清除画布和绘制。扩展的功能有：返回上一步的绘制步骤，设置画笔的属性，mark笔，毛笔，钢笔，圆珠笔，铅笔等一切的控制都在这里进行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">    canvas.drawBitmap(mBitmap, 0, 0, mPaint);</span><br><span class="line">    switch (mCanvasCode) &#123;</span><br><span class="line">        case CANVAS_NORMAL:</span><br><span class="line">            mVisualStrokePen.draw(canvas);</span><br><span class="line">            break;</span><br><span class="line">        case CANVAS_RESET:</span><br><span class="line">            reset();</span><br><span class="line">            break;</span><br><span class="line">        default:</span><br><span class="line">            Log.e(TAG, &quot;onDraw&quot; + Integer.toString(mCanvasCode));</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    super.onDraw(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##2.认识MotionEvent对象</p><p>####当用户触摸屏幕时，将创建一个MontionEvent对象。MotionEvent包含了关于发生触摸的位置和时间的信息，以及触摸事件的其他细节。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  event.getAction() //获取触控动作比如ACTION_DOWN</span><br><span class="line">  event.getPointerCount(); //获取触控点的数量，比如2则可能是两个手指同时按压屏幕</span><br><span class="line">  event.getPointerId(nID); //对于每个触控的点的细节，我们可以通过一个循环执行getPointerId方法获取索引</span><br><span class="line">  event.getX(nID); //获取第nID个触控点的x位置,记录的第一个点为getX，getY</span><br><span class="line">  event.getY(nID); //获取第nID个点触控的y位置</span><br><span class="line">  event.getPressure(nID); //LCD可以感应出用户的手指压力，当然具体的级别由驱动和物理硬件决定的</span><br><span class="line">  event.getDownTime() //按下开始时间</span><br><span class="line">  event.getEventTime() // 事件结束时间</span><br><span class="line">  event.getEventTime()-event.getDownTime()); //总共按下时花费时间</span><br><span class="line">  * @param event</span><br><span class="line">  * @return</span><br><span class="line">  */</span><br><span class="line"> @Override</span><br><span class="line"> public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">     //测试过程中，当使用到event的时候，产生了没有收到事件的问题，所以在这里需要obtian的一下</span><br><span class="line">     MotionEvent event2 = MotionEvent.obtain(event);</span><br><span class="line">     switch (event2.getActionMasked()) &#123;</span><br><span class="line">         case MotionEvent.ACTION_DOWN:</span><br><span class="line">             setCanvasCode(CANVAS_NORMAL);</span><br><span class="line">             mVisualStrokePen.onDown(mVisualStrokePen.createMotionElement(event2));</span><br><span class="line">             break;</span><br><span class="line">         case MotionEvent.ACTION_MOVE:</span><br><span class="line">             mVisualStrokePen.onMove(mVisualStrokePen.createMotionElement(event2));</span><br><span class="line">             break;</span><br><span class="line">         case MotionEvent.ACTION_UP:</span><br><span class="line">             long time = System.currentTimeMillis();</span><br><span class="line">             mVisualStrokePen.onUp(mVisualStrokePen.createMotionElement(event2),mCanvas);</span><br><span class="line">             break;</span><br><span class="line">         default:</span><br><span class="line">             break;</span><br><span class="line">     &#125;</span><br><span class="line">     invalidate();</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>####在这里我需要提到一个MotionEvent的api：motionEvent.getToolType(0);返回的以下四种的值，<br>TOOL_TYPE_UNKNOWN ：不知道什么画的<br>TOOL_TYPE_FINGER ：手指<br>TOOL_TYPE_STYLUS ：笔画的<br>TOOL_TYPE_MOUSE ：该工具是一个鼠标或触控板<br>TOOL_TYPE_ERASER ：工具是一块橡皮或一笔用于倒立的姿势<br>看见没，卧槽，以前都不知道，这个类知道我们用什么属性在写字，<br>event.getPressure(); //可以感应出用户的手指压力，当然具体的级别由驱动和物理硬件决定的,我的手机上为1<br>motionEvent.getEventTime()：事件发生的事件，在我此时的事件是shiming==8359650，而且是跟随着系统的时间而定<br>···</p><pre><code> /**  * Tool type constant: Unknown tool type. * This constant is used when the tool type is not known or is not relevant, * such as for a trackball or other non-pointing device. * * @see #getToolType */public static final int TOOL_TYPE_UNKNOWN = 0;/** * Tool type constant: The tool is a finger. * * @see #getToolType */public static final int TOOL_TYPE_FINGER = 1;/** * Tool type constant: The tool is a stylus. * * @see #getToolType */public static final int TOOL_TYPE_STYLUS = 2;/** * Tool type constant: The tool is a mouse or trackpad. * * @see #getToolType */public static final int TOOL_TYPE_MOUSE = 3;/** * Tool type constant: The tool is an eraser or a stylus being used in an inverted posture. * * @see #getToolType */public static final int TOOL_TYPE_ERASER = 4:</code></pre><p>####关于MotionElement 类：记录下五个参数：坐标x y，压力值，什么在屏幕上写的，还有事件发生的时间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static class MotionElement &#123;</span><br><span class="line"></span><br><span class="line">      public float x;</span><br><span class="line">      public float y;</span><br><span class="line">      public float pressure;</span><br><span class="line">      public int tooltype;</span><br><span class="line">      public long timestamp;</span><br><span class="line"></span><br><span class="line">      public MotionElement(float mx, float my, float mp, int ttype, long mt) &#123;</span><br><span class="line">          x = mx;</span><br><span class="line">          y = my;</span><br><span class="line">          pressure = mp;</span><br><span class="line">          tooltype = ttype;</span><br><span class="line">          timestamp = mt;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * event.getPressure(); //LCD可以感应出用户的手指压力，当然具体的级别由驱动和物理硬件决定的,我的手机上为1</span><br><span class="line">    * @param motionEvent</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   public MotionElement createMotionElement(MotionEvent motionEvent) &#123;</span><br><span class="line">       System.out.println(&quot;shiming== 0000==&quot;+motionEvent.getToolType(0));</span><br><span class="line">       System.out.println(&quot;shiming==&quot;+motionEvent.getPressure());</span><br><span class="line">       System.out.println(&quot;shiming==&quot;+motionEvent.getEventTime());</span><br><span class="line">       MotionElement motionElement = new MotionElement(motionEvent.getX(), motionEvent.getY(),</span><br><span class="line">               motionEvent.getPressure(), motionEvent.getToolType(0),</span><br><span class="line">               motionEvent.getEventTime());</span><br><span class="line">       return motionElement;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>##3.清除画布<br>Xfermode国外有大神称之为过渡模式，这种翻译比较贴切但恐怕不易理解，大家也可以直接称之为图像混合模式，因为所谓的“过渡”其实就是图像混合的一种把paint.setXfermode(Xfermode xfermode)的模式设置为clear，使用我们新建的canvas去drapaint这个笔，记得清除完了，要把mode设置为null<br>有偏文档介绍的很好，我在这里抛砖引玉一下，就不班门弄斧了：<a href="http://www.cnblogs.com/tianzhijiexian/p/4297172.html" target="_blank" rel="noopener">http://www.cnblogs.com/tianzhijiexian/p/4297172.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   *清除画布，记得清除点的集合</span><br><span class="line">   */</span><br><span class="line">  public void reset() &#123;</span><br><span class="line">      mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.CLEAR));</span><br><span class="line">      mCanvas.drawPaint(mPaint);</span><br><span class="line">      mPaint.setXfermode(null);</span><br><span class="line">      mVisualStrokePen.clear();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>##4.关于Bezier曲线<br>先发个图，嘿嘿，我自己手画的，看不清没关系，只需知道4个点的关系，想象一下曲线就行</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-7dd06af8c72132e2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信图片_20170826183403.jpg"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-df08ff751b79f650.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####知道两点连接起来是直线，当我们不断的求出两个点的控制点，把无数的控制点绘制在一起就是一条完美的曲线，反正我这样子理解的，当然我在这里也做了一个width的控制，和这种的原理差不多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void init(float lastx, float lasty, float lastWidth, float x, float y, float width)</span><br><span class="line">   &#123;</span><br><span class="line">       //资源点设置，最后的点的为资源点</span><br><span class="line">       mSource.set(lastx, lasty, lastWidth);</span><br><span class="line">       float xmid = getMid(lastx, x);</span><br><span class="line">       float ymid = getMid(lasty, y);</span><br><span class="line">       float wmid = getMid(lastWidth, width);</span><br><span class="line">       //距离点为平均点</span><br><span class="line">       mDestination.set(xmid, ymid, wmid);</span><br><span class="line">       //控制点为当前的距离点</span><br><span class="line">       mControl.set(getMid(lastx,xmid),getMid(lasty,ymid),getMid(lastWidth,wmid));</span><br><span class="line">       //下个控制点为当前点</span><br><span class="line">       mNextControl.set(x, y, width);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    *</span><br><span class="line">    * @param x1 一个点的x</span><br><span class="line">    * @param x2 一个点的x</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">  /**</span><br><span class="line">    *</span><br><span class="line">    * @param x1 一个点的x</span><br><span class="line">    * @param x2 一个点的x</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private float getMid(float x1, float x2) &#123;</span><br><span class="line">       return (float)((x1 + x2) / 2.0);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private double getWidth(double w0, double w1, double t)&#123;</span><br><span class="line">       return w0 + (w1 - w0) * t;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>####以上记得知道个步骤，才能方便理解，当这个点是我们资源点的时候，或者是当前点，那么它下一步就会成为一个新的资源点，需要不断的替换当前的起点和终点，那么才可以形成一个曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 替换就的点，原来的距离点变换为资源点，控制点变为原来的下一个控制点，距离点取原来控制点的和新的的一半</span><br><span class="line"> * 下个控制点为新的点</span><br><span class="line"> * @param x 新的点的坐标</span><br><span class="line"> * @param y 新的点的坐标</span><br><span class="line"> * @param width</span><br><span class="line"> */</span><br><span class="line">public void addNode(float x, float y, float width)&#123;</span><br><span class="line">    mSource.set(mDestination);</span><br><span class="line">    mControl.set(mNextControl);</span><br><span class="line">    mDestination.set(getMid(mNextControl.x, x), getMid(mNextControl.y, y), getMid(mNextControl.width, width));</span><br><span class="line">    mNextControl.set(x, y, width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####是不是看不懂，对，看不懂就对了，去下面看代码，记得在本子上多画几个点，想象一下这样变换的位置，然后就会明白了这真的是一个美妙的曲线，比女朋友还漂亮，哈哈，扯皮了</p><p>####关于手指抬起来的时候的方法: 结合手指抬起来的动作，告诉现在的曲线控制点也必须变化，其实在这里也不需要结合着up事件使用因为在down的事件中，所有点都会被重置，然后设置这个没有多少意义，但是可以改变下个事件的朝向改变先留着，因为后面如果需要控制整个颜色的改变的话，我的依靠这个方法，还有按压的时间的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 结合手指抬起来的动作，告诉现在的曲线控制点也必须变化，其实在这里也不需要结合着up事件使用</span><br><span class="line">   * 因为在down的事件中，所有点都会被重置，然后设置这个没有多少意义，但是可以改变下个事件的朝向改变</span><br><span class="line">   * 先留着，因为后面如果需要控制整个颜色的改变的话，我的依靠这个方法，还有按压的时间的变化</span><br><span class="line">   */</span><br><span class="line">   /**</span><br><span class="line">   * 结合手指抬起来的动作，告诉现在的曲线控制点也必须变化，其实在这里也不需要结合着up事件使用</span><br><span class="line">   * 因为在down的事件中，所有点都会被重置，然后设置这个没有多少意义，但是可以改变下个事件的朝向改变</span><br><span class="line">   * 先留着，因为后面如果需要控制整个颜色的改变的话，我的依靠这个方法，还有按压的时间的变化</span><br><span class="line">   */</span><br><span class="line">  public void end() &#123;</span><br><span class="line">      mSource.set(mDestination);</span><br><span class="line">      float x = getMid(mNextControl.x, mSource.x);</span><br><span class="line">      float y = getMid(mNextControl.y, mSource.y);</span><br><span class="line">      float w = getMid(mNextControl.width, mSource.width);</span><br><span class="line">      mControl.set(x, y, w);</span><br><span class="line">      mDestination.set(mNextControl);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>####还有个方法：我的提一句，是不是想一个一元二次的方程，哈哈！这个不是我写的，这个是基于git上开源的写的，是不是有点高中数学的影响了，哈哈，对就是这样的，</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-502f1a6068d1fc73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><pre><code> * 三阶曲线的控制点 * @param p0 * @param p1 * @param p2 * @param t * @return */private double getValue(double p0, double p1, double p2, double t){    double A = p2 - 2 * p1 + p0;    double B = 2 * (p1 - p0);    double C = p0;    return A * t * t + B * t + C;}</code></pre><p>##5.关于StrokePen，这个类才是所有的关键，如图分析：其实原理就是，通过安卓事件收集一个点的集合，这个点的集合的第一点和第二个点，绘制一个椭圆一个椭圆。</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-61b7202ef15ed062.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">private void drawLine(Canvas canvas, double x0, double y0, double w0, double x1, double y1, double w1, Paint paint)&#123;</span><br><span class="line">        //求两个数字的平方根 x的平方+y的平方在开方记得X的平方+y的平方=1，这就是一个园</span><br><span class="line">       double curDis = Math.hypot(x0-x1, y0-y1);</span><br><span class="line">       int steps = 1;</span><br><span class="line">       if(paint.getStrokeWidth() &lt; 6)&#123;</span><br><span class="line">           steps = 1+(int)(curDis/2);</span><br><span class="line">       &#125;else if(paint.getStrokeWidth() &gt; 60)&#123;</span><br><span class="line">           steps = 1+(int)(curDis/4);</span><br><span class="line">       &#125;else&#123;</span><br><span class="line">           steps = 1+(int)(curDis/3);</span><br><span class="line">       &#125;</span><br><span class="line">       double deltaX=(x1-x0)/steps;</span><br><span class="line">       double deltaY=(y1-y0)/steps;</span><br><span class="line">       double deltaW=(w1-w0)/steps;</span><br><span class="line">       double x=x0;</span><br><span class="line">       double y=y0;</span><br><span class="line">       double w=w0;</span><br><span class="line"></span><br><span class="line">       for(int i=0;i&lt;steps;i++)&#123;</span><br><span class="line">           RectF oval = new RectF();</span><br><span class="line">           oval.set((float)(x-w/4.0f), (float)(y-w/2.0f), (float)(x+w/4.0f), (float)(y+w/2.0f));</span><br><span class="line">           //最基本的实现，通过点控制线，绘制椭圆</span><br><span class="line">           canvas.drawOval(oval, paint);</span><br><span class="line">           x+=deltaX;</span><br><span class="line">           y+=deltaY;</span><br><span class="line">           w+=deltaW;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p> ####说明</p><ul><li>求两个数字的平方根 x的平方+y的平方在开方记得X的平方+y的平方=1，这就是一个园<pre><code>double curDis = Math.hypot(x0-x1, y0-y1);</code></pre></li><li><p>绘制多少个椭圆，我们可以根据笔的宽度,当笔的宽度和大的时候，我们绘制的可以适当减少步骤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(paint.getStrokeWidth() &lt; 6)&#123;</span><br><span class="line">          steps = 1+(int)(curDis/2);</span><br><span class="line">      &#125;else if(paint.getStrokeWidth() &gt; 60)&#123;</span><br><span class="line">          steps = 1+(int)(curDis/4);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">          steps = 1+(int)(curDis/3);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于Rext和RexF的区别：Rect是使用int类型作为数值，RectF是使用float类型作为数值。很明显这里我们需要更高的精度 </p></li><li>绘制的原理，就是每个记录下的点绘制一个椭圆，当无数个的椭圆重合在一起就是一个线，这个线的宽度和椭圆的形状有关系<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RectF oval = new RectF();</span><br><span class="line">oval.set((float)(x-w/4.0f), (float)(y-w/2.0f), (float)(x+w/4.0f), (float)(y+w/2.0f));</span><br><span class="line">//最基本的实现，通过点控制线，绘制椭圆</span><br><span class="line">canvas.drawOval(oval, paint);</span><br></pre></td></tr></table></figure></li></ul><p>这里需要在view中的onDraw中调用，本来我开始是想说能不能再一开始的时候，down事件的时候，给他画个园，但是这个园的半径我控制不好，所以在代码中我留下这个问题，以后需要做更难的效果的时候，我来把这个开始的步骤补上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 早onDraw需要调用</span><br><span class="line">     * @param canvas 画布</span><br><span class="line">     */</span><br><span class="line">    public void draw(Canvas canvas) &#123;</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        //点的集合少 不去绘制</span><br><span class="line">        if (mHWPointList == null || mHWPointList.size() &lt; 1)</span><br><span class="line">            return;</span><br><span class="line">        //当控制点的集合很少的时候，需要画个小圆，但是需要算法</span><br><span class="line">        if (mHWPointList.size() &lt; 2) &#123;</span><br><span class="line">            ControllerPoint point = mHWPointList.get(0);</span><br><span class="line">            //由于此问题在算法上还没有实现，所以暂时不给他画圆圈</span><br><span class="line">            //canvas.drawCircle(point.x, point.y, point.width, mPaint);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curPoint = mHWPointList.get(0);</span><br><span class="line">            for (int i = 1; i &lt; mHWPointList.size(); i++) &#123;</span><br><span class="line">                ControllerPoint point = mHWPointList.get(i);</span><br><span class="line">                drawToPoint(canvas, point, mPaint);</span><br><span class="line">                curPoint = point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>####Down事件处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">     * 手指的down事件</span><br><span class="line">     * @param mElement</span><br><span class="line">     */</span><br><span class="line">    public void onDown(MotionElement mElement) &#123;</span><br><span class="line">        mPaint.setXfermode(null);</span><br><span class="line">        mPath = new Path();</span><br><span class="line">        mPointList.clear();</span><br><span class="line">        mHWPointList.clear();</span><br><span class="line">        //记录down的控制点的信息</span><br><span class="line">        ControllerPoint curPoint = new ControllerPoint(mElement.x, mElement.y);</span><br><span class="line">        //如果用笔画的画我的屏幕，记录他宽度的和压力值的乘，但是哇，</span><br><span class="line">        if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">            mLastWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //如果是手指画的，我们取他的0.8</span><br><span class="line">            mLastWidth = 0.8 * mBaseWidth;</span><br><span class="line">        &#125;</span><br><span class="line">        //down下的点的宽度</span><br><span class="line">        curPoint.width = (float) mLastWidth;</span><br><span class="line">        mLastVel = 0;</span><br><span class="line"></span><br><span class="line">        mPointList.add(curPoint);</span><br><span class="line">        //记录当前的点</span><br><span class="line">        mLastPoint = curPoint;</span><br><span class="line">        //绘制起点</span><br><span class="line">        mPath.moveTo(mElement.x, mElement.y);</span><br><span class="line">    &#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure></p><p>####Move事件的处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">public void onMove(MotionElement mElement) &#123;</span><br><span class="line">       ControllerPoint curPoint = new ControllerPoint(mElement.x, mElement.y);</span><br><span class="line"></span><br><span class="line">       double deltaX = curPoint.x - mLastPoint.x;</span><br><span class="line">       double deltaY = curPoint.y - mLastPoint.y;</span><br><span class="line">       //deltaX和deltay平方和的二次方根 想象一个例子 1+1的平方根为1.4 （x²+y²）开根号</span><br><span class="line">       double curDis = Math.hypot(deltaX, deltaY);</span><br><span class="line">       //我们求出的这个值越小，画的点或者是绘制椭圆形越多，这个值越大的话，绘制的越少，笔就越细，宽度越小</span><br><span class="line">       double curVel = curDis * DIS_VEL_CAL_FACTOR;</span><br><span class="line">       System.out.println(&quot;shiming===&quot;+curDis+&quot; &quot;+curVel+&quot; &quot;+deltaX+&quot; &quot;+deltaY);</span><br><span class="line">       double curWidth;</span><br><span class="line">       //点的集合少，我们得必须改变宽度,每次点击的down的时候，这个事件</span><br><span class="line">       if (mPointList.size() &lt; 2) &#123;</span><br><span class="line">           System.out.println(&quot;shiming==dian shao&quot;);</span><br><span class="line">           if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">               curWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               curWidth = calcNewWidth(curVel, mLastVel, curDis, 1.5,</span><br><span class="line">                       mLastWidth);</span><br><span class="line">           &#125;</span><br><span class="line">           curPoint.width = (float) curWidth;</span><br><span class="line">           mBezier.Init(mLastPoint, curPoint);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           System.out.println(&quot;shiming==dian duo&quot;);</span><br><span class="line">           mLastVel = curVel;</span><br><span class="line">           if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">               curWidth = mElement.pressure * mBaseWidth;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //由于我们手机是触屏的手机，滑动的速度也不慢，所以，一般会走到这里来</span><br><span class="line">               //阐明一点，当滑动的速度很快的时候，这个值就越小，越慢就越大，依靠着mlastWidth不断的变换</span><br><span class="line">               curWidth = calcNewWidth(curVel, mLastVel, curDis, 1.5,</span><br><span class="line">                       mLastWidth);</span><br><span class="line">               System.out.println(&quot;shiming==&quot;+curVel+&quot; &quot;+mLastVel+&quot; &quot;+curDis+&quot; &quot; +mLastWidth);</span><br><span class="line">               System.out.println(&quot;shiming==dian duo&quot;+curWidth);</span><br><span class="line">           &#125;</span><br><span class="line">           curPoint.width = (float) curWidth;</span><br><span class="line">           mBezier.AddNode(curPoint);</span><br><span class="line">       &#125;</span><br><span class="line">       //每次移动的话，这里赋值新的值</span><br><span class="line">       mLastWidth = curWidth;</span><br><span class="line"></span><br><span class="line">       mPointList.add(curPoint);</span><br><span class="line"></span><br><span class="line">       int steps = 1 + (int) curDis / STEPFACTOR;</span><br><span class="line">       System.out.println(&quot;shiming-- steps&quot;+steps);</span><br><span class="line">       double step = 1.0 / steps;</span><br><span class="line">       for (double t = 0; t &lt; 1.0; t += step) &#123;</span><br><span class="line">           ControllerPoint point = mBezier.GetPoint(t);</span><br><span class="line">           mHWPointList.add(point);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mPath.quadTo(mLastPoint.x, mLastPoint.y,</span><br><span class="line">               (mElement.x + mLastPoint.x) / 2,</span><br><span class="line">               (mElement.y + mLastPoint.y) / 2);</span><br><span class="line"></span><br><span class="line">       mLastPoint = curPoint;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>##Up事件的处理:当需要关心我们画的这个bitmap的时候，记得在up结束的时候，需要把这个绘制的东西需要重新绘制到我们自定义View的画布上，这个画笔是自己定义的，而不是View里面onDraw(cavns)里面的画布</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public void onUp(MotionElement mElement, Canvas canvas) &#123;</span><br><span class="line">       ControllerPoint curPoint = new ControllerPoint(mElement.x, mElement.y);</span><br><span class="line">       double deltaX = curPoint.x - mLastPoint.x;</span><br><span class="line">       double deltaY = curPoint.y - mLastPoint.y;</span><br><span class="line">       double curDis = Math.hypot(deltaX, deltaY);</span><br><span class="line"></span><br><span class="line">       if (mElement.tooltype == MotionEvent.TOOL_TYPE_STYLUS) &#123;</span><br><span class="line">           curPoint.width = (float) (mElement.pressure * mBaseWidth);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           curPoint.width = 0;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mPointList.add(curPoint);</span><br><span class="line"></span><br><span class="line">       mBezier.AddNode(curPoint);</span><br><span class="line"></span><br><span class="line">       int steps = 1 + (int) curDis / STEPFACTOR;</span><br><span class="line">       double step = 1.0 / steps;</span><br><span class="line">       for (double t = 0; t &lt; 1.0; t += step) &#123;</span><br><span class="line">           ControllerPoint point = mBezier.GetPoint(t);</span><br><span class="line">           mHWPointList.add(point);</span><br><span class="line">       &#125;</span><br><span class="line">       //</span><br><span class="line">       mBezier.End();</span><br><span class="line">       for (double t = 0; t &lt; 1.0; t += step) &#123;</span><br><span class="line">           ControllerPoint point = mBezier.GetPoint(t);</span><br><span class="line">           mHWPointList.add(point);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       mPath.quadTo(mLastPoint.x, mLastPoint.y,</span><br><span class="line">               (mElement.x + mLastPoint.x) / 2,</span><br><span class="line">               (mElement.y + mLastPoint.y) / 2);</span><br><span class="line">       mPath.lineTo(mElement.x, mElement.y);</span><br><span class="line">      // 手指up 我画到纸上上</span><br><span class="line">       draw(canvas);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>####其实这里才是关键的地方，通过画布画椭圆，每一个点都是一个椭圆，这个椭圆的所有细节，逐渐构建出一个完美的笔尖 和笔锋的效果,我觉得在这里需要大量的测试，其实就对低端手机进行排查，看我们绘制的笔的宽度是多少，绘制多少个椭圆然后在低端手机上不会那么卡，当然你哪一个N年前的手机给我，那也的卡，只不过需要适中的范围里面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private void drawLine(Canvas canvas, double x0, double y0, double w0, double x1, double y1, double w1, Paint paint)&#123;</span><br><span class="line">     double curDis = Math.hypot(x0-x1, y0-y1);</span><br><span class="line">     int steps = 1;</span><br><span class="line">     if(paint.getStrokeWidth() &lt; 6)&#123;</span><br><span class="line">         steps = 1+(int)(curDis/2);</span><br><span class="line">     &#125;else if(paint.getStrokeWidth() &gt; 60)&#123;</span><br><span class="line">         steps = 1+(int)(curDis/4);</span><br><span class="line">     &#125;else&#123;</span><br><span class="line">         steps = 1+(int)(curDis/3);</span><br><span class="line">     &#125;</span><br><span class="line">     double deltaX=(x1-x0)/steps;</span><br><span class="line">     double deltaY=(y1-y0)/steps;</span><br><span class="line">     double deltaW=(w1-w0)/steps;</span><br><span class="line">     double x=x0;</span><br><span class="line">     double y=y0;</span><br><span class="line">     double w=w0;</span><br><span class="line"></span><br><span class="line">     for(int i=0;i&lt;steps;i++)&#123;</span><br><span class="line">         RectF oval = new RectF();</span><br><span class="line">         oval.set((float)(x-w/4.0f), (float)(y-w/2.0f), (float)(x+w/4.0f), (float)(y+w/2.0f));</span><br><span class="line">         //最基本的实现，通过点控制线，绘制椭圆</span><br><span class="line">         canvas.drawOval(oval, paint);</span><br><span class="line">         x+=deltaX;</span><br><span class="line">         y+=deltaY;</span><br><span class="line">         w+=deltaW;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>##最后来张自画像,可以，帅的一比！</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-e5217194937430b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>#写在最后的话，不要皮，讲个原理，实现笔锋的效果？到底怎么实现，我先前纠结的是我一定要拿到手指的滑动的速率，安卓也提供了这个api，ViewPager的源码中提供了思路：如下图所示</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-8c985104e33ab948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ce8efa32bb2d2f9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ec29a3a0dfbb29ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>#当这个速度大于了mMinimumVelocity这个值的时候， Math.abs(velocity) &gt; mMinimumVelocity那么我们的页面就需要翻页了，下面是ViewPager的实现的代码，很明显就知道<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final float density = context.getResources().getDisplayMetrics().density;</span><br><span class="line"></span><br><span class="line">    mTouchSlop = configuration.getScaledPagingTouchSlop();</span><br><span class="line">    mMinimumVelocity = (int) (MIN_FLING_VELOCITY * density);</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">private int determineTargetPage(int currentPage, float pageOffset, int velocity, int deltaX) &#123;</span><br><span class="line">    int targetPage;</span><br><span class="line">    if (Math.abs(deltaX) &gt; mFlingDistance &amp;&amp; Math.abs(velocity) &gt; mMinimumVelocity) &#123;</span><br><span class="line">        targetPage = velocity &gt; 0 ? currentPage : currentPage + 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        final float truncator = currentPage &gt;= mCurItem ? 0.4f : 0.6f;</span><br><span class="line">        targetPage = currentPage + (int) (pageOffset + truncator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (mItems.size() &gt; 0) &#123;</span><br><span class="line">        final ItemInfo firstItem = mItems.get(0);</span><br><span class="line">        final ItemInfo lastItem = mItems.get(mItems.size() - 1);</span><br><span class="line"></span><br><span class="line">        // Only let the user target pages we have items for</span><br><span class="line">        targetPage = Math.max(firstItem.position, Math.min(targetPage, lastItem.position));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return targetPage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#我就一直纠结啊，这种可以啊，没毛病啊，老铁，我就一直做啊做，实现的效果，就是一直Move事件中的笔的宽度都是一样的，是不是崩溃啊，的确很崩溃，最后我在想，能不能拿到按压值MotionEvent.getPressure();但是最后通过一查，这个方法的返回值是这样决定的：感应出用户的手指压力，当然具体的级别由驱动和物理硬件决定的，我一直用手写，这个值永远不变，奔溃，又一次崩溃，最后在研究一个opengl写的Demo的时候，我发现了一个真理：那就是，我要画多长，是用户手指决定的，但是它的Move事件中接受到的点的数量是和这个距离没有相对应的关系，啊哈哈，对不对，我接受了这个多点，但是我要画很长的线，是不是我的线就细了，但Move中的接受到的点数量一样，我画的距离短了，是不是线就粗了，这就是这个Demo的原理，顿时豁然开朗，春暖花开！</p><p>##最后奉上Git地址，求赞，如果后续有空闲的时间，我会试着实现毛笔的效果和马克笔的效果，求star，谢谢！<br><a href="https://github.com/Shimingli/WritingPen" target="_blank" rel="noopener">https://github.com/Shimingli/WritingPen</a></p>]]></content>
      
      
        <tags>
            
            <tag> 安卓画笔笔锋的实现探索（一） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Fragment.setNextAnim(int) on a null object reference</title>
      <link href="/2017/08/14/Fragment-setNextAnim/"/>
      <url>/2017/08/14/Fragment-setNextAnim/</url>
      <content type="html"><![CDATA[<h4 id="产生的原因：java-lang-NullPointerException-Attempt-to-invoke-virtual-method-‘void-android-support-v4-app-Fragment-setNextAnim-int-’-on-a-null-object-reference"><a href="#产生的原因：java-lang-NullPointerException-Attempt-to-invoke-virtual-method-‘void-android-support-v4-app-Fragment-setNextAnim-int-’-on-a-null-object-reference" class="headerlink" title="产生的原因：java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.support.v4.app.Fragment.setNextAnim(int)’ on a null object reference"></a>产生的原因：java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.support.v4.app.Fragment.setNextAnim(int)’ on a null object reference</h4><p>虽然知道是这个原因，但是呢？我们代码中并没有对MainActivity中的Fragment进入和出入动画做设置，可以这样说，这段代码是谷歌官方的，但是它抛异常<br><a id="more"></a><br><img src="http://upload-images.jianshu.io/upload_images/5363507-7c4adab74fa7b3df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-1dc01a163b603d8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>####影响的结果，app奔溃率的90%的原因都是这个原因。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-2a1bfe270abd8678.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-c4d5706681621beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>###定位问题<br><a href="http://blog.csdn.net/easyhood/article/details/53446830" target="_blank" rel="noopener">Android N 指纹识别 NullPointerException: Attempt toFragment.mNextAnim 的错误</a> 在这个博客下作者一句话：已录制指纹，关闭指纹后重新开启指纹识别，设置停止运行，抛出异常为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NullPointerException: Attempt to write to field &apos;int android.app.Fragment.mNextAnim&apos; on a null object reference</span><br></pre></td></tr></table></figure></p><p>虽然和我们的程序中抛出的异常不一样，但是也是出入动画的为null，解释的原因为：fragment为空的时候hide remove 或是show了，但是这毕竟是谷歌大神写的源码，毫无为空的地方，因为它也不显示到底第几行报错<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Like commit() but allows the commit to be executed after an activity’s state is saved. This is dangerous because the commit can be lost if the activity needs to later be restored from its state, so this should only be used for cases where it is okay for the UI state to change unexpectedly on the user.</span><br></pre></td></tr></table></figure></p><p>大致意思是说我使用的 commit方法是在Activity的onSaveInstanceState()之后调用的，这样会出错，因为<br>onSaveInstanceState方法是在该Activity即将被销毁前调用，来保存Activity数据的如果在保存完状态后再给它添加Fragment就会出错。<br>到这里我大概明白什么原因了，就是当onSaveInstanceState（）调用以后回来再次commit fragment的话，会导致这个bug的产生，所以在这里入手解决问题！</p><p>###模拟问题的出现<br>android3.0之前：onResume() – [optional]onSaveInstanceState() – onPause(),即调用onPause()之前，可能调用onSaveInstanceState()<br>android3.0之后：onResume() – onPause() – [optional]onSaveInstanceState() – onStop(),即调用onStop()之前，可能调用onSaveInstanceState()<br>就是由于这个可能，花费了很多时间，由于onSaveInstanceState()不是必然出现，所以要模拟出来，开始我的模拟之路！</p><p>####1、模拟横竖屏的情况（这种情况简单，但是由于项目工程中，在横竖屏上有很多null异常，导致自己修复的时候，很多代码需要注释掉，反而更加麻烦，最后没有完美呈现横屏情况下app的状态分析）</p><p>####2、模拟MainActivity异常关闭的情况，同时App正常的运行下来，在失去焦点了，2s后开启一个新的Activity同时关闭当前的Activity，但是呢？app不会异常，只不过在栈内最下的位置不是MainActivity了，当返回的时候，就直接退出程序了。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-753791c6434863cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5FXVLX)A{_09PM8`26B7ZTI.png"></p><p>####3、仔细研究到底合适会触发Activity的 onSaveInstanceState() 和 onRestoreInstanceState()；<br>Activity的 onSaveInstanceState() 和 onRestoreInstanceState()并不是生命周期方法，它们不同于 onCreate()、onPause()等生命周期方法，它们并不一定会被触发。当应用遇到意外情况（如：内存不足、用户直接按Home键）由系统销毁一个Activity时，onSaveInstanceState() 会被调用。但是当用户主动去销毁一个Activity时，例如在应用中按返回键，onSaveInstanceState()就不会被调用。因为在这种情况下，用户的行为决定了不需要保存Activity的状态。通常onSaveInstanceState()只适合用于保存一些临时性的状态，而onPause()适合用于数据的持久化保存。<br>onSaveInstanceState()方法会在什么时候被执行：<br>   　　(1)、当用户按下HOME键时。<br>　　这是显而易见的，系统不知道你按下HOME后要运行多少其他的程序，自然也不知道activity A是否会被销毁，因此系统会调用onSaveInstanceState()，让用户有机会保存某些非永久性的数据。以下几种情况的分析都遵循该原则<br>　　(2)、长按HOME键，选择运行其他的程序时。<br>　　(3)、按下电源按键（关闭屏幕显示）时。<br>　　(4)、从activity A中启动一个新的activity时。<br>　　(5)、屏幕方向切换时，例如从竖屏切换到横屏时。</p><p>##更具上面的结论，其实我在不断测试中已经在不断的走onSaveInstanceState()，只不过我自己以为没有走这个方法。但是测试过程中， Fragment.setNextAnim(int)这个bug产生的几率很小，可以忽略不计。所以这里可以得出结论：当onSaveInstanceState（）调用以后回来再次commit fragment的话，不会导致这个bug的产生，那么以上的全部都过程，都是不成立的</p><p>#那到底是什么样的问题导致Fragment.setNextAnim(int) null异常的呢？看下Acitivty的生命周期，当内存不足的时候，app能在后台被后台回收掉，但是Activity并没有被销毁掉，还是存在栈内中，只不过会走onCreate（）方法。ok！到这里就可以定位了出问题出现的点<br><img src="http://upload-images.jianshu.io/upload_images/5363507-192b3dffa53b523d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>##再次试图重现问题，这次聪明了，直接哪一个内存比较小的手机，不断的启动手机里其他的APP，同时也要启动目标App，然他的进程一直在前台进程和非前台进程中切换，需要注意的是，当启动一个比较耗内存的app比如地图，游戏之类的，会把app直接回收掉，这不是bug，这是安卓系统的原因，同时还需的注意点，在这里我们关心的MainActivity被回收了，所以建议把MainActivity的位置置于在栈内第三个或者是第四个位置，一切准备就绪，开始测试（主要看人品，我个人在测试3次左右就能出现）</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-37abf23257d293af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"><br>哦原来是，这样子fragment为null，导致了java.lang.NullPointerException: Attempt to invoke virtual method ‘void android.support.v4.app.Fragment.setNextAnim(int)’ on a null object reference</p><p>###来个手动的测试的结果，如图<br><img src="http://upload-images.jianshu.io/upload_images/5363507-ca95680aa5370125.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>#总结：当Activty别系统紧急回收了，没有被销毁，重新走到onCreate（）的方法中了，初始化Fragment的时候，导致fragment的变量为null，就会引起如下bug<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException:Unable to resume activity &#123;cn.changniannian.broodon/cn.changniannian.broodon.view.navigation.main.MainActivity&#125;: java.lang.NullPointerException: Attempt to invoke virtual method &apos;void android.support.v4.app.Fragment.setNextAnim(int)&apos; on a null object reference</span><br><span class="line">2 android.app.ActivityThread.performResumeActivity(ActivityThread.java:3030)</span><br><span class="line">3 ......</span><br><span class="line">4 Caused by:</span><br><span class="line">5 java.lang.NullPointerException:Attempt to invoke virtual method &apos;void android.support.v4.app.Fragment.setNextAnim(int)&apos; on a null object reference</span><br><span class="line">6 android.support.v4.app.BackStackRecord.executeOps(BackStackRecord.java:768)</span><br><span class="line">7 android.support.v4.app.FragmentManagerImpl.executeOps(FragmentManager.java:2415)</span><br><span class="line">8 android.support.v4.app.FragmentManagerImpl.executeOpsTogether(FragmentManager.java:2200)</span><br><span class="line">9 android.support.v4.app.FragmentManagerImpl.optimizeAndExecuteOps(FragmentManager.java:2153)</span><br><span class="line">10 android.support.v4.app.FragmentManagerImpl.execPendingActions(FragmentManager.java:2063)</span><br><span class="line">11 android.support.v4.app.FragmentController.execPendingActions(FragmentController.java:388)</span><br><span class="line">12 android.support.v4.app.FragmentActivity.onResume(FragmentActivity.java:440)</span><br><span class="line">13 com.broodon.core.base.BaseActivity.onResume(BaseActivity.java:137)</span><br><span class="line">14 cn.changniannian.broodon.view.navigation.main.MainActivity.onResume(MainActivity.java:525)</span><br><span class="line">15 android.app.Instrumentation.callActivityOnResume(Instrumentation.java:1243)</span><br><span class="line">16 android.app.Activity.performResume(Activity.java:6111)</span><br><span class="line">17 android.app.Activity.performResume(Activity.java:6313)</span><br><span class="line">18 android.app.ActivityThread.performResumeActivity(ActivityThread.java:3012)</span><br><span class="line">19 android.app.ActivityThread.handleResumeActivity(ActivityThread.java:3061)</span><br><span class="line">20 android.app.ActivityThread$H.handleMessage(ActivityThread.java:1375)</span><br><span class="line">21 android.os.Handler.dispatchMessage(Handler.java:102)</span><br><span class="line">22 android.os.Looper.loop(Looper.java:135)</span><br><span class="line">23 android.app.ActivityThread.main(ActivityThread.java:5318)</span><br><span class="line">24 java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">25 java.lang.reflect.Method.invoke(Method.java:372)</span><br><span class="line">26 com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:922)</span><br><span class="line">27 com.android.internal.os.ZygoteInit.main(ZygoteInit.java:717)</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-f2a0addeddb761f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
      
      
        <tags>
            
            <tag> Fragment.setNextAnim(int) on a null object reference </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVP网络框架Retorfit+Rxjava+Rxandroid</title>
      <link href="/2017/08/08/MVP%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6Retorfit-Rxjava-Rxandroid/"/>
      <url>/2017/08/08/MVP%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6Retorfit-Rxjava-Rxandroid/</url>
      <content type="html"><![CDATA[<ul><li>时隔三年再次过来回看这个Demo，修复聚合接口不能访问的问题，完善下载的Demo<br><img src="https://upload-images.jianshu.io/upload_images/5363507-4d657789d66e123f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li></ul><a id="more"></a><p>目前我个人觉得是一套比较好的network的网络请求框架，大体时间用了8个小时，由于其中的网络请求不会来数据，就解决了一会bug，中间拖了5天由于在工作，所以今天晚上来完成这篇博客<br>1、先了解mvp的模式</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-eadc63a77316195d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">包的结构，在外层可以套个ui的包，</p><p>逻辑处理交互到persenter去处理，在view层就关心数据和view的绑定</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-2857080996687c46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">在view中只需要new persenter（）</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-d97be7aef14051de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">点击事件去请求网络，或者在baseActivity中去封装一个方法只执行一次的网络请求</p><p>[图片上传中。。。（4）]数据回来再回调中去处理</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-f54fb365f90b2bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">在p中去做接口会掉的操作</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-72e015f3efad0088.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">omodel层拿到我偶们的service</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-d62825c5843371dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">service中去包装我们的接口</p><p>一套完美的代码结构，逻辑清晰，适合多个开发一个项目，从而不会显得代码网络请求紊乱，mvp的模式<br>2、怎么去封装网络请求</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-041cef98ce3ce8ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">创建依赖不要全部放在app去管理，一个好的工程结构，看起来给人的感觉很美</p><p>1、加入依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compile&apos;com.squareup.retrofit2:retrofit:2.1.0&apos;</span><br><span class="line">compile&apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;</span><br><span class="line">compile&apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;</span><br><span class="line">compile&apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos;// 日记拦截，方便调试</span><br><span class="line">compile&apos;io.reactivex:rxandroid:1.1.0&apos;//经典的rx</span><br></pre></td></tr></table></figure></p><p>2、创建我们自己的retrofit</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-0d4484cc4862f94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">retrofit的关键的代码</p><p>okhttpclient的使用，build出来，和我们的retorfit相关联在一起</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-b2b98430027354b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">通过这里去调用返回一个service</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-9a0800a9dedcab3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="">这里必须要使用单利的模式去管理</p><p>建立baseSubscriber去继承rx安卓的订阅者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public  class    BaseSubscriber    extends    Subscriber</span><br><span class="line">创建我们的接口</span><br><span class="line">public abstract class SubscriberListener&lt;T&gt; &#123;</span><br><span class="line">    public abstract void onSuccess(T response);</span><br><span class="line">    //why  后台定义来改动</span><br><span class="line">    public abstract void onFail(String errorCode,String errorMsg);</span><br><span class="line">    public abstract void onError(Throwable e);</span><br><span class="line">    public void onCompleted()&#123;  &#125;</span><br><span class="line">    public void onBegin()&#123;&#125;</span><br><span class="line">    //如果app需要检查你的账号是否在别的设备上登录，根据返回吗在这里做登录的操作</span><br><span class="line">    //每当用户在app中请求了一次网络的请求的话，就会走到这个方法里，然后在这个方法中做统一的操作</span><br><span class="line">    //比如退出app，重新登录。。。</span><br><span class="line">    public abstract void checkLogin(String errorCode,String erroMsg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个的接口是根据我们根据后台的服务器去自定义，onbegin的方法在哪里去调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">package network.shiming.com.network.retrofit;</span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2017/4/3.</span><br><span class="line"> * 订阅者</span><br><span class="line"> */</span><br><span class="line">public class BaseSubscriber&lt;T extends SMResponse&gt; extends Subscriber&lt;T&gt;&#123;</span><br><span class="line">    private static final String TAG=&quot;BaseSubscriber&quot;;</span><br><span class="line">    private SubscriberListener mBaseSubscriber;</span><br><span class="line">    public BaseSubscriber(SubscriberListener baseSubscriber)&#123;</span><br><span class="line">        this.mBaseSubscriber=baseSubscriber;</span><br><span class="line">    &#125;</span><br><span class="line">    public void onBegin()&#123;</span><br><span class="line">        Log.i(TAG,&quot;onbegin&quot;);</span><br><span class="line">        if (mBaseSubscriber!=null)&#123;</span><br><span class="line">            mBaseSubscriber.onBegin();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     * 为了防止可能的内存泄露，在你的 Activity 或 Fragment 的 onDestroy 里</span><br><span class="line">     * 用 Subscription.isUnsubscribed() 检查你的 Subscription 是否是</span><br><span class="line">     * unsubscribed。如果调用了 Subscription.unsubscribe()</span><br><span class="line">     * Unsubscribing将会对 items 停止通知给你的 Subscriber，</span><br><span class="line">     * 并允许垃圾回收机制释放对象，防止任何 RxJava 造成内存泄露</span><br><span class="line">     * 最终要走到我们的完成中去  要不然内存有可能泄露</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void onCompleted() &#123;</span><br><span class="line">        Log.i(TAG,&quot;onCompleted&quot;);</span><br><span class="line">        if (mBaseSubscriber!=null)&#123;</span><br><span class="line">            mBaseSubscriber.onCompleted();</span><br><span class="line">        &#125;</span><br><span class="line">        if (!this.isUnsubscribed())&#123;//如果用户已取消订阅返回true 加上！false</span><br><span class="line">            //请求完成了调用这个 手动的给他取消掉订阅  防止内存泄露</span><br><span class="line">            this.unsubscribe();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Throwable e) &#123;</span><br><span class="line">        Log.i(TAG,&quot;onError&quot;);</span><br><span class="line">        if (mBaseSubscriber!=null)&#123;</span><br><span class="line">            mBaseSubscriber.onError(e);//gothere  nopass down</span><br><span class="line">        &#125;</span><br><span class="line">        onCompleted();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onNext(T response) &#123;</span><br><span class="line">        Log.i(TAG,&quot;onNext&quot;);</span><br><span class="line">        if (mBaseSubscriber!=null)&#123;</span><br><span class="line">            System.out.println(response.error_code==0);</span><br><span class="line">            if (response.error_code==0)&#123;//结果码0  聚合数据的返回码看文档 o</span><br><span class="line">                mBaseSubscriber.onSuccess(response);</span><br><span class="line">            &#125;</span><br><span class="line">            // 这些返回码 都是需要和服务器 那边相对应的</span><br><span class="line">            if (response.error_code==1)&#123;</span><br><span class="line">                mBaseSubscriber.onFail(response.error_code+&quot;&quot;,response.reason);</span><br><span class="line">            &#125;</span><br><span class="line">            if (response.error_code==2)&#123;</span><br><span class="line">                mBaseSubscriber.checkLogin(response.error_code+&quot;&quot;,response.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法我们封装到我们的base中，在HttpMethod 中订阅开始call方法的开始，绑定call</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">package network.shiming.com.network.retrofit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import rx.Observable;</span><br><span class="line">import rx.android.schedulers.AndroidSchedulers;</span><br><span class="line">import rx.functions.Action0;</span><br><span class="line">import rx.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2017/4/8.</span><br><span class="line"> * RxJava最核心的两个东西是Observables（被观察者，事件源）</span><br><span class="line"> * 和Subscribers（订阅者）。Observables发出一系列事件，</span><br><span class="line"> * Subscribers处理这些事件</span><br><span class="line"> */</span><br><span class="line">public class HttpMethod &#123;</span><br><span class="line">    // 这个可以处理一个app中大多的网络请求了</span><br><span class="line">    public static &lt;T extends SMResponse&gt; void toSubscribe(Observable&lt;T&gt; observable, final BaseSubscriber&lt;T&gt; baseSubscriber) &#123;</span><br><span class="line">        observable.subscribeOn(Schedulers.io())</span><br><span class="line">                .retryWhen(new RetryWhenHandler(1, 5))//chongxin lianjie</span><br><span class="line">                .doOnSubscribe(new Action0() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void call() &#123;</span><br><span class="line">                        baseSubscriber.onBegin();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .subscribeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .unsubscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">                .subscribe(baseSubscriber);//绑定订阅者</span><br><span class="line">    &#125;</span><br><span class="line">    // 多个数据流，整合多个数据流的方法 调用  在第一版本 我先不讲这个这么用  如果有合适的接口调用</span><br><span class="line">//    我会把这个讲讲怎么用</span><br><span class="line">//    public static &lt;T&gt; Observable.Transformer&lt;T, T&gt; defaultHandler() &#123;</span><br><span class="line">//        return new Observable.Transformer&lt;T, T&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public Observable&lt;T&gt; call(Observable&lt;T&gt; observable) &#123;</span><br><span class="line">//                return observable</span><br><span class="line">//                        .subscribeOn(Schedulers.io())</span><br><span class="line">//                        .retryWhen(new RetryWhenHandler(1, 5))</span><br><span class="line">//                        .unsubscribeOn(Schedulers.io())</span><br><span class="line">//                        .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SMRetrofit 类是我们关键类的开始，通过这个SMRetrofit 去调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">package network.shiming.com.network.retrofit;</span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2017/4/3.</span><br><span class="line"> */</span><br><span class="line">public class SMRetrofit &#123;</span><br><span class="line">    private static SMRetrofit mRetrofit;</span><br><span class="line">    private  Context mContext;</span><br><span class="line">    //是否https的链接</span><br><span class="line">    private static  boolean mIsHttps;</span><br><span class="line">    private String mServerAddressFormal;</span><br><span class="line">    private static final int DEFAULT_TIMEOUT = 15;</span><br><span class="line">    private OkHttpClient mClient;</span><br><span class="line">    private Retrofit mBuild;</span><br><span class="line">    private SMRetrofit(Context context,boolean isHttps)&#123;</span><br><span class="line">        //为什么要取这个context的对象，因为这个生命周期比较短，百度</span><br><span class="line">        mContext = context.getApplicationContext();</span><br><span class="line">        mIsHttps = isHttps;</span><br><span class="line">        initRetrofit();</span><br><span class="line">    &#125;</span><br><span class="line">    private void initRetrofit() &#123;</span><br><span class="line">        //no https</span><br><span class="line">        mServerAddressFormal = BuildConfig.SERVER_ADDRESS_FORMAL;</span><br><span class="line">        String publishEnvironment = BuildConfig.PUBLISH_ENVIRONMENT;</span><br><span class="line">        if (mIsHttps)&#123;</span><br><span class="line">            //is https</span><br><span class="line">            mServerAddressFormal=BuildConfig.SERVER_ADDRESS_FORMAL_S;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println( &quot; host shiming &quot;+ mServerAddressFormal);</span><br><span class="line">        initRetrofit(mServerAddressFormal)；</span><br><span class="line">    &#125;</span><br><span class="line">    private void initRetrofit(String serverAddressFormal) &#123;</span><br><span class="line">        Log.i(this.getClass().getName(),&quot;serverAddress=&quot;+serverAddressFormal);</span><br><span class="line">        HttpLoggingInterceptor httpLoggingInterceptor = new HttpLoggingInterceptor();</span><br><span class="line">        Log.i(&quot;shiming &quot;,BuildConfig.DEBUG+&quot;&quot;);</span><br><span class="line">        if (!BuildConfig.DEBUG)&#123;</span><br><span class="line">            System.out.println( &quot;shiming debug log&quot;);</span><br><span class="line">            httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.BODY);</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //上线  不给日记输出</span><br><span class="line">            System.out.println( &quot;shiming &quot;+&quot; no log&quot;);</span><br><span class="line">            httpLoggingInterceptor.setLevel(HttpLoggingInterceptor.Level.NONE);</span><br><span class="line">        &#125;</span><br><span class="line">        File cache = new File(mContext.getCacheDir(), &quot;cache&quot;);</span><br><span class="line">        int cacheSize=10*1024*1024;</span><br><span class="line">        Cache cache1 = new Cache(cache, cacheSize);</span><br><span class="line">        //这里我还得说明一下 这个拦截器的原因  你比如说一个ip地址 ，用app端去访问和 pc端访问回来的数据不一样</span><br><span class="line">        //这就是拦截器的作用  比如在app的版本不同 对一个地址访问回来的数据会不一样</span><br><span class="line">        mClient = new OkHttpClient.Builder().cache(cache1)</span><br><span class="line">//              .addInterceptor(new Interceptor(mContext))//拦截器 如果项目需要的话 如果大公司的话 该死的项目经理会要求拿到用户的手机设备的信息发布渠道的东西 ，需要这里填入</span><br><span class="line">                .connectTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(DEFAULT_TIMEOUT, TimeUnit.SECONDS)</span><br><span class="line">                .addInterceptor(httpLoggingInterceptor)</span><br><span class="line">                .cookieJar(new PersistentCookieJar(new SetCookieCache(), new SharedPrefsCookiePersistor(mContext)))</span><br><span class="line">                .build();</span><br><span class="line">        mBuild = new Retrofit.Builder()</span><br><span class="line">                .baseUrl(serverAddressFormal)</span><br><span class="line">                .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">                .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">                .client(mClient)// 关联</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @return</span><br><span class="line">     * 双重锁判断 单利</span><br><span class="line">     * 由于我自己用的聚合的数据接口 我这里就默认了我这里不是https的接口</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public static SMRetrofit getInstance(Context context)&#123;</span><br><span class="line">        if (mRetrofit==null||mIsHttps)&#123;</span><br><span class="line">            synchronized (SMRetrofit.class)&#123;</span><br><span class="line">                if (mRetrofit==null||mIsHttps)&#123;</span><br><span class="line">                    mRetrofit=new SMRetrofit(context,false);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mRetrofit;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果项目中有用到的https的地方  使用这个初始化 并且在build文件去配置的你地址</span><br><span class="line">    public static SMRetrofit getInstance(Context context,boolean isHttps)&#123;</span><br><span class="line">        if (mRetrofit==null||isHttps)&#123;</span><br><span class="line">            synchronized (SMRetrofit.class)&#123;</span><br><span class="line">                if (mRetrofit==null||isHttps)&#123;</span><br><span class="line">                    mRetrofit=new SMRetrofit(context,isHttps);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return mRetrofit;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @return 真正的retorfit在这里</span><br><span class="line">     */</span><br><span class="line">    public Retrofit getBuild()&#123;</span><br><span class="line">        return mBuild;</span><br><span class="line">    &#125;</span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param servcie 真正的service在这里</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; T getService(Context context,Class&lt;T&gt; servcie)&#123;</span><br><span class="line">        return SMRetrofit.getInstance(context).getBuild().create(servcie);</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><p>调用的方法model中去调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by shiming on 2017/4/3.</span><br><span class="line"> *</span><br><span class="line"> * import rx.Observable; 注意这里的导入的是哪个包下的  不要导入了其他的安卓报下的observable了  就行了</span><br><span class="line"> */</span><br><span class="line">public class TestModel &#123;</span><br><span class="line">    private  TestService mService;</span><br><span class="line">    public TestModel(Context context)&#123;</span><br><span class="line">        mService = SMRetrofit.getService(context, TestService.class);</span><br><span class="line">    &#125;</span><br><span class="line">    public void getTaday(String cai,BaseSubscriber infos)&#123;</span><br><span class="line">        Observable&lt;SMResponse&lt;ArrayList&lt;TadayBean&gt;&gt;&gt; data = mService.getTaday(&quot;b15674dbd34ec00ded57b369dfdabd90&quot;, &quot;1.0&quot;, 4, 4);</span><br><span class="line">        HttpMethod.toSubscribe(data,infos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键的数据基类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by shiming on 2017/4/3.</span><br><span class="line"> * 保证一个类的唯一     子类自需要重写一个 uniquekey的方法 ，就可以了</span><br><span class="line"> * 为什么呢 ？ 有时候  我们传入是对象  ，我们只需要一个对象的值</span><br><span class="line"> * 但是要保证我们的对象是同一个的对象  so  你懂得</span><br><span class="line"> */</span><br><span class="line">public abstract class BaseOneBean implements Serializable&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        String[] uniqueKey = uniqueKey();</span><br><span class="line">        if (uniqueKey != null &amp;&amp; uniqueKey.length &gt; 0) &#123;</span><br><span class="line">            int result = 0;</span><br><span class="line">            for (int i = 0; i &lt; uniqueKey.length; i++) &#123;</span><br><span class="line">                String unique = uniqueKey[i];</span><br><span class="line">                if (!TextUtils.isEmpty(unique)) &#123;</span><br><span class="line">                    result = 31 * result + unique.hashCode();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (result == 0) &#123;</span><br><span class="line">                return super.hashCode();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public abstract String[] uniqueKey() ;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        String[] uniqueKey = uniqueKey();</span><br><span class="line">        if (uniqueKey != null &amp;&amp; uniqueKey.length &gt; 0) &#123;</span><br><span class="line">            BaseOneBean user = (BaseOneBean) o;</span><br><span class="line">            String[] modelKey = user.uniqueKey();</span><br><span class="line">            for (int i = 0; i &lt; uniqueKey.length; i++) &#123;</span><br><span class="line">                String unique = uniqueKey[i];</span><br><span class="line">                if (TextUtils.isEmpty(unique) || !unique.equals(modelKey[i])) &#123;</span><br><span class="line">                    return super.equals(o);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return super.equals(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类的作用，仅仅是让我们的数据bean保持唯一，在做业务比如去刷新我们的adapter的时候，我们传入的数据bean要是唯一，就必须去继承它，但是我们项目中最好去做个数据bean的管理<br>第二个重要的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class SMResponse&lt;T&gt; extends BaseOneBean &#123;</span><br><span class="line">    public T result; // TODO: 2017/4/8   这里哈哈  这里妈的最坑  这里返回的状态码 写错了，我们就拿不到数据</span><br><span class="line">    public String reason;</span><br><span class="line">    public int error_code;</span><br><span class="line">    @Override</span><br><span class="line">    public String[] uniqueKey() &#123;</span><br><span class="line">        return new String[]&#123;&quot;&quot;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个类的返回的状态的数据一定要和服务器的返回的bean正确，要不然你拿到额数据一定会为空，我一时手快把result写成了reuslt，导致我找了半天问题出现在哪里，巨难受，想哭!</p><p>##最后项目已经在git开源，欢迎star 哈哈<br><a href="https://github.com/Shimingli/Demo#demo" target="_blank" rel="noopener">https://github.com/Shimingli/Demo#demo</a></p>]]></content>
      
      
        <tags>
            
            <tag> MVP网络框架Retorfit+Rxjava+Rxandroid </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Glide图片处理框架（模糊图，倒圆角，圆形图片）</title>
      <link href="/2017/07/30/Glide%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%EF%BC%88%E6%A8%A1%E7%B3%8A%E5%9B%BE%EF%BC%8C%E5%80%92%E5%9C%86%E8%A7%92%EF%BC%8C%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%89/"/>
      <url>/2017/07/30/Glide%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86%E6%A1%86%E6%9E%B6%EF%BC%88%E6%A8%A1%E7%B3%8A%E5%9B%BE%EF%BC%8C%E5%80%92%E5%9C%86%E8%A7%92%EF%BC%8C%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="不逼逼，先看效果"><a href="#不逼逼，先看效果" class="headerlink" title="不逼逼，先看效果"></a>不逼逼，先看效果</h2><p>1、使用Glide裁剪圆形图片、圆角图片和处理模糊图片<br><img src="http://upload-images.jianshu.io/upload_images/5363507-78e54509580bcd6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>2、对本地图片处理的三种效果<br><img src="http://upload-images.jianshu.io/upload_images/5363507-548f00bd21d6d8fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-5734d40402d6d8ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a></p><p>##如何搭建图片加载框架？<br>1、肯定不能光自己爽，你要想到用到地方的可能性。<br>2、同时，代码要一目十行，一看就明白这个方法是做什么，如果别人想扩展，要很容易。<br>3、基于Glide图片加载框架，使用起来要务必方便，代码不臃肿，能够满足各种姿势，各种要求。如果不能满足，自定义起来需务必方便。</p><p>###创建依赖<br>1、这个不需多提，不要什么都放在app目录下，一定要用依赖的形式<br><img src="http://upload-images.jianshu.io/upload_images/5363507-4d191c9737376677.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>2、加入依赖<br><code>compile &#39;com.github.bumptech.glide:glide:3.6.1</code><br>3、包名结构</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-2becb7eaf8f40fe5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>a、关键接口定义：需要根据业务逻辑不断的修改，明确几点即可，哪里需要用到图片加载？Fragment中使用，Activity中使用，加载需要监听的地方，需要给与加载中或者是加载失败的图片过度，需要加载本地图片，需要对图片进行处理（圆形，倒角，模糊图等效果），反之即可定义此接口，方便以后扩展更加复杂的图片处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public interface IImageLoaderClient &#123;</span><br><span class="line">    public void init(Context context);</span><br><span class="line"></span><br><span class="line">    public void destroy(Context context);</span><br><span class="line"></span><br><span class="line">    public File getCacheDir(Context context);</span><br><span class="line"></span><br><span class="line">    public void clearMemoryCache(Context context);</span><br><span class="line"></span><br><span class="line">    public void clearDiskCache(Context context);</span><br><span class="line"></span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url);</span><br><span class="line"></span><br><span class="line">    public void getBitmapFromCache(Context context, String url, IGetBitmapListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IBitmapTransformation... transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IBitmapTransformation... transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IImageLoaderListener listener);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius);</span><br><span class="line"></span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, IGetDrawableListener listener);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, IBitmapTransformation... transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, IBitmapTransformation... transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations);</span><br><span class="line"></span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>b、需要根据业务定义自定义的接口回调,以下三个接口回调的用处是为了获取缓存中的bitmap、获取加载完成后的drawable，获取下载失败成功的回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public interface IGetBitmapListener &#123;</span><br><span class="line">    void onBitmap(Bitmap bitmap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> * 设置此皆苦是为了业务需要，一般不需要关心网络请求回来的drawable，但是业务需要切换的地方的话，需要拿到网络请求回来的drawable</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public interface IGetDrawableListener &#123;</span><br><span class="line">    void onDrawable(Drawable drawable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> * 监听图片下载进度</span><br><span class="line"> */</span><br><span class="line">public interface IImageLoaderListener &#123;</span><br><span class="line"></span><br><span class="line">    //监听图片下载错误</span><br><span class="line">    void onLoadingFailed(String url, ImageView target, Exception exception);</span><br><span class="line">   //监听图片加载成功</span><br><span class="line">    void onLoadingComplete(String url, ImageView target);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>c、主要的实现类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by shiming on 2016/10/26.</span><br><span class="line"> * des:</span><br><span class="line"> * with(Context context). 使用Application上下文，Glide请求将不受Activity/Fragment生命周期控制。</span><br><span class="line">   with(Activity activity).使用Activity作为上下文，Glide的请求会受到Activity生命周期控制。</span><br><span class="line">   with(FragmentActivity activity).Glide的请求会受到FragmentActivity生命周期控制。</span><br><span class="line">   with(android.app.Fragment fragment).Glide的请求会受到Fragment 生命周期控制。</span><br><span class="line">   with(android.support.v4.app.Fragment fragment).Glide的请求会受到Fragment生命周期控制。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class GlideImageLoaderClient implements IImageLoaderClient &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(Context context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy(Context context) &#123;</span><br><span class="line">        clearMemoryCache(context);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public File getCacheDir(Context context) &#123;</span><br><span class="line">        return Glide.getPhotoCacheDir(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearMemoryCache(Context context) &#123;</span><br><span class="line">        Glide.get(context).clearMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearDiskCache(Context context) &#123;</span><br><span class="line">        Glide.get(context).clearDiskCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url) &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;glide 不支持同步 获取缓存中 bitmap&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getBitmapFromCache(Context context, String url, final IGetBitmapListener listener) &#123;</span><br><span class="line">        Glide.with(context).load(url).asBitmap().into(new SimpleTarget&lt;Bitmap&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onResourceReady(Bitmap resource, GlideAnimation&lt;? super Bitmap&gt; glideAnimation) &#123;</span><br><span class="line">                if (listener != null) &#123;</span><br><span class="line">                    listener.onBitmap(resource);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context  上下文</span><br><span class="line">     * @param resId  id</span><br><span class="line">     * @param imageView into</span><br><span class="line">      */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        //设置缓存策略缓存原始数据</span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.SOURCE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url url</span><br><span class="line">     * @param imageView in</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param isCache 是否是缓存 如果是：缓存策略缓存原始数据  不是的话 ：缓存策略DiskCacheStrategy.NONE：什么都不缓存</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache) &#123;</span><br><span class="line">        Glide.with(context).load(url).skipMemoryCache(isCache).diskCacheStrategy(isCache ? DiskCacheStrategy.SOURCE : DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param fragment 绑定生命周期</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 使用.placeholder()方法在某些情况下会导致图片显示的时候出现图片变形的情况</span><br><span class="line">     * 这是因为Glide默认开启的crossFade动画导致的TransitionDrawable绘制异常</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).crossFade().placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param transformations bitmapTransform 方法设置图片转换</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, final IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        //由于这里bitmapTransform接受的为com.bumptech.glide.load.resource.bitmap.BitmapTransformation子类</span><br><span class="line">        //所以需要我们传入构造函数去</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes placeholder(int resourceId). 设置资源加载过程中的占位Drawable  error(int resourceId).设置load失败时显示的Drawable</span><br><span class="line">     * @param size override(int width, int height). 重新设置Target的宽高值</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).override(size.getWidth(), size.getHeight()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).override(size.getWidth(), size.getHeight()).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).skipMemoryCache(cacheInMemory).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).skipMemoryCache(cacheInMemory).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 只在需要的地方进行监听 listener 通过自定义的接口回调参数</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param listener  监听资源加载的请求状态 但不要每次请求都使用新的监听器，要避免不必要的内存申请，可以使用单例进行统一的异常监听和处理</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, final String url, final ImageView imageView, final IImageLoaderListener listener) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, final String url, final ImageView imageView, final IImageLoaderListener listener) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, final String url, final ImageView imageView, int defRes, final IImageLoaderListener listener) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, final String url, final ImageView imageView, int defRes, final IImageLoaderListener listener) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingFailed(url, imageView, e);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123;</span><br><span class="line">                listener.onLoadingComplete(url, imageView);</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 圆形图片的裁剪</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(context, new CircleBitmapTransformation(context))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(imageView.getContext(), new CircleBitmapTransformation(imageView.getContext()))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param radius 倒圆角的图片 需要传入需要radius</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(context, new RoundBitmapTransformation(imageView.getContext(), radius))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(imageView.getContext(), new RoundBitmapTransformation(imageView.getContext(), radius))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param blurRadius 模糊的程度 ，数字越大越模糊</span><br><span class="line">     * @param listener 接口回调需要拿到drawable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, final IGetDrawableListener listener) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).</span><br><span class="line">                bitmapTransform(new GlideTransform(context, new BlurBitmapTransformation(context, blurRadius))).</span><br><span class="line">                into(new SimpleTarget&lt;GlideDrawable&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onResourceReady(GlideDrawable resource, GlideAnimation&lt;? super GlideDrawable&gt; glideAnimation) &#123;</span><br><span class="line">                        if ( listener != null ) &#123;</span><br><span class="line">                            listener.onDrawable( resource );</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不需要关系此模糊图的drawable</span><br><span class="line">     * @param context</span><br><span class="line">     * @param url</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     * @param blurRadius</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        Glide.with(context).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(context, new BlurBitmapTransformation(context, blurRadius))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius) &#123;</span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.SOURCE).bitmapTransform(new GlideTransform(imageView.getContext(), new BlurBitmapTransformation(imageView.getContext(), blurRadius))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        Glide.with(fragment).load(url).diskCacheStrategy(DiskCacheStrategy.SOURCE).placeholder(defRes).error(defRes).bitmapTransform(new GlideTransform(imageView.getContext(), new BlurBitmapTransformation(imageView.getContext(), blurRadius))).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *  加载资源文件</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView) &#123;</span><br><span class="line">        Glide.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载资源文件的同时，对图片进行处理</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param transformations</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,ImageView imageView, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).transform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Glide.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).transform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 加载资源文件失败了，加载中的默认图和失败的图片</span><br><span class="line">     * @param context</span><br><span class="line">     * @param resId</span><br><span class="line">     * @param imageView</span><br><span class="line">     * @param defRes</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId, ImageView imageView, int defRes) &#123;</span><br><span class="line">        Glide.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    //关心context</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Glide.with(context).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).transform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">    //关心fragment</span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        int size = transformations.length;</span><br><span class="line">        GlideTransform[] glideTransforms = new GlideTransform[size];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">            glideTransforms[i] = new GlideTransform(transformations[i].getContext(), transformations[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        Glide.with(fragment).load(resId).diskCacheStrategy(DiskCacheStrategy.NONE).placeholder(defRes).error(defRes).transform(glideTransforms).into(imageView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>d、项目中调用的主体实现类:在此构建此类中需要注意两点（java并发编程）：<br>1、volatile 关键字：我个人理解的是：使用volatile关键字的程序在并发时能够正确执行。但是它不能够代替synchronized关键字。当初我在构建的此图片框架时，我领导说过，需加上此关键字，本人才疏学浅，能初步理解此用途，但是还是不够深入了解。但是在初期不加这个关键字，好像对图片加载并无什么影响。在网上找到这么一句话：观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；2）它会强制将对缓存的修改操作立即写入主存；3）如果是写操作，它会导致其他CPU中对应的缓存行无效。<br>2、synchronized（记得双重的判断）关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，至于那些情况我也不太明白，因为涉及到java内存模型的相关概念，抛砖引玉一下：<a href="http://www.importnew.com/18126.html" target="_blank" rel="noopener">http://www.importnew.com/18126.html</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class ImageLoader implements IImageLoaderClient &#123;</span><br><span class="line">    private volatile static ImageLoader instance;</span><br><span class="line">    private IImageLoaderClient client;</span><br><span class="line">    private ImageLoader() &#123;</span><br><span class="line">        client = new GlideImageLoaderClient();</span><br><span class="line">    &#125;</span><br><span class="line">    /***</span><br><span class="line">     * 设置 图片加载库客户端</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    public void setImageLoaderClient(Context context, IImageLoaderClient client) &#123;</span><br><span class="line">        if (this.client != null) &#123;</span><br><span class="line">            this.client.clearMemoryCache(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (this.client != client) &#123;</span><br><span class="line">            this.client = client;</span><br><span class="line">            if (this.client != null) &#123;</span><br><span class="line">                this.client.init(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static ImageLoader getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (ImageLoader.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    instance = new ImageLoader();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void init(Context context) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.destroy(context);</span><br><span class="line">            client = null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        instance = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public File getCacheDir(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            return client.getCacheDir(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearMemoryCache(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clearMemoryCache(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void clearDiskCache(Context context) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.clearDiskCache(context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmapFromCache(Context context, String url) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            return client.getBitmapFromCache(context, url);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getBitmapFromCache(Context context, String url, IGetBitmapListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.getBitmapFromCache(context, url, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, int resId, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, resId, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, boolean isCache) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView,isCache);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, ImageSize size) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, cacheInMemory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, boolean cacheInMemory) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, cacheInMemory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Context context, String url, ImageView imageView, int defRes, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(context, url, imageView, defRes, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImage(Fragment fragment, String url, ImageView imageView, int defRes, IImageLoaderListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImage(fragment, url, imageView, defRes, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Context context, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayCircleImage(context, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayCircleImage(Fragment fragment, String url, ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayCircleImage(fragment, url, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Context context, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayRoundImage(context, url, imageView, defRes, radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, int blurRadius, final IGetDrawableListener listener) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, url, blurRadius, listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayRoundImage(Fragment fragment, String url, ImageView imageView, int defRes, int radius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayRoundImage(fragment, url, imageView, defRes, radius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, url, imageView, defRes, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Context context, int resId, ImageView imageView, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(context, resId, imageView, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayBlurImage(Fragment fragment, String url, ImageView imageView, int defRes, int blurRadius) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayBlurImage(fragment, url, imageView, defRes, blurRadius);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId,  imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId,  imageView);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId, ImageView imageView, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId, imageView, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId, imageView, defRes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Context context, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(context, resId, imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void displayImageInResource(Fragment fragment, int resId,  ImageView imageView, int defRes, IBitmapTransformation... transformations) &#123;</span><br><span class="line">        if (client != null) &#123;</span><br><span class="line">            client.displayImageInResource(fragment, resId,  imageView, defRes, transformations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>##项目中的使用<br>使用的方式及其简单，一行带代码搞定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//圆形图片</span><br><span class="line">      ImageLoader.getInstance().displayCircleImage(this,&quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;,mImageView_1,R.mipmap.ic_launcher_round);</span><br><span class="line">      //圆角图片</span><br><span class="line">      ImageLoader.getInstance().displayRoundImage(this,&quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;,mImageView_2,R.mipmap.ic_launcher_round,20);</span><br><span class="line">      //模糊图片</span><br><span class="line">      ImageLoader.getInstance().displayBlurImage(this,&quot;http://imgsrc.baidu.com/imgad/pic/item/267f9e2f07082838b5168c32b299a9014c08f1f9.jpg&quot;,mImageView_3,R.mipmap.ic_launcher_round,20);</span><br><span class="line"></span><br><span class="line">      //本地图片</span><br><span class="line">      ImageLoader.getInstance().displayImageInResource(this,R.mipmap.test,mImageView_4);</span><br><span class="line">      ImageLoader.getInstance().displayImageInResource(this,R.mipmap.test,mImageView_5,new BlurBitmapTransformation(this,40));</span><br><span class="line">      ImageLoader.getInstance().displayImageInResource(this,R.mipmap.test,mImageView_6,new CircleBitmapTransformation(this));</span><br><span class="line">      ImageLoader.getInstance().displayImageInResource(this,R.mipmap.test,mImageView_6,new RoundBitmapTransformation(this,40));</span><br></pre></td></tr></table></figure></p><p>##最后，代码已上传git，欢迎提意见<br><a href="https://github.com/Shimingli/ImageLoader" target="_blank" rel="noopener">https://github.com/Shimingli/ImageLoader</a></p>]]></content>
      
      
        <tags>
            
            <tag> Glide图片处理框架（模糊图，倒圆角，圆形图片） </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>自定义PopupWindow的超强使用</title>
      <link href="/2017/05/08/%E8%87%AA%E5%AE%9A%E4%B9%89PopupWindow%E7%9A%84%E8%B6%85%E5%BC%BA%E4%BD%BF%E7%94%A8/"/>
      <url>/2017/05/08/%E8%87%AA%E5%AE%9A%E4%B9%89PopupWindow%E7%9A%84%E8%B6%85%E5%BC%BA%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="先看效果，在TitleBar上面有一个图片的控件，当点击了图片出现了一个可以扩展的PopupWindow，同时可以通过点击事件去做相对应的操作"><a href="#先看效果，在TitleBar上面有一个图片的控件，当点击了图片出现了一个可以扩展的PopupWindow，同时可以通过点击事件去做相对应的操作" class="headerlink" title="先看效果，在TitleBar上面有一个图片的控件，当点击了图片出现了一个可以扩展的PopupWindow，同时可以通过点击事件去做相对应的操作"></a>先看效果，在TitleBar上面有一个图片的控件，当点击了图片出现了一个可以扩展的PopupWindow，同时可以通过点击事件去做相对应的操作</h3><p><img src="http://upload-images.jianshu.io/upload_images/5363507-db9d38a622b9e07b.gif?imageMogr2/auto-orient/strip" alt="jdfw.gif"></p><h5 id="所需要的类的：Item-adapter-listview-还有一个管理的ExtendPopupWindow"><a href="#所需要的类的：Item-adapter-listview-还有一个管理的ExtendPopupWindow" class="headerlink" title="所需要的类的：Item adapter listview 还有一个管理的ExtendPopupWindow"></a>所需要的类的：Item adapter listview 还有一个管理的ExtendPopupWindow</h5><p><img src="http://upload-images.jianshu.io/upload_images/5363507-a6e7df4efe56894b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><a id="more"></a></p><p>###1、为了可扩展性的话，我们需要在PopupWindow中加载的是一个可以动态设置的item,其实呢，可以在item中设置过多的属性，以满足实际的项目需要（比如说，可以设置一个红点，提醒用户这里面有更新的东西），这里我只设置了一个title，就是和上面的git图中的一个文字的tiitle，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package com.example.popupwindow;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @time 2017/5/11 18:37</span><br><span class="line"> * @desc  可以扩展的item</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PopupItem &#123;</span><br><span class="line">    private String title;</span><br><span class="line">    private int tag;</span><br><span class="line"></span><br><span class="line">    public int getIcon() &#123;</span><br><span class="line">        return icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setIcon(int icon) &#123;</span><br><span class="line">        this.icon = icon;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int icon;</span><br><span class="line">    private Context context;</span><br><span class="line">    public Context getContext() &#123;</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContext(Context context) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTag() &#123;</span><br><span class="line">        return tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTag(int tag) &#123;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PopupItem(int tag, String title) &#123;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    public PopupItem(Context context,String title, int tag, int icon) &#123;</span><br><span class="line">        this(tag,title);</span><br><span class="line">        this.icon=icon;</span><br><span class="line">        this.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitle(String title) &#123;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###2、PopupMenuExtendAdapter的创建<br>1、R.layout.nim_popup_menu_list_item，layout布局，可以通过自定义，这里就是简单的使用的l，使用了ViewHolder 去管理<br>2、通过对数据的获取PopupItem item = mPopupItemList.get(position);设置layout应该显示的内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">package com.example.popupwindow;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.view.LayoutInflater;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.BaseAdapter;</span><br><span class="line">import android.widget.ImageView;</span><br><span class="line">import android.widget.TextView;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @time 2017/5/11 19:08</span><br><span class="line"> * @desc  可以动态的设置很多</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PopupMenuExtendAdapter extends BaseAdapter &#123;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    private List&lt;PopupItem&gt; mPopupItemList;</span><br><span class="line">    private final LayoutInflater mInflater;</span><br><span class="line"></span><br><span class="line">    public PopupMenuExtendAdapter(Context context, List&lt;PopupItem&gt; popupItemList) &#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">        mPopupItemList = popupItemList;</span><br><span class="line">        //通过这个方法去拿到 infalter</span><br><span class="line">        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return mPopupItemList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object getItem(int position) &#123;</span><br><span class="line">        return mPopupItemList.get(position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        ViewHolder cache;</span><br><span class="line">        if (convertView == null) &#123;</span><br><span class="line">             cache =  new ViewHolder();</span><br><span class="line">            convertView = mInflater.inflate(R.layout.nim_popup_menu_list_item, null);</span><br><span class="line">            cache.icon = (ImageView) convertView.findViewById(R.id.popup_menu_icon);</span><br><span class="line">            cache.title = (TextView) convertView.findViewById(R.id.popup_menu_title);</span><br><span class="line">            convertView.setTag(cache);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">           cache = (ViewHolder) convertView.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        PopupItem item = mPopupItemList.get(position);</span><br><span class="line">        cache.title.setText(item.getTitle());</span><br><span class="line">        if (item.getIcon() != 0) &#123;</span><br><span class="line">            cache.icon.setVisibility(View.VISIBLE);</span><br><span class="line">            cache.icon.setImageResource(item.getIcon());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cache.icon.setVisibility(View.GONE);</span><br><span class="line">        &#125;</span><br><span class="line">        // 下面代码实现数据绑定</span><br><span class="line">        return convertView;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final class ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">        public ImageView icon;</span><br><span class="line"></span><br><span class="line">        public TextView title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>###3、PopupMenuExtendListview的创建，其实也是简单的扩张了listview，对listview的宽度重新的测量，代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">package com.example.popupwindow;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.util.AttributeSet;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.view.ViewGroup;</span><br><span class="line">import android.widget.ListView;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author shiming</span><br><span class="line"> * @time 2017/5/8 19:56</span><br><span class="line"> * @desc popup  Menu  为了可以扩展 这里继承了 listview</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class PopupMenuExtendListview extends ListView &#123;</span><br><span class="line"></span><br><span class="line">    public PopupMenuExtendListview(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public PopupMenuExtendListview(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 1.View本身大小多少，这由onMeasure()决定；</span><br><span class="line">     * 2.View在ViewGroup中的位置如何，这由onLayout()决定；</span><br><span class="line">     * 3.绘制View，onDraw()定义了如何绘制这个View。</span><br><span class="line">     */</span><br><span class="line">    /**</span><br><span class="line">     * View本身大小多少，这由onMeasure()决定</span><br><span class="line">     * @param widthMeasureSpec 代模式的32 位</span><br><span class="line">     * @param heightMeasureSpec  代模式的32位</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int width = measureWidthByChilds() + getPaddingLeft() + getPaddingRight();</span><br><span class="line">        //重新的测量这个 精确的模式下面</span><br><span class="line">        super.onMeasure(MeasureSpec.makeMeasureSpec(width,MeasureSpec.EXACTLY), heightMeasureSpec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 测量listview中的孩子的宽度</span><br><span class="line">     *</span><br><span class="line">     * @return width</span><br><span class="line">     */</span><br><span class="line">    private int measureWidthByChilds() &#123;</span><br><span class="line">        int width = 0;</span><br><span class="line">        View view = null;</span><br><span class="line">        for (int i = 0; i &lt; getAdapter().getCount(); i++) &#123;</span><br><span class="line">            view = getAdapter().getView(i, view, this);</span><br><span class="line">            if (view != null) &#123;</span><br><span class="line">                //为什么要传入的是0</span><br><span class="line">                // *设置与此视图相关联的布局参数。这些供应</span><br><span class="line">                //*参数，以指定此视图应该如何</span><br><span class="line">                // *设置。有许多子viewgroup.layoutparams，这些</span><br><span class="line">                // *对应的ViewGroup负责不同的子类</span><br><span class="line">                view.setLayoutParams(new ViewGroup.LayoutParams(0, 0));</span><br><span class="line">                // MeasureSpec.UNSPECIFIED是未指定尺寸，这种情况不多，</span><br><span class="line">                // 一般都是父控件是AdapterView，通过measure方法传入的模式。</span><br><span class="line">                view.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);</span><br><span class="line">                if (view.getMeasuredWidth()&gt;width)&#123;</span><br><span class="line">                    width=view.getMeasuredWidth();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在写代码的时候如果我把view.setLayoutParams(new ViewGroup.LayoutParams(0, 0));给去掉了，只去view.measure(MeasureSpec.UNSPECIFIED, MeasureSpec.UNSPECIFIED);我会发现始终测出来的值不对，但是我也没有想通为什么要这么去设置，这个是看别人讲解，也不太明白。记得以前实现过一个动画，先要去mease（0,0）；然后去执行才不会出错，哎哎，先给个todo </p><p>###4、关键的交互类，ExtendPopupWindow详情<br>1、构造方法传入参数,MenuItemClickListener是内部的接口，专门是做来点击的事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//当扩张到一定的地步是不是可以滑动</span><br><span class="line">  private boolean scroll = false;</span><br><span class="line">  public ExtendPopupWindow(Context context, List&lt;PopupItem&gt; items,  MenuItemClickListener listener) &#123;</span><br><span class="line">      this(context,items,false,listener);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public ExtendPopupWindow(Context context, List&lt;PopupItem&gt; items,  boolean scroll, MenuItemClickListener listener) &#123;</span><br><span class="line">      this.context = context;</span><br><span class="line">      this.items = items;</span><br><span class="line">      this.scroll = scroll;</span><br><span class="line">      this.listener = listener;</span><br><span class="line">      init();</span><br><span class="line">  &#125;</span><br><span class="line">public interface MenuItemClickListener &#123;</span><br><span class="line">       void onItemClick(PopupItem item);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>2、init()方法做什么</p><p>第一步初始化我们的rootview<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">if (rootView == null) &#123;</span><br><span class="line">         rootView = LayoutInflater.from(context).inflate(R.layout.nim_popup_menu_layout, null);</span><br><span class="line">         ListView listView = (ListView) rootView.findViewById(R.id.popmenu_listview);</span><br><span class="line">         listView.setOnItemClickListener(new AdapterView.OnItemClickListener() &#123;</span><br><span class="line"></span><br><span class="line">             @Override</span><br><span class="line">             public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123;</span><br><span class="line">                 if (listener != null) &#123;</span><br><span class="line">                     popWindow.dismiss();</span><br><span class="line">                     listener.onItemClick(items.get(position));</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">         adapter = new PopupMenuExtendAdapter(context, items);</span><br><span class="line">         listView.setAdapter(adapter);</span><br><span class="line">     &#125;</span><br><span class="line">     // focusableInTouchMode.这个属性的意思一如字面所述,就是在进入触摸输入模式后,该控件是否还有获得焦点的能力.</span><br><span class="line">     // 可以简单的理解为,用户一旦开始通过点击屏幕的方式输入,手机就进入了&quot;touch mode&quot;.</span><br><span class="line">     // focusableInTouchMode这种属性,多半是设给EditText这种即使在TouchMode下,依然需要获取焦点的控件</span><br><span class="line">     rootView.setFocusableInTouchMode(true);</span><br><span class="line">     //监听返回的按钮，然后 隐藏pop</span><br><span class="line">     rootView.setOnKeyListener(new View.OnKeyListener() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public boolean onKey(View v, int keyCode, KeyEvent event) &#123;</span><br><span class="line">             if (keyCode == KeyEvent.KEYCODE_MENU &amp;&amp; popWindow.isShowing()</span><br><span class="line">                     &amp;&amp; event.getAction() == KeyEvent.ACTION_DOWN) &#123;</span><br><span class="line">                 popWindow.dismiss();</span><br><span class="line">                 return true;</span><br><span class="line">             &#125;</span><br><span class="line">             return false;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br></pre></td></tr></table></figure></p><p>以上的rootview其实是一个layout的高度为15dp，其中嵌套了一个我们封装的popupwindow的listview，在给他设置了一个setOnKeyListener监听，判断了按下rootview，判断三种情况的成立的话pupwindow就必须的dismiss掉，KEYCODE_MENU其实就是早期的菜单键，return true；表示拦截这个操作</p><p>第二步做什么：初始化我们popwindow<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//初始化我们的popuwindow</span><br><span class="line">      if (popWindow == null) &#123;</span><br><span class="line">          popWindow = new PopupWindow(context);</span><br><span class="line">          popWindow.setContentView(rootView);</span><br><span class="line">          popWindow.setWidth(WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">          if (scroll) &#123;</span><br><span class="line">              popWindow.setHeight(context.getApplicationContext().getResources().getDisplayMetrics().heightPixels * 2 / 3);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              popWindow.setHeight(WindowManager.LayoutParams.WRAP_CONTENT);</span><br><span class="line">          &#125;</span><br><span class="line">          popWindow.setTouchable(true);</span><br><span class="line">          popWindow.setBackgroundDrawable(new BitmapDrawable());</span><br><span class="line">          popWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void onDismiss() &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>以上需要说明的是： popWindow.setBackgroundDrawable(new BitmapDrawable());我们要给他一个bitmap，要不然会有问题，安卓有很多的地方有这个需求，估计理解为安卓的内部的毛病。</p><p>####假想个问题，这既然是一个交互的类，那么我们还需要做什么，好吧，我也咩想到，想到，最后看别人的代码，哈哈…………</p><p>#####数据的交互，有adapter的对吧，so,暴露方法告诉adapter的数据变了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void notifyData() &#123;</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>#####pop不可能在初始化页面了，就开始显示了吧，so，砸门的控制show()，判null,是否showing,这里有个关键的东西，我们设置了可以滑动，同时要判断一下我们设备的屏幕的方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if (popWindow == null) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     if (popWindow.isShowing()) &#123;</span><br><span class="line">         popWindow.dismiss();</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">         if (scroll) &#123;// 当可以滚动时，横竖屏切换时，重新确定高度</span><br><span class="line">             Configuration configuration = context.getResources().getConfiguration();</span><br><span class="line">             int ori = configuration.orientation;</span><br><span class="line">             if (ori == Configuration.ORIENTATION_LANDSCAPE) &#123;</span><br><span class="line">                 popWindow.setHeight(context.getApplicationContext().getResources().getDisplayMetrics().widthPixels* 2 / 3);</span><br><span class="line">             &#125; else &#123;</span><br><span class="line">                 popWindow.setHeight(context.getApplicationContext().getResources().getDisplayMetrics().heightPixels  * 2 / 3);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         popWindow.setFocusable(true);</span><br><span class="line">         popWindow.showAsDropDown(v, -10, 0);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>####Configuration类专门描述手机设备上的配置信息，这些配置信息既包括用户特定的配置项，也包括系统的动态设备配置。  int ori = configuration.orientation;判断是否是横竖屏，我记得没错的话，横竖屏的话，我们的activity是需要重新的走生命周期，只有onnewintent的这个才不会走，是横的话，为了显示的更加人性化，我们要横的2/3。    popWindow.showAsDropDown(v, -10, 0);显示在哪个控件下面，这个v是我们的控件iew，偏移了-10.y没有动，这些可以动态的设置</p><p>  ###5、Activity中的代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">package com.example.popupwindow;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.os.Bundle;</span><br><span class="line">import android.support.v7.app.AppCompatActivity;</span><br><span class="line">import android.view.View;</span><br><span class="line">import android.widget.Toast;</span><br><span class="line"></span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private ArrayList&lt;PopupItem&gt; menuItemList;</span><br><span class="line">    private ExtendPopupWindow popupMenu;</span><br><span class="line">    private View mImg;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mImg = findViewById(R.id.img);</span><br><span class="line">        mImg.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                initPopuptWindow(MainActivity.this, mImg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 窗体泄漏造成的原因，是我们的view虽然已经有了这个，但是我们在没有通过点击事件</span><br><span class="line">     * 或者其他的动作，去开启这个popwindow的话，我们的窗体就会泄漏</span><br><span class="line">     * 哈哈</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void onResume() &#123;</span><br><span class="line">        super.onResume();</span><br><span class="line">//        initPopuptWindow(this, mImg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initPopuptWindow(Context context, View view) &#123;</span><br><span class="line">        if (popupMenu == null) &#123;</span><br><span class="line">            menuItemList = new ArrayList&lt;&gt;();</span><br><span class="line">            popupMenu = new ExtendPopupWindow(context, menuItemList, listener);</span><br><span class="line">        &#125;</span><br><span class="line">        menuItemList.clear();</span><br><span class="line">        menuItemList.addAll(getMoreMenuItems(context));</span><br><span class="line">        popupMenu.notifyData();</span><br><span class="line">        popupMenu.show(view);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static List&lt;PopupItem&gt; getMoreMenuItems(Context context) &#123;</span><br><span class="line">        List&lt;PopupItem&gt; moreMenuItems = new ArrayList&lt;PopupItem&gt;();</span><br><span class="line">        moreMenuItems.add(new PopupItem(context,</span><br><span class="line">                &quot;feiji  0&quot;, 1,0));</span><br><span class="line">        moreMenuItems.add(new PopupItem(context,</span><br><span class="line">                &quot;feiji  1&quot;, 2,0));</span><br><span class="line">        moreMenuItems.add(new PopupItem(context,</span><br><span class="line">                &quot;feiji  2&quot;, 3,0));</span><br><span class="line">        moreMenuItems.add(new PopupItem(context,</span><br><span class="line">                &quot;feiji  3&quot;, 4,0));</span><br><span class="line">        return moreMenuItems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ExtendPopupWindow.MenuItemClickListener listener = new ExtendPopupWindow.MenuItemClickListener() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onItemClick(final PopupItem item) &#123;</span><br><span class="line">            switch (item.getTag()) &#123;</span><br><span class="line">                case 1:</span><br><span class="line">                    Toast.makeText(MainActivity.this, &quot;feiji  0&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                case 2:</span><br><span class="line">                    Toast.makeText(MainActivity.this, &quot;feiji  1&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                case 3:</span><br><span class="line">                    Toast.makeText(MainActivity.this, &quot;feiji  2&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                case 4:</span><br><span class="line">                    Toast.makeText(MainActivity.this, &quot;feiji  3&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上只说明一点：popupWindow，不可能在初始化就显示了，只能通过事件来显示，要不然会报错窗体泄漏</p><p>#谢谢 ！</p><p>###github地址：<a href="https://github.com/Shimingli/PopupWindow" target="_blank" rel="noopener">https://github.com/Shimingli/PopupWindow</a></p>]]></content>
      
      
        <tags>
            
            <tag> PopupWindow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity的转场动画效果</title>
      <link href="/2017/05/02/Activity%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
      <url>/2017/05/02/Activity%E7%9A%84%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/</url>
      <content type="html"><![CDATA[<p>前些天无意中看到了微信的广告的效果，本想自己实现一下这种效果，点开图片，图片放大，然后在另外一个的Activity中显示，就好像是通过一个图片动画，动画结束完了，开启一个界面，但是实际上这是安卓的转场动画。<br><img src="http://upload-images.jianshu.io/upload_images/5363507-c9af3c7a7fd737ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><h3 id="转场动画很早就有了，但是由于fragment的使用，所以在activity的交互没有那么多，导致以前自己没有认真的接触到。"><a href="#转场动画很早就有了，但是由于fragment的使用，所以在activity的交互没有那么多，导致以前自己没有认真的接触到。" class="headerlink" title="转场动画很早就有了，但是由于fragment的使用，所以在activity的交互没有那么多，导致以前自己没有认真的接触到。"></a>转场动画很早就有了，但是由于fragment的使用，所以在activity的交互没有那么多，导致以前自己没有认真的接触到。</h3><p>##通过xml做转场动画<br><a id="more"></a><br>1、代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">startActivity(new Intent(MainActivity.this, Main2Activity.class));</span><br><span class="line">                /**</span><br><span class="line">                 * in 的动画是第二个activity （）进入的动画，out是第一个activity finish（）的动画</span><br><span class="line">                 * 如果两个时间不一样的话，这就会导致一种翻书的效果，in out的动画是从下往上的动画</span><br><span class="line">                 */</span><br><span class="line"> overridePendingTransition(R.anim.in,R.anim.out);</span><br></pre></td></tr></table></figure></p><p>2、R.anim.in中的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">     android:fillAfter=&quot;false&quot;</span><br><span class="line">    &gt;</span><br><span class="line">   &lt;!--   android:fillAfter=&quot;true&quot;主要是在加这一属性的时候必须加在&lt;set&gt;标签这里才起作用</span><br><span class="line">   这一属性在xml中设置使动画保持在播放的最后一帧不起作用</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;!-- XML中</span><br><span class="line">    alpha</span><br><span class="line">    渐变透明度动画效果</span><br><span class="line">    scale</span><br><span class="line">    渐变尺寸伸缩动画效果</span><br><span class="line">    translate</span><br><span class="line">    画面转换位置移动动画效果</span><br><span class="line">    rotate</span><br><span class="line">    画面转移旋转动画效果--&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 0.1透明  1.0完全不透明</span><br><span class="line">          fromAlpha 属性为动画起始时透明度</span><br><span class="line">          toAlpha   属性为动画结束时透明度</span><br><span class="line">            说明:</span><br><span class="line">               0.0表示完全透明</span><br><span class="line">                1.0表示完全不透明</span><br><span class="line">       以上值取0.0-1.0之间的float数据类型的数字</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;!-- &lt;alpha</span><br><span class="line">        android:fromAlpha=&quot;0.1&quot;</span><br><span class="line">        android:toAlpha=&quot;1.0&quot;</span><br><span class="line">        android:duration=&quot;3000&quot;</span><br><span class="line">        /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--    &lt;translate</span><br><span class="line">        android:toYDelta=&quot;0&quot;</span><br><span class="line">        android:fromYDelta=&quot;100%&quot;</span><br><span class="line">        android:duration=&quot;1500&quot;/&gt;--&gt;</span><br><span class="line"></span><br><span class="line">   &lt;!-- 有三种动画插入器:</span><br><span class="line">    accelerate_decelerate_interpolator  加速-减速 动画插入器</span><br><span class="line">    accelerate_interpolator        加速-动画插入器</span><br><span class="line">    decelerate_interpolator        减速- 动画插入器</span><br><span class="line">    其他的属于特定的动画效果</span><br><span class="line">    浮点型值：</span><br><span class="line">    fromXScale 属性为动画起始时 X坐标上的伸缩尺寸</span><br><span class="line">    toXScale   属性为动画结束时 X坐标上的伸缩尺寸</span><br><span class="line">    fromYScale 属性为动画起始时Y坐标上的伸缩尺寸</span><br><span class="line">    toYScale   属性为动画结束时Y坐标上的伸缩尺寸</span><br><span class="line">    startOffset  属性为从上次动画停多少时间开始执行下个动画</span><br><span class="line"></span><br><span class="line">    说明:</span><br><span class="line">    以上四种属性值</span><br><span class="line">    0.0表示收缩到没有</span><br><span class="line">    1.0表示正常无伸缩</span><br><span class="line">    值小于1.0表示收缩</span><br><span class="line">    值大于1.0表示放大</span><br><span class="line">    pivotX     属性为动画相对于物件的X坐标的开始位置</span><br><span class="line">    pivotY     属性为动画相对于物件的Y坐标的开始位置</span><br><span class="line">    说明:</span><br><span class="line">    以上两个属性值 从0%-100%中取值</span><br><span class="line">    50%为物件的X或Y方向坐标上的中点位置</span><br><span class="line">    长整型值：</span><br><span class="line">    duration  属性为动画持续时间</span><br><span class="line">    说明:   时间以毫秒为单位</span><br><span class="line">    布尔型值:</span><br><span class="line">    fillAfter 属性 当设置为true ，该动画转化在动画结束后被应用--&gt;</span><br><span class="line">  &lt;!--  &lt;scale</span><br><span class="line">        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class="line">        android:fromXScale=&quot;0.0&quot;</span><br><span class="line">        android:toXScale=&quot;1.4&quot;</span><br><span class="line">        android:fromYScale=&quot;0.0&quot;</span><br><span class="line">        android:toYScale=&quot;1.4&quot;</span><br><span class="line">        android:pivotX=&quot;50%&quot;</span><br><span class="line">        android:startOffset=&quot;700&quot;</span><br><span class="line">        android:pivotY=&quot;50%&quot;</span><br><span class="line">        android:duration=&quot;700&quot; /&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;rotate</span><br><span class="line">        android:interpolator=&quot;@android:anim/accelerate_decelerate_interpolator&quot;</span><br><span class="line">        android:fromDegrees=&quot;0&quot;</span><br><span class="line">        android:toDegrees=&quot;+350&quot;</span><br><span class="line">        android:pivotX=&quot;50%&quot;</span><br><span class="line">        android:pivotY=&quot;50%&quot;</span><br><span class="line">        android:duration=&quot;3000&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- rotate 旋转动画效果</span><br><span class="line">       属性：interpolator 指定一个动画的插入器</span><br><span class="line">             在我试验过程中，使用android.res.anim中的资源时候发现</span><br><span class="line">             有三种动画插入器:</span><br><span class="line">                accelerate_decelerate_interpolator   加速-减速 动画插入器</span><br><span class="line">                accelerate_interpolator               加速-动画插入器</span><br><span class="line">                decelerate_interpolator               减速- 动画插入器</span><br><span class="line">             其他的属于特定的动画效果</span><br><span class="line"></span><br><span class="line">       浮点数型值:</span><br><span class="line">            fromDegrees 属性为动画起始时物件的角度</span><br><span class="line">            toDegrees   属性为动画结束时物件旋转的角度 可以大于360度</span><br><span class="line">            说明:    当角度为负数——表示逆时针旋转</span><br><span class="line">                     当角度为正数——表示顺时针旋转</span><br><span class="line">                     (负数from——to正数:顺时针旋转)</span><br><span class="line">                     (负数from——to负数:逆时针旋转)</span><br><span class="line">                     (正数from——to正数:顺时针旋转)</span><br><span class="line">                     (正数from——to负数:逆时针旋转)</span><br><span class="line">            pivotX     属性为动画相对于物件的X坐标的开始位置</span><br><span class="line">            pivotY     属性为动画相对于物件的Y坐标的开始位置</span><br><span class="line">            说明:        以上两个属性值 从0%-100%中取值</span><br><span class="line">                         50%为物件的X或Y方向坐标上的中点位置</span><br><span class="line">        长整型值：</span><br><span class="line">            duration  属性为动画持续时间</span><br><span class="line">            说明:       时间以毫秒为单位  --&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p>xml的动画有这四种的动画注意这个android:fillAfter=”true”的使用情况<br>3、R.anim.out中的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;</span><br><span class="line">    &lt;translate</span><br><span class="line">        android:duration=&quot;5000&quot;</span><br><span class="line">        android:fromYDelta=&quot;0&quot;</span><br><span class="line">        android:toYDelta=&quot;-100%&quot;/&gt;</span><br><span class="line">&lt;/set&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-890f8aa407adb948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>###以上是很早的activity的转场的动画实现，当然也可以使用属性动画</p><p>##在api21后谷歌提供了另外一种方式的转场动画<br>5.0之后的转场动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            //分解，把一个activity分解成为两部分的，进入</span><br><span class="line">//            getWindow().setEnterTransition(new Explode().setDuration(2000));</span><br><span class="line">//            getWindow().setExitTransition(new Explode().setDuration(2000));</span><br><span class="line">            //滑动进入</span><br><span class="line">//            getWindow().setEnterTransition(new Slide().setDuration(2000));</span><br><span class="line">//            getWindow().setExitTransition(new Slide().setDuration(2000));</span><br><span class="line">           //淡入淡出</span><br><span class="line">//            getWindow().setEnterTransition(new Fade().setDuration(2000));</span><br><span class="line">//            getWindow().setExitTransition(new Fade().setDuration(2000));</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>就是在v21的包下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 表示激活Activity中元素的过渡效果 ：  &lt;item name=&quot;android:windowContentTransitions&quot;&gt;true&lt;/item&gt;</span><br><span class="line">   --&gt;</span><br></pre></td></tr></table></figure></p><p>这个styles的建立的方式，把上面的代码加入到styles中，那么安卓studio就会提示你建立这个v21的文件<br><img src="http://upload-images.jianshu.io/upload_images/5363507-c66f7fd89878c2ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>styles中的详情！<br><img src="http://upload-images.jianshu.io/upload_images/5363507-fb0fd8cba9637c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>##共享元素(微信图片广告效果)<br>在MainActivity和Main2Activity里边都有一个ImageView，只不过一个大一个小，从MainActivity跳转到Main2Activity时，我并没有感觉到Activity的跳转，只是觉得好像第一个页面的ImageView放大了，同理，当我从第二个页面回到第一个页面时，也好像ImageView变小了。OK，这就是我们的Activity共享元素。</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-b45037d92f5b3c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>第一个activity点击图片跳转到第二个activity时候动画<br><img src="http://upload-images.jianshu.io/upload_images/5363507-12894796adf9780a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>代码实现如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final ImageView imageview = (ImageView) findViewById(R.id.imgview);</span><br><span class="line">  imageview.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void onClick(View v) &#123;</span><br><span class="line">          if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">              startActivity(new Intent(MainActivity.this,Main2Activity.class), ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,imageview,&quot;imageview&quot;).toBundle());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p> ActivityOptions.makeSceneTransitionAnimation(MainActivity.this,imageview,”imageview”)。其中的三个参数，可能需要明白第三个参数是什么？其实就是在xml中设置一项属性  android:transitionName=”imageview”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:id=&quot;@+id/imgview&quot;</span><br><span class="line">    android:layout_width=&quot;200dp&quot;</span><br><span class="line">    android:scaleType=&quot;fitXY&quot;</span><br><span class="line">    android:layout_height=&quot;200dp&quot;</span><br><span class="line">    android:layout_centerHorizontal=&quot;true&quot;</span><br><span class="line">    android:src=&quot;@mipmap/ic_launcher&quot;</span><br><span class="line">    android:transitionName=&quot;imageview&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure></p><p>Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP<br>以上就能实现微信跳转的效果了（但是必须是api21上的才能实现）</p><p>###Demo的地址<br><a href="https://github.com/Shimingli/AnimationDemo" target="_blank" rel="noopener">https://github.com/Shimingli/AnimationDemo</a></p>]]></content>
      
      
        <tags>
            
            <tag> Activity的转场动画效果 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何用AndroidStudio查看和解决OOM</title>
      <link href="/2017/04/17/%E5%A6%82%E4%BD%95%E7%94%A8AndroidStudio%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%A7%A3%E5%86%B3OOM/"/>
      <url>/2017/04/17/%E5%A6%82%E4%BD%95%E7%94%A8AndroidStudio%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%A7%A3%E5%86%B3OOM/</url>
      <content type="html"><![CDATA[<h2 id="1、什么是oom"><a href="#1、什么是oom" class="headerlink" title="1、什么是oom"></a>1、什么是oom</h2><p> 一句话：c++ 中内存的泄漏指定的new出来的对象 ，没有delete掉，变成了空指针.java中指的是new出来的对象放在heap上，无法GC。安卓中的四种引用（强引用就是我报oom，也不会让你gc我，软引用是，空间不够的话，gc自己，弱引用是在gc 的时候，不管你的空间是不是不够，都可以gc，虚引用随时都可以gc）</p><blockquote><h4 id="为什么要性能优化"><a href="#为什么要性能优化" class="headerlink" title="为什么要性能优化"></a>为什么要性能优化</h4><p>Android每一个应用都是运行的独立的Dalivk虚拟机，根据不同的手机分配的可用内存可能只有（32M、64M等），所谓的4GB、6GB运行内存其实对于我们的应用不是可以任意索取<br>优秀的算法与效率低下的算法之间的运行效率要远远超过计算机硬件的的发展，虽然手机单核、双核到4核、8核的发展，但性能优化任然不可忽略<br>现在一般的用户都不会重启手机，可能一个月都不会重启。像微信这样的APP，每天都在使用。如果一旦发生内存泄漏，那么可能一点一点的累积，程序就会出现OOM。</p></blockquote><a id="more"></a><p>##2、常见的安卓oom</p><p>1、adapter没有使用缓存的convertview（listview）</p><p>2、bitmap对象没有被 recycle（）掉在源码中有一句话是 </p><p>since the normal GC percess will free up this mermory   意思就是你要主动调用这个方法才会释放内存</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-08e192da2e1de089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>3、context使用不正确，不要对activity context保持长生命周期的引用，竟可能使用applicationcontext代替  context的地方进行替换。</p><p>4、数据库的 cursor必须手动的关闭，流对象的关闭、webview的销毁。   </p><p>5、注册了系统的服务，但onDestory未注销</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//注册了系统的服务</span><br><span class="line">SensorManager sensorManager = getSystemService(SENSOR_SERVICE);</span><br><span class="line">Sensor sensor = sensorManager.getDefaultSensor(Sensor.TYPE_ALL);</span><br><span class="line">sensorManager.registerListener(this,sensor,SensorManager.SENSOR_DELAY_FASTEST);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//不需要用的时候记得移除监听</span><br><span class="line">    sensorManager.unregisterListener(listener);</span><br></pre></td></tr></table></figure><p>6、还用一种的情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//add监听，放到集合里面</span><br><span class="line">    tv.getViewTreeObserver().addOnWindowFocusChangeListener(new ViewTreeObserver.OnWindowFocusChangeListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onWindowFocusChanged(boolean b) &#123;</span><br><span class="line">            //监听view的加载，view加载出来的时候，计算他的宽高等。</span><br><span class="line">            //  在这里必须要注销，要不然会内存溢出</span><br><span class="line">              //计算完后，一定要移除这个监听</span><br><span class="line">            tv.getViewTreeObserver().removeOnWindowFocusChangeListener(this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>##3、<strong>jvm</strong><br>静态的</p><blockquote><p>静态的存储区，内存在程序编译的时候就已经分配好了，这块内存在程序整个运行期间都一直存在，它主要存放静态数据、全局的static数据和一些常量。</p></blockquote><p>栈式的</p><blockquote><p>在执行方法时，方法一些内部变量的存储都可以放在栈上面创建，方法执行结束的时候这些存储单元就会自动被注释掉。栈 内存包括分配的运算速度很快，因为内在在处理器里面。当然容量有限，并且栈式一块连续的内存区域，大小是由操作系统决定的，他先进后 出，进出完成不会产生碎片，运行效率高且稳定</p></blockquote><p>堆式的</p><blockquote><p>也叫动态内存 。我们通常使用new 来申请分配一个内存。这里也是我们讨论内存泄漏优化的关键存储区。GC会根据内存的使用情况，对堆内存里的垃圾内存进行回收。堆内存是一块不连续的内存区域，如果频繁地new/remove会造成大量的内存碎片，GC频繁的回收，导致内存抖动，这也会消耗我们应用的性能<br>我们知道可以调用 System.gc();进行内存回收，但是GC不一定会执行。面对GC的机制，我们是否无能为力？其实我们可以通过声明一些引用标记来让GC更好对内存进行回收。</p></blockquote><p>类型    回收时机    生命周期</p><blockquote><p>StrongReference （强引用）    任何时候GC是不能回收他的，哪怕内存不足时，系统会直接抛出异常OutOfMemoryError，也不会去回收    进程终止<br>SoftReference （软引用）    当内存足够时不会回收这种引用类型的对象，只有当内存不够用时才会回收    内存不足，进行GC的时候<br>WeakReference （弱引用）    GC一运行就会把给回收了    GC后终止<br>PhantomReference (虚引用)    如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收    任何时候都有可能<br>开发时，为了防止内存溢出，处理一些比较占用内存并且生命周期长的对象时，可以尽量使用软引用和弱引用。</p></blockquote><hr><p>##4、内存泄漏的定义</p><p>当一个对象已经不需要使用了，本该被回收时，而有另外一个正在使用的对象持有它的引用，从而导致了对象不能被GC回收。这种导致了本该被回收的对象不能被回收而停留在堆内存中，就产生了内存泄漏</p><p>内存泄漏与内存溢出的区别</p><hr><p>内存泄漏（Memory Leak）<br>进程中某些对象已经没有使用的价值了，但是他们却还可以直接或间接地被引用到GC Root导致无法回收。当内存泄漏过多的时候，再加上应用本身占用的内存，日积月累最终就会导致内存溢出OOM</p><p>内存溢出（OOM）<br>当 应用的heap资源超过了Dalvik虚拟机分配的内存就会内存溢出</p><hr><p>内存泄漏带来的影响</p><p>应用卡顿<br>泄漏的内存影响了GC的内存分配，过多的内存泄漏会影响应用的执行效率</p><p>应用异常（OOM）<br>过多的内存泄漏，最终会导致 Dalvik分配的内存，出现OOM</p><p>##5、如何使用安卓是studio的工具查看内存溢出</p><p>####第一种情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   //泄漏 activity 最简单的方法就是在 activity 类中定义一个 static 变量，并且将其指向一个运行中的 activity 实例。</span><br><span class="line">    // 如果在 activity 的生命周期结束之前，没有清除这个引用，那它就会泄漏了。这是因为 activity</span><br><span class="line">    // （例如 MainActivity） 的类对象是静态的，一旦加载，就会在 APP 运行时一直常驻内存，</span><br><span class="line">    // 因此如果类对象不卸载，其静态成员就不会被垃圾回收。</span><br><span class="line">    public static MainActivity mMainActivity;</span><br><span class="line">       @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">                mMainActivity = this;</span><br><span class="line">                Intent intent = new Intent(this, TwoActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                finish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原理就是简单的点击事件，同时在这个对象为一个静态的持有static的变量，开启第二个activity的时候，这个activity关闭掉</p><p>通过monitors查看</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-2cc8e8e8f9e5f749.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>然后出现了</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-c0271c13c309b3d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-9abb0e1d3652af49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>通过点击上面的额package tree view 进入到我们自己创建的类</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-043e569635edeea3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>会发现一个有趣的现象，mainactivity不是已经销毁了，为什么在java heap中还看的到？</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-5b70b55f99a4961c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>原来是我们的变量mMainActivity中还持有activity的对象 ，虽然我们的activity的ondestory的方法已经走了，但是实际在内存中是没有销毁的，所以这里就有oom的可能，进入相对应的activity</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-ab69df31832cfcb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>真的发现是这样，这就可以通过这种方式发现了oom的可能了</p><p>通过Memory Usage去发现我们activity在内存中存在多少<br><img src="http://upload-images.jianshu.io/upload_images/5363507-73772fe00a35c1b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>我们第一步知道，我们开了两个activity，开启第二个的activity的时候，我们的第一个activity已经finish（）；所以内存中存在一个activity<br>But  看图</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-0afafcbc27fc7397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>我擦，是不是我眼睛瞎了，咋还有两个activity呢？对，就是怎么神奇，你即使finish掉了，但是在内存中还是存在的，所以必须处理，要不然以后的应用有崩掉的可能性</p><p>####第二种情况:view持有static<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    //view 持有静态的变量</span><br><span class="line">//    view 被加入到界面中，它就会持有 context 的强引用，也就是我们的 activity。</span><br><span class="line">// 由于我们通过一个静态成员引用了这个 view，</span><br><span class="line">//    所以我们也就引用了 activity，因此 activity 就发生了泄漏。</span><br><span class="line">//    所以一定不要把加载的 view 赋值给静态变量，如果你真的需要，那一定要确保在 activity 销毁之前将其从 view 层级中移除。</span><br><span class="line">    private static View mView;</span><br><span class="line">    mView = findViewById(R.id.btn_goto_two_activity);</span><br></pre></td></tr></table></figure></p><p>####第三种情况：单利<br>当调用getmUtils时，如果传入的context是Activity的context。只要这个单例没有被释放，那么这个Activity也不会被释放一直到进程退出才会释放。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class TestUtils &#123;</span><br><span class="line">    private static  TestUtils mUtils;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    private TestUtils(Context context)&#123;</span><br><span class="line">        mContext=context;</span><br><span class="line">    &#125;</span><br><span class="line">    public static TestUtils getmUtils(Context context)&#123;</span><br><span class="line">        if (mUtils!=null)&#123;</span><br><span class="line">            mUtils=new TestUtils(context);</span><br><span class="line">        &#125;</span><br><span class="line">        return mUtils;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>能使用Application的Context就不要使用Activity的Content，Application的生命周期伴随着整个进程的周期</p><p>####第四种情况：handler泄漏<br>mHandler是Handler的非静态匿名内部类的实例，所以它持有外部类Activity的引用，我们知道消息队列是在一个Looper线程中不断轮询处理消息，那么当这个Activity退出时消息队列中还有未处理的消息或者正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity的内存资源无法及时回收，引发内存泄漏。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">    private TextView mTextView ;</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; reference;</span><br><span class="line">        public MyHandler(Context context) &#123;</span><br><span class="line">            reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            if(activity != null)&#123;</span><br><span class="line">                activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadData() &#123;</span><br><span class="line"></span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>解决的方法</p><p>创建一个静态Handler内部类，然后对Handler持有的对象使用弱引用，这样在回收时也可以回收Handler持有的对象，这样虽然避免了Activity泄漏，不过Looper线程的消息队列中还是可能会有待处理的消息，所以我们在Activity的Destroy时或者Stop时应该移除消息队列中的消息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> private MyHandler mHandler = new MyHandler(this);</span><br><span class="line">    private TextView mTextView ;</span><br><span class="line">    private static class MyHandler extends Handler &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; reference;</span><br><span class="line">        public MyHandler(Context context) &#123;</span><br><span class="line">            reference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            MainActivity activity = (MainActivity) reference.get();</span><br><span class="line">            if(activity != null)&#123;</span><br><span class="line">                activity.mTextView.setText(&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mTextView = (TextView)findViewById(R.id.textview);</span><br><span class="line">        loadData();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void loadData() &#123;</span><br><span class="line">        //...request</span><br><span class="line">        Message message = Message.obtain();</span><br><span class="line">        mHandler.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        mHandler.removeCallbacksAndMessages(null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####第五种情况：线程造成的内存泄漏<br>异步任务和Runnable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成， 那么将导致Activity的内存资源无法回收，造成内存泄漏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">new AsyncTask&lt;Void, Void, Void&gt;() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         protected Void doInBackground(Void... params) &#123;</span><br><span class="line">             SystemClock.sleep(10000);</span><br><span class="line">             return null;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;.execute();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     new Thread(new Runnable() &#123;</span><br><span class="line">         @Override</span><br><span class="line">         public void run() &#123;</span><br><span class="line">             SystemClock.sleep(10000);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;).start();</span><br></pre></td></tr></table></figure></p><p>解决的方法：尽量的使用静态的内部类<br>使用 静态内部类，避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123;</span><br><span class="line">        private WeakReference&lt;Context&gt; weakReference;</span><br><span class="line"></span><br><span class="line">        public MyAsyncTask(Context context) &#123;</span><br><span class="line">            weakReference = new WeakReference&lt;&gt;(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Void doInBackground(Void... params) &#123;</span><br><span class="line">            SystemClock.sleep(10000);</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected void onPostExecute(Void aVoid) &#123;</span><br><span class="line">            super.onPostExecute(aVoid);</span><br><span class="line">            MainActivity activity = (MainActivity) weakReference.get();</span><br><span class="line">            if (activity != null) &#123;</span><br><span class="line">                //...</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    static class MyRunnable implements Runnable&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            SystemClock.sleep(10000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">//——————</span><br><span class="line">    new Thread(new MyRunnable()).start();</span><br><span class="line">    new MyAsyncTask(this).execute();</span><br></pre></td></tr></table></figure></p><p>####第六种的情况:资源未关闭造成的内存泄漏</p><p>对于使用了BraodcastReceiver，ContentObserver，File，Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏</p><p>解决：在Activity销毁时及时关闭或者注销</p><p>####第七种情况：使用静态的方法</p><p><img src="http://upload-images.jianshu.io/upload_images/5363507-418e0f47c02ba722.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br>比如说我在一个activity开启一个dialog的方法，那么持有这个变量context<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">   private static BaseDialog baseDialog;</span><br><span class="line">    public static void sendVideo(Context context) &#123;</span><br><span class="line">        baseDialog = new BaseDialog(context)</span><br><span class="line">                .setCustomerContent(R.layout.nim_layout_shiming_test_layout)</span><br><span class="line">                .setDialogSize(145.0f, 145.0f)</span><br><span class="line">                .setWindowBackground(R.color.clr_000000)</span><br><span class="line">                .setViewOnClickListener(R.id.shiming_text_send_video, new View.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(View v) &#123;</span><br><span class="line">                        //开启activity录像</span><br><span class="line">                        videoFile = openCaptureVideo(context);</span><br><span class="line">//                        gotoSendVideo(file,listener);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).setViewOnClickListener(R.id.shiming_text_send_in_phone, new View.OnClickListener() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void onClick(View v) &#123;</span><br><span class="line">                        System.out.println( &quot;shiming phone&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        baseDialog.setCanCancelOutside(true);</span><br><span class="line">        baseDialog.show();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>由于我们的dialog的对象为静态的，所以就有了内存泄漏的可能，但是我们的context的对象必须为activity，因为我们的dialog必须持有的activity的context才能开启，要不然会报错，窗体泄漏<br>todo</p><p>##end<br>地址：<a href="https://github.com/Shimingli/DemoOOM" target="_blank" rel="noopener">https://github.com/Shimingli/DemoOOM</a></p>]]></content>
      
      
        <tags>
            
            <tag> OOM </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
