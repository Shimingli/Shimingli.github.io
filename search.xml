<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Android 9 Pie 正式版总结</title>
      <link href="/2018/08/14/Android-9-Pie-%E6%AD%A3%E5%BC%8F%E7%89%88%E6%80%BB%E7%BB%93/"/>
      <url>/2018/08/14/Android-9-Pie-%E6%AD%A3%E5%BC%8F%E7%89%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<ul><li>先声明下，以下的整理的资料一部分来源于公众号<code>谷歌开发者</code>,一部分来源于<a href="https://developer.android.google.cn/" target="_blank" rel="noopener">谷歌安卓官方网站</a>（不用翻墙，gogogo），还有小部分自己的理解。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-88fbec19dcb39405.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android 9"><a id="more"></a></li><li>微信公众号号<code>谷歌开发者</code>推送了 <code>Android 9 Pie 现已面向全球正式发布！</code>,就去更新 <code>Android API 28</code>,想看看正式版那些功能，就发生了如下的故事 </li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-246697c1c7a1fd7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="钉钉工作群"><br>这是我的电脑<code>IP</code>地址<br><img src="https://upload-images.jianshu.io/upload_images/5363507-2570704afb0266ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="我的电脑IP.png"></p><p><img src="https://upload-images.jianshu.io/upload_images/5363507-981c91a3d7305557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="和领导的聊天记录"></p><ul><li>然后我的电脑就被限制速度了，为了同事们能够好好工作，现在模拟器镜像都不能下载了！哈哈</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-4fdf1483b6f645f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li><p>虽然不能完成<code>Android 9</code>有些 <code>api</code>的具体的效果，先mark下，后续再来添上</p></li><li><p>今天我终于把<code>API 28</code>的源码下载下来了。哈哈！<br>##动态电量管理</p><h4 id="1、应用待机分组"><a href="#1、应用待机分组" class="headerlink" title="1、应用待机分组"></a>1、应用待机分组</h4><ul><li>Android P 新增加应用待机分组的功能，让系统根据用户的使用情况而限制应用调用CPU或网络等设备的资源, 应用待机分组是 Android P 新添加的一项电量管理功能，它能根据应用的使用频率或者最近一次使用时间，对其资源请求进行优先级排序！</li><li>优先分组   在默认的情况下，系统会更具应用的近期的使用的情况进行等级划分，应用活跃度越高，所处的分组优先级就越高，也更加容易获取设备的资源；第二种是系统安装了通过利用机器学习预加载的应用，从而预测各个应用的使用概率，然后将他们编配值相应的群组，在我朝手机设备厂商应该不会是这种。设备厂商可以自行规定非活跃应用的群组划分规则(我朝特色，厂商白名单)。请开发者不要试图篡改应用所处的群组，而是专注于改善应用行为，确保应用被划分至目标群组后，依旧能够顺利运行（小公司，好好提升技术，）<h5 id="5个分组如下-活跃-Active-、工作-Working-set-、-常用-Frequent-、-极少-Rare-、应用偶尔被使用-App-is-not-frequently-used"><a href="#5个分组如下-活跃-Active-、工作-Working-set-、-常用-Frequent-、-极少-Rare-、应用偶尔被使用-App-is-not-frequently-used" class="headerlink" title="5个分组如下  活跃 (Active)、工作 (Working set)、 常用 (Frequent)、 极少 (Rare)、应用偶尔被使用 (App is not frequently used)"></a>5个分组如下  活跃 (Active)、工作 (Working set)、 常用 (Frequent)、 极少 (Rare)、应用偶尔被使用 (App is not frequently used)</h5></li><li><p><code>活跃 (Active)</code>: 应用正在被使用 （每个应用都可以）<br>1、启动了一个Activity<br>2、正在运行的前台服务<br> 3、另外一个应用已关联该应用<br>4、 用户点击了推送</p></li><li><p><code>工作 (Working set)</code>: 应用使用频率很高<br>1、若应用的运行频率很高，但目前并未处于“活跃”状态，它就会被划分至工作群组，例如用户常用的社交媒体应用。此外，该群组还包括了那些被间接使用的应用。微信 QQ 支付宝 ，工作分组内的应用任务（Job）运行和闹铃受到系统的部分限制</p></li><li><p><code>常用 (Frequent)</code>: 应用经常但不是每天被使用<br>常用应用指用户经常使用但不是每天使用的应用，比如用户在健身房使用的打卡应用可能就属于这一群组。跑步的APP系统对常用分组采用的限制更强，应用运行任务(job)和触发闹铃的能力都会受到影响，而且接受的高优先性FCM消息也有数量上限</p></li></ul></li></ul><ul><li><p><code>极少 (Rare)</code>: 应用偶尔被使用</p><pre><code>若应用的使用频率很低，它就会被划分至该分组，(比如说你去某个地方，订酒店之类的APP，)该群组下的应用在任务 (job)、闹铃和高优先性FCM消息的资源调用上都会受到严格的限制。此外，网络访问能力也会受到影响</code></pre></li><li><p><code>应用偶尔被使用 (App is not frequently used)</code><br>安装后一次都未被使用过的应用将被划分至 “从不” 这一特殊群组，并受到十分严格的系统限制  我们自己的手机上有这种的App 很多</p><ul><li>我们做应用层<code>APP</code>应该怎么应对这几种分组 ？    </li><li>每个模式下，都能打开APP，确保App不能炸掉</li><li>要确保有启动的 Launcher Activity，如果没有的话，有可能你的应用不会切换到活跃分组</li><li>推送的消息要具有可操作性，这个的意思就是说，点了通知栏要跳到应用去</li><li>若应用在接受高优先级的 FCM 消息之后未能发送推送，用户将无法与应用产生互动并将其优先级提升至 “活跃” 等级。</li><li>如果用户多次忽略某个App的推送，系统会去询问用户是否不再接受此推送 。所以不要乱去推送，为了保持活跃群组!</li></ul></li></ul><ul><li><p>后台的限制 （微信经常这样）当系统检测到应用消耗过多的资源时，系统会发通知询问用户是否需要限制该应用的后台的活动<br>1、第一中期情况是，频繁使用唤醒锁 (wake locks)：屏幕关闭后，局部唤醒锁 (Partial wake lock) 连续开启 1 小时；<br>2、过多的后台服务：当应用目标 API 等级低于 26，且运行过多后台服务。</p></li><li><p>Android P 进一步提升了省电模式的性能。需要由设备的厂商来决定采用的具体的限制<br>作为开发者 我们自己，我们需要在省电模式下测试应用。确保自己的应用能够安全的上线和运行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//使用 Android Debug Bridge 命令 https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&amp;mid=2652046811&amp;idx=1&amp;sn=f0340e6fabb07a3ee40db45bdd58e7b0&amp;chksm=808ca59eb7fb2c883c6ae99be7c84460f48886cd79bb0de886a5bac84afa2d8050a58339cc89&amp;scene=21#wechat_redirect</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、后台限制"><a href="#2、后台限制" class="headerlink" title="2、后台限制"></a>2、后台限制</h4><ul><li><code>Android P</code>新增后台限制功能，如果应用出现 <code>Android Vitals</code> 里面所描述的行为，系统将提醒用户限制该应用的访问设备的资源!</li><li><code>Android Vitals</code>:是谷歌提高Android设备稳定性和性能的一项举措。当选择的用户运行你的应用程序时，他们的Android设备记录各种度量，包括关于应用程序稳定性、应用程序启动时间、电池使用时间、渲染时间和权限拒绝的数据。谷歌播放控制台聚集这些数据并将其显示在Android虚拟仪表板中。仪表板突出了崩溃率、ANR率、过度唤醒和卡尾锁：这是开发人员应该关注的核心。所有其他的vitals，当适用于你的APP或游戏类型时，都应该被监控，以确保它们不会产生负面影响。如果产生了，应用的商店被发现的可能性低，说到底的意思就是，垃圾应用，我不帮你推荐!</li></ul><h4 id="3、省电模式的优化"><a href="#3、省电模式的优化" class="headerlink" title="3、省电模式的优化"></a>3、省电模式的优化</h4><ul><li>Android P 优化了现在的省电助手的功能，在启动该功能后，系统将对所有的后台运行实施加以限制</li></ul><h4 id="4、低耗能模式，-当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android-P并没有针对低电耗模式做出改变"><a href="#4、低耗能模式，-当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android-P并没有针对低电耗模式做出改变" class="headerlink" title="4、低耗能模式， 当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。Android P并没有针对低电耗模式做出改变."></a>4、低耗能模式， 当用户一段时间没有使用设备时候，设备将进入低耗电模式，所有的应用都将要受到影响。<code>Android P</code>并没有针对低电耗模式做出改变.</h4><ul><li>低耗电模式:   低电耗模式通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络 Activity 来减少电池消耗。应用待机模式可推迟用户近期未与之交互的应用的后台网络 Activity. 如果用户设备未插接电源、处于静止状态一段时间且屏幕关闭，设备会进入低电耗模式。 在低电耗模式下，系统会尝试通过限制应用对网络和 CPU 密集型服务的访问来节省电量。 这还可以阻止应用访问网络并推迟其作业、同步和标准闹铃.一旦用户通过移动设备、打开屏幕或连接到充电器唤醒设备，系统就会立即退出低电耗模式，并且所有应用都将返回到正常 Activity。</li><li>有个例子。手机设备8.0上，打开视频APP下载视屏，关闭屏幕，一会视屏App就会关闭，在以前的版本不会出现，这就是低电耗模式!</li></ul><h4 id="5、Slices-App-Actions"><a href="#5、Slices-App-Actions" class="headerlink" title="5、Slices  App Actions"></a>5、Slices  App Actions</h4><ul><li>Google 想要透过<code>Action</code>和 <code>Slice</code> 这两个功能让使用者减少操作动作，让应用程式和操作行为更紧密结合，把以前需要操作四五下才能完成的事减少到操作两三下或是操作一下就能自动完成。</li><li><code>App Actions</code>是一种全新的应用推荐的方式，它能够对应用语义意图和使用场景进行分析，并根据分析结果在适当的时机向用户推荐应用,比如说在用户插入耳机的时候，推荐开启 音乐<code>App</code> 等等 —&gt;谷歌没有公布使用的方式  </li><li><code>Slice</code>: 的概念则是 Google Assistant 的延伸，让使用者能快速使用到 app 里的某个特定功能，只要开发者导入 Slice 功能，使用者在使用搜寻、Google Play 商店、Google Assitant 或其他内建功能时都会出现 Slice 的操作建议。在<code>go</code>语言中 有个叫切片<code>slice</code>，它的意思是：在初始定义数组时，我们并不知道需要多大的数组，因此我们就需要“动态数组”。在Go里面这种数据结构叫<code>slice</code>.</li></ul><h4 id="6、文本识别与-Smart-Linkify"><a href="#6、文本识别与-Smart-Linkify" class="headerlink" title="6、文本识别与 Smart Linkify"></a>6、<a href="https://developer.android.google.cn/reference/android/view/textclassifier/package-summary" target="_blank" rel="noopener">文本识别与 Smart Linkify</a></h4><ul><li>在 Android 9 中，我们对识别文本的机器学习模型进行了扩展，使其可以借助 TextClassifier API 识别出类似日期或航班号这样的信息。此外， Smart Linkify 允许开发者通过 Linkify API 使用文本识别模块完成多项操作，比如对用户可采取的操作提出建议。Smart Linkify 让系统在文本识别精确度与速度上都有明显的提升。</li><li>TextClassifier  后续更新下Demo  研究中<br><img src="https://upload-images.jianshu.io/upload_images/5363507-085482fa43bb2721.gif?imageMogr2/auto-orient/strip" alt="demo.gif"></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   TextClassifier API</span><br><span class="line">  https://developer.android.google.cn/reference/android/view/textclassifier/package-summary</span><br><span class="line"> Linkify API</span><br><span class="line">https://developer.android.google.cn/reference/android/text/util/Linkify</span><br></pre></td></tr></table></figure><h4 id="7、神经网络-API-1-1"><a href="#7、神经网络-API-1-1" class="headerlink" title="7、神经网络 API 1.1"></a>7、<a href="https://developer.android.google.cn/ndk/guides/neuralnetworks/index.html" target="_blank" rel="noopener">神经网络 API 1.1</a></h4><ul><li><code>Android 9.0</code> 对神经网络 API 进行了扩展与改进，进一步优化 Android 对机器学习硬件加速的支持。神经网络 API 1.1 共增加了对 9 个新算子的支持，它们分别是<code>Pad、BatchToSpaceND、SpaceToBatchND、Transpose、Strided Slice、Mean、Div、Sub 和 Squeeze。TensorFlow Lite</code>就是一个已经用上此 API 的典型机器学习框架。</li></ul><h2 id="人机交互"><a href="#人机交互" class="headerlink" title="人机交互"></a>人机交互</h2><h4 id="1、全新系统导航"><a href="#1、全新系统导航" class="headerlink" title="1、全新系统导航"></a>1、全新系统导航</h4><ul><li><code>Android 9</code>迎来了全新的系统导航，让多任务切换及关联应用探索变得更加简单。您只需要向上滑动屏幕就可以全屏预览最近使用过的应用，轻触预览页后便可以切换至所选应用。</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-57240ac05547289b.gif?imageMogr2/auto-orient/strip" alt="全新系统导航.gif"></p><h4 id="2、-凹口屏支持"><a href="#2、-凹口屏支持" class="headerlink" title="2、 凹口屏支持"></a>2、 <a href="https://developer.android.google.cn/guide/topics/display-cutout/" target="_blank" rel="noopener">凹口屏支持</a></h4><ul><li>想起来 苹果大佬 还是牛逼，刘海是为了屈服某种硬件的缺陷，然后谷歌就开始支持了</li><li><code>Android 9</code> 中加入了凹口屏支持，让您的应用可以充分利用最新全面屏，展现应用的独特魅力。该功能可以在大部分应用中无缝工作，系统会通过调整状态栏高度将应用内容与屏幕缺口区域分开。如果您的应用含有沉浸式内容，您可调用<code>display cutout APIs</code> 确认缺口形状与位置，然后请求围绕缺口进行全屏布局。另外，我们还加入了开发者选项来模拟任意设备上的凹口形状，从而极大简化了应用支持凹口屏幕所需的构建以及测试流程。<h4 id="3、-通知与智能回复"><a href="#3、-通知与智能回复" class="headerlink" title="3、 通知与智能回复"></a>3、 通知与智能回复</h4></li><li><code>Android 9</code> 进一步改善了通知的实用性与可操作性。消息类应用可以调用新的 <code>MessagingStyle API</code> 来显示对话，附加照片和表情，或者提供智能回复建议。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Create new Person.  完蛋了，这下在安卓中Person类有了，不仅仅是一个了</span><br><span class="line">   val sender = Person()</span><br><span class="line">           .setName(name)</span><br><span class="line">           .setUri(uri)</span><br><span class="line">           .setIcon(null)</span><br><span class="line">           .build()</span><br><span class="line"> // Create image message.</span><br><span class="line">   val message = Notification.MessagingStyle.Message(&quot;Picture&quot;, time, sender)</span><br><span class="line">           .setData(&quot;image/&quot;, imageUri)</span><br><span class="line">   val style = Notification.MessagingStyle(getUser())</span><br><span class="line">           .addMessage(&quot;Check this out!&quot;, 0, sender)</span><br><span class="line">           .addMessage(message)</span><br></pre></td></tr></table></figure></li></ul><h4 id="4、文本放大镜"><a href="#4、文本放大镜" class="headerlink" title="4、文本放大镜"></a>4、<a href="https://developer.android.google.cn/reference/android/widget/Magnifier" target="_blank" rel="noopener">文本放大镜</a></h4><ul><li>Android 9 中添加文字放大镜工具 (Magnifier widget)，以提升文本选择方面的用户体验。由于该放大器提供了可以在文本上方拖拽的文本放大面板，所以有助于用户精准地定位光标或文本选择手柄。该功能可以灵活运用在所有附加在窗口的视图上，个性化小部件和定制文本呈现均是不错的应用场景。</li><li>该放大器工具还可以提供任何视图或界面的放大版本，而不仅仅是文本。<br><img src="https://upload-images.jianshu.io/upload_images/5363507-1298304aefb3084e.gif?imageMogr2/auto-orient/strip" alt="文本放大.gif"></li></ul><h2 id="用户安全与隐私"><a href="#用户安全与隐私" class="headerlink" title="用户安全与隐私"></a>用户安全与隐私</h2><h4 id="1、统一身份验证对话框"><a href="#1、统一身份验证对话框" class="headerlink" title="1、统一身份验证对话框"></a>1、统一身份验证对话框</h4><ul><li><p>为了保障用户在不同甘银强和应用之间能够获得一致的体验，Android P 引入了统一的身份验证对话框，提醒用户进行操作。应用可以不自行的设计，该API还支持面部识别<code>虹膜识别技术</code> 是基于眼睛中的虹膜进行身份识别，应用于安防设备（如门禁等），以及有高度保密需求的场所。</p><ul><li>优点<br>1．便于用户使用；<br>2．可能会是最可靠的生物识别技术；.<br>3．不需物理的接触；<br>4．可靠性高。</li><li>缺点<br>1．很难将图像获取设备的尺寸小型化；<br>2．设备造价高，无法大范围推广；<br>3．镜头可能产生图像畸变而使可靠性降低；<br>4．两大模块：硬件和软件；<br>5．一个自动虹膜识别系统包含硬件和软件两大模块：虹膜图像获取装置和虹膜识别算法。分别对应于图像获取和模式匹配这两个基本问题。</li></ul></li></ul><ul><li>代码如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// TODO 一定要在 API 28的模拟器上跑 要不然 app 会直接奔溃掉</span><br><span class="line">       val BiometricPrompt = BiometricPrompt.Builder(this)</span><br><span class="line">               .setTitle(&quot;指纹验证&quot;)</span><br><span class="line">               .setDescription(&quot;描述&quot;)</span><br><span class="line">               .setNegativeButton(&quot;取消&quot;, mainExecutor, DialogInterface.OnClickListener &#123; dialogInterface, i -&gt; Log.i(UserSecurityAndPrivacyActivity@ this.localClassName, &quot;Cancel button clicked&quot;) &#125;)</span><br><span class="line">               .build()</span><br><span class="line">       val mCancellationSignal = CancellationSignal()</span><br><span class="line">       mCancellationSignal.setOnCancelListener &#123;</span><br><span class="line">           CancellationSignal.OnCancelListener &#123;</span><br><span class="line">               fun onCancel() &#123;</span><br><span class="line">                   println(&quot;取消了啊&quot;)</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       val mAuthenticationCallback = object : BiometricPrompt.AuthenticationCallback() &#123;</span><br><span class="line">           override fun onAuthenticationError(errorCode: Int, errString: CharSequence) &#123;</span><br><span class="line">               super.onAuthenticationError(errorCode, errString)</span><br><span class="line">               println(&quot;发生了 错误了啊&quot;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           override fun onAuthenticationSucceeded(result: BiometricPrompt.AuthenticationResult) &#123;</span><br><span class="line">               super.onAuthenticationSucceeded(result)</span><br><span class="line">               println(&quot;发生了 成功了啊&quot;)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           override fun onAuthenticationFailed() &#123;</span><br><span class="line">               super.onAuthenticationFailed()</span><br><span class="line">               println(&quot;发生了 失败了&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       BiometricPrompt.authenticate(mCancellationSignal, mainExecutor, mAuthenticationCallback)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、Android-Protected-Confirmation"><a href="#2、Android-Protected-Confirmation" class="headerlink" title="2、Android Protected Confirmation"></a>2、<a href="https://developer.android.google.cn/preview/features/security#android-protected-confirmation" target="_blank" rel="noopener">Android Protected Confirmation</a></h4><ul><li>安卓保护确认：运行Android 9或更高版本的支持设备使您有能力使用Android保护的确认。使用此工作流时，应用程序向用户显示提示，要求用户批准简短语句。这个声明允许应用程序重新确认用户希望完成一个敏感的交易，例如支付。</li></ul><h4 id="3、KeyStore-加强密钥安全保护"><a href="#3、KeyStore-加强密钥安全保护" class="headerlink" title="3、KeyStore 加强密钥安全保护"></a>3、<code>KeyStore</code> <a href="https://link.juejin.im?target=https%25253A%25252F%25252Fdeveloper.android.google.cn%25252Fpreview%25252F" target="_blank" rel="noopener">加强密钥安全保护</a></h4><ul><li>加入了一个新的<code>KeyStore</code> 类 —— <code>StrongBox</code>，并提供相应的 API 来支持那些提供了防入侵硬件措施的设备，比如独立的 CPU，内存以及安全存储。</li></ul><p>####4、 DNS over TLS 基于TLS的DNS</p><ul><li>大多的网络连接 –DNS查询–》返回IP地址–》客服端就能连接上网页了。互联网的大佬们一直在致力于新的NDS的协议的开发，该协议就是NDS over  TLS协议     <code>TLS</code>：安全传输层协议（TLS）用于在两个通信应用程序之间提供保密性和数据完整性<ul><li><code>Android  P</code> 正式版内置对 <code>DNS over TLS</code>的支持，在 “网络和互联网” 设置中添加了隐私 DNS (Private DNS) 模式。</li><li>NS over TLS 模式自动为所有系统上的应用提供安全 DNS查询。不过，若应用未使用系统 API，而是自行运行 DNS 查询，它们必须确保在系统进行安全连接情况下，不发送不安全的 DNS 查询。应用可以调用新的 API<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkProperties.isPrivateDnsActive()</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="5、Android-P默认使用了HTTPS"><a href="#5、Android-P默认使用了HTTPS" class="headerlink" title="5、Android P默认使用了HTTPS"></a>5、<code>Android P</code>默认使用了<code>HTTPS</code></h4><h4 id="6、基于编译器的安全缓解措施"><a href="#6、基于编译器的安全缓解措施" class="headerlink" title="6、基于编译器的安全缓解措施"></a>6、基于编译器的安全缓解措施</h4><ul><li><code>Android 9</code> 将进一步扩展编译器级别的安全缓解措施，借助运行时危险行为监测进一步加强平台安全建设。<code>Android 9</code>通过控制流程完整性 <code>(CFI)</code> 技术解决了代码重用<code>(code-reuse)</code>和任意代码执行两大漏洞，并扩展了<code>CFI</code>在媒体框架和其它关键安全组件内的使用范围，如<code>NFC</code> 与蓝牙。同时，<code>Android 9</code>还针对 <code>Android</code> 常见内核的 <code>LLVM</code> 编译添加了 <code>CFI</code>内核支持。</li></ul><h4 id="7、用户隐私"><a href="#7、用户隐私" class="headerlink" title="7、用户隐私"></a>7、用户隐私</h4><ul><li><code>Android 9</code>新加入多项机制，进一步加强了对用户隐私的保护。系统禁止所有处于空闲状态的应用对话筒、摄像头和所有 <code>SensorManager</code>传感器的访问。当应用的 <code>UID</code> 空闲时，麦克风将会报告 “无音频信号”，传感器将会停止报告事件，应用使用的摄像头也会断开连接，并在应用试图访问时生成错误。在大多数情况下，这些限制不会对现有应用造成新的问题，谷歌建议从应用中移除此类传感器请求。</li><li><code>Android 9</code> 还让用户控制是否允许访问平台<code>build.serial</code>识别码 (它被 READ_PHONE_STATE 权限保护) ,设备的唯一标识<code>the hardware serial number</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//获取硬件序列号，如果可用的话。</span><br><span class="line">    if (ActivityCompat.checkSelfPermission(this, Manifest.permission.READ_PHONE_STATE) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        //注意需要在 高版本的 SDK的手机上运行</span><br><span class="line">        val serial = Build.getSerial()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="摄像和影音的全面升级"><a href="#摄像和影音的全面升级" class="headerlink" title="摄像和影音的全面升级"></a>摄像和影音的全面升级</h2><h4 id="1、多摄像头的API的改进-–-gt"><a href="#1、多摄像头的API的改进-–-gt" class="headerlink" title="1、多摄像头的API的改进 –&gt;"></a>1、多摄像头的API的改进 –&gt;</h4><ul><li>从 Android 9 开始，您可以在支持多摄像头 API 的设备上通过两个或更多实体摄像头同时访问视频流；在配有双前置或双后置摄像头的设备上，实现单摄像头无法实现的创新功能：如无缝变焦、散景和立体视觉。该 API 还允许您调用可以在两台或更多台摄像头之间自动切换的逻辑或混合摄像头视频流。</li></ul><h4 id="2、使用动态处理增强音频–-gt-降噪技术"><a href="#2、使用动态处理增强音频–-gt-降噪技术" class="headerlink" title="2、使用动态处理增强音频–&gt;降噪技术"></a>2、使用动态处理增强音频–&gt;降噪技术</h4><ul><li>iPhone手机的降噪技术：双麦克风降噪技术，即手机中内置的两个麦克风，一个保持清晰通话，另一个麦克风从物理上主动消除噪音，通过收集外界的噪声，运用内部算法进行处理后，发出与噪音相反的声波，利用抵消原理消除噪音。其他手机估计也差不多！</li><li>开发者可以调用 <code>Dynamics Processing API</code>对音频进行动态处理，通过分离出特定频率的声音，降低过大的音量，或者增强过小的音量，来改善应用的音频质量。比如说，即便说话者声音小，离麦克风远，而且外界环境十分嘈杂，您的应用依然可以有效捕捉并他/她的声音，并进行相应优化。该 API 提供了多声场、多频段的动态处理效果，包括一个预均衡器、一个多频段压缩器，一个后均衡器以及一个串联的音量限制器。<h4 id="3、ImageDecoder-API"><a href="#3、ImageDecoder-API" class="headerlink" title="3、ImageDecoder API"></a>3、ImageDecoder API</h4></li><li><code>ImageDecoder</code> 通过一种更为简单的方式将图像解码为位图或 <code>drawable</code>。<code>ImageDecoder</code> 允许您从字节缓冲区、文件或 URI 创建位图或 drawable。它相比<code>BitmapFactory</code>有以下几个优势：支持精确缩放，支持单步解码至硬件存储器，支持解码后处理，以及动画图像解码。</li><li><p><code>ImageDecoder</code>:一个的可以将<code>PNG, JPEG, WEBP, GIF, or HEIF</code>格式的图片的转换成<code>Drawable</code> 或者<code>Bitmap</code>对象的类。</p><ul><li><p>1、正常的使用:得到<code>drawable</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val file =File(&quot;filename&quot;)</span><br><span class="line">      val source = ImageDecoder.createSource(file)</span><br><span class="line">      val drawable = ImageDecoder.decodeDrawable(source)</span><br></pre></td></tr></table></figure></li><li><p>2、传递<code>OnHeaderDecodedListener</code>，这里<code>ImageInfo</code>存放的是原始的图片的宽和高。可以修改用来修改图片宽高的时候修改<code>SampleSize</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val listener = object : ImageDecoder.OnHeaderDecodedListener &#123;</span><br><span class="line">          override fun onHeaderDecoded(decoder: ImageDecoder, info: ImageDecoder.ImageInfo, source: ImageDecoder.Source) &#123;</span><br><span class="line">              decoder.setTargetSampleSize(2)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      val drawable1 = ImageDecoder.decodeDrawable(source, listener)</span><br></pre></td></tr></table></figure></li><li><p>3、如果解码的图片是<code>gif</code>，会被解码成<code>AnimatedImageDrawable</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val drawable2 = ImageDecoder.decodeDrawable(source)</span><br><span class="line">    if (drawable is AnimatedImageDrawable) &#123;</span><br><span class="line">        drawable.start()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>4、解码出来的bitmap是不可变，可以使用<code>PostProcessor</code>来添加一些自定义的效果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">val drawable3 = ImageDecoder.decodeDrawable(source) &#123; decoder, info, src -&gt;</span><br><span class="line">        decoder.setPostProcessor &#123; canvas -&gt;</span><br><span class="line">            // This will create rounded corners.</span><br><span class="line">            //创建圆角照片</span><br><span class="line">            val path = Path()</span><br><span class="line">            path.setFillType(Path.FillType.INVERSE_EVEN_ODD)</span><br><span class="line">            val width = canvas.width</span><br><span class="line">            val height = canvas.height</span><br><span class="line">             // 最低的API的要求是 21 所以我的工程里面的 API为 21</span><br><span class="line">            path.addRoundRect(0.toFloat(), 0.toFloat(), width.toFloat(), height.toFloat(), 20.toFloat(), 20.toFloat(), Path.Direction.CW)</span><br><span class="line">            val paint = Paint()</span><br><span class="line">            paint.setAntiAlias(true)</span><br><span class="line">            paint.setColor(Color.TRANSPARENT)</span><br><span class="line">            paint.setXfermode(PorterDuffXfermode(PorterDuff.Mode.SRC))</span><br><span class="line">            canvas.drawPath(path, paint)</span><br><span class="line">            PixelFormat.TRANSLUCENT</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、如果解码的照片是不完整的或者包含错误，解码的时候会抛出<code>DecodeException</code>，一些情况下，可能已经解码出一部分的照片，这个时候传递<code>OnPartialImageListener</code>，并返回<code>true</code>，就只显示解码出来的部分，剩余部分使用空白代替!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val drawable5 = ImageDecoder.decodeDrawable(source) &#123; decoder, info, src -&gt;</span><br><span class="line">         decoder.setOnPartialImageListener &#123; e: ImageDecoder.DecodeException -&gt;</span><br><span class="line">              true</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="网络连接与位置"><a href="#网络连接与位置" class="headerlink" title="网络连接与位置"></a>网络连接与位置</h2><h4 id="1、使用-Wi-Fi-RTT-，进行室内定位"><a href="#1、使用-Wi-Fi-RTT-，进行室内定位" class="headerlink" title="1、使用 Wi-Fi RTT ，进行室内定位"></a>1、使用 Wi-Fi RTT ，进行室内定位</h4><ul><li><code>Android 9</code> 为<code>IEEE 802.11mc Wi-Fi</code>协议添加了平台支持 (也称为 Wi-Fi 往返时间，RTT)，这可以让您在应用中使用室内定位功能。在提供硬件支持的 Android 9 设备上，在启动位置服务并勾选 “允许获取地理位置信息” 选项后，应用就可以使用 RTT API 测量与附近 Wi-Fi 接入点 (AP) 的距离。设备不需要连接到 AP 便可以使用 RTT，而且为了保护隐私，只有手机能够确定距离，而 AP 不可以。</li><li>通过测量从设备到三个或更多 AP 的距离，您可以计算设备位置至 1 到 2 米的精度。这种精确度允许您创建更多新的体验：室内导航、基于位置的细粒度服务，例如，模糊语音控制 ( “打开这里的灯” ) ；以及基于位置的资讯服务 ( “这个产品有优惠活动吗？” )。</li></ul><h4 id="2、JobScheduler-中的数据费用敏感度"><a href="#2、JobScheduler-中的数据费用敏感度" class="headerlink" title="2、JobScheduler 中的数据费用敏感度"></a>2、JobScheduler 中的数据费用敏感度</h4><ul><li>在 <code>Android 9</code>中，<code>JobScheduler</code> 可以更好地帮助用户处理与网络相关的任务，并与运营商单独提供的网络状态信号相协调</li><li><code>JobScheduler</code>是 <code>Android</code> 的一项核心服务，它可以帮助您针对低耗电模式、应用待机模式以及后台限制，妥善进行各种任务的调度。在 <code>Android 9</code>中，<code>JobScheduler</code> 可以更好地帮助用户处理与网络相关的任务，并与运营商单独提供的网络状态信号相协调。任务现在可以声明预估数据量、信号预取以及指定详细的网络要求 —— 运营商可以报告网络状况是拥塞还是不计量，然后 <code>JobScheduler</code>会根据网络状态管理作业。例如，当网络拥塞时，<code>JobScheduler</code> 可能推迟大型网络请求；而在网络可以不计量使用时，则可以运行多种预加载作业 (例如，预读标题) 来改进用户体验。<h4 id="3、-用于-NFC-支付和安全交易的-Open-Mobile-API"><a href="#3、-用于-NFC-支付和安全交易的-Open-Mobile-API" class="headerlink" title="3、 用于 NFC 支付和安全交易的 Open Mobile API"></a>3、 用于 NFC 支付和安全交易的 Open Mobile API</h4></li><li><code>Android 9</code> 将 <code>GlobalPlatform Open Mobile API</code> 的实现添加至平台中。在支持的设备上，应用可以使用 OMAPI API 访问安全元素 (SE) ，以启用智能卡支付等安全服务。硬件抽象层 (HAL) 提供了必要的 API，用于枚举多种可用的 Secure Elements (如 eSE, UICC 等)。</li></ul><h2 id="更强劲的性能表现"><a href="#更强劲的性能表现" class="headerlink" title="更强劲的性能表现"></a>更强劲的性能表现</h2><h4 id="1、ART-性能提升"><a href="#1、ART-性能提升" class="headerlink" title="1、ART 性能提升"></a>1、ART 性能提升</h4><ul><li>ART是什么？<ul><li><code>AOT</code>是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式。</li></ul></li><li><code>JIT</code>是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik。<ul><li>ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。</li><li>当然ART与Dalvik相比，还是有缺点的。<ul><li>ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%</li><li>由于有了一个转码的过程，所以应用安装时间难免会延长<ul><li>但是这些与更流畅的Android体验相比而言，不值一提。</li></ul></li></ul></li></ul></li><li><code>Android 9</code> 借助 <code>ART</code> 运行时显著提高了应用的性能表现与运行效率。扩展了 <code>ART</code>对执行特征的使用，以优化应用并减少已编译应用代码的内存占用量。ART 现可使用特征文件信息在设备上重写 DEX 文件，帮助多个常见应用的内存占用减少高达 11％。我们期望借此减少系统 DEX 内存使用量并加快应用启动时间。</li></ul><h4 id="2、Kotlin-优化"><a href="#2、Kotlin-优化" class="headerlink" title="2、Kotlin 优化"></a>2、Kotlin 优化</h4><ul><li>Kotlin 是 Android 开发的一等编程语言，改进了一些编译器优化，尤其是那些针对循环的编译器优化，以实现更好的性能。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Android P </tag>
            
            <tag> 谷歌 </tag>
            
            <tag> Android 9 正式版 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>安卓invalidate、postInvalidate、requestLayout源码分析</title>
      <link href="/2018/08/07/%E5%AE%89%E5%8D%93invalidate%E3%80%81postInvalidate%E3%80%81requestLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
      <url>/2018/08/07/%E5%AE%89%E5%8D%93invalidate%E3%80%81postInvalidate%E3%80%81requestLayout%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<ul><li>最近在撸<code>Golang</code>有点上火了，来整理下安卓源码资料☺☺☺</li><li>分析结果基于<code>Audroid API 26</code><a id="more"></a><h4 id="requestLayout-源码分析"><a href="#requestLayout-源码分析" class="headerlink" title="requestLayout()源码分析"></a><code>requestLayout()</code>源码分析</h4></li><li><p>假如在一个页面上有个按钮，点击按钮就对一个 <code>view.requestLayout()</code>,这个 <code>view</code> 执行的方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView------onMeasure</span><br><span class="line">InvalidateTextView------onMeasure</span><br><span class="line">InvalidateTextView-------layout</span><br><span class="line">InvalidateTextView--------onLayout</span><br><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p><code>view.requestLayout()</code>  方法的详情</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@CallSuper</span><br><span class="line">  public void requestLayout() &#123;</span><br><span class="line">      // 清除绘制的缓存</span><br><span class="line">      if (mMeasureCache != null) mMeasureCache.clear();</span><br><span class="line"></span><br><span class="line">      if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</span><br><span class="line">          //只有在布局逻辑中触发请求，如果这是请求它的视图，而不是其父层次结构中的视图</span><br><span class="line">          ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">          //如果连续请求两次，其中一次自动返回！</span><br><span class="line">          if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">              if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          mAttachInfo.mViewRequestingLayout = this;</span><br><span class="line">      &#125;</span><br><span class="line">     //todo   为当前view设置标记位 PFLAG_FORCE_LAYOUT</span><br><span class="line">      mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">      mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line"></span><br><span class="line">      if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">         //   todo  向父容器请求布局 这里是向父容器请求布局，即调用父容器的requestLayout方法，为父容器添加PFLAG_FORCE_LAYOUT标记位，而父容器又会调用它的父容器的requestLayout方法，即requestLayout事件层层向上传递，直到DecorView，即根View，而根View又会传递给ViewRootImpl，也即是说子View的requestLayout事件，最终会被ViewRootImpl接收并得到处理</span><br><span class="line">          mParent.requestLayout();</span><br><span class="line">      &#125;</span><br><span class="line">      if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == this) &#123;</span><br><span class="line">          mAttachInfo.mViewRequestingLayout = null;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>1、如果缓存不为<code>null</code>,清除绘制的缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (mMeasureCache != null) mMeasureCache.clear();</span><br></pre></td></tr></table></figure></li><li><p>2、这里判断了是否在<code>layout</code>，如果是，就返回，也就可以理解为： 如果连续请求两次，并且其中的一次正在<code>layout</code>中，其中一次返回！这样做是节约性能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (mAttachInfo != null &amp;&amp; mAttachInfo.mViewRequestingLayout == null) &#123;</span><br><span class="line">         //只有在布局逻辑中触发请求，如果这是请求它的视图，而不是其父层次结构中的视图</span><br><span class="line">         ViewRootImpl viewRoot = getViewRootImpl();</span><br><span class="line">         //如果连续请求两次，其中一次自动返回！</span><br><span class="line">         if (viewRoot != null &amp;&amp; viewRoot.isInLayout()) &#123;</span><br><span class="line">             if (!viewRoot.requestLayoutDuringLayout(this)) &#123;</span><br><span class="line">                 return;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         mAttachInfo.mViewRequestingLayout = this;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li><li><p>3、  为当前<code>view</code>设置标记位<code>PFLAG_FORCE_LAYOUT</code>,关于 <code>|=</code>符号：<code>a|=b</code>的意思就是把a和b按位或然后赋值给a 按位或的意思就是先把a和b都换成2进制，然后用或操作，相当于<code>a=a|b</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mPrivateFlags |= PFLAG_FORCE_LAYOUT;</span><br><span class="line">mPrivateFlags |= PFLAG_INVALIDATED;</span><br></pre></td></tr></table></figure></li><li><p>4、向父容器请求布局，即调用<code>ViewGroup</code>父容器的<code>requestLayout()</code>方法，为父容器添加<code>PFLAG_FORCE_LAYOUT</code>标记位，而父容器又会调用它的父容器的<code>requestLayout()</code>方法，即<code>requestLayout()</code>事件层层向上传递，直到<code>DecorView</code>，即根<code>View</code>，而根<code>View</code>又会传递给<code>ViewRootImpl，</code>也即是说子View的<code>requestLayout()f</code>事件，最终会被<code>ViewRootImpl.requestLayout()</code>接收并得到处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (mParent != null &amp;&amp; !mParent.isLayoutRequested()) &#123;</span><br><span class="line">      mParent.requestLayout();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、<code>ViewRootImpl.requestLayout()</code>方法详情</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void requestLayout() &#123;</span><br><span class="line">      if (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">          // 检查是否在主线程，不在的话，抛出异常</span><br><span class="line">          checkThread();</span><br><span class="line">          mLayoutRequested = true;</span><br><span class="line">          scheduleTraversals();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、检查是否在主线程，不在的话，抛出异常<code>checkThread();</code>    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void checkThread() &#123;</span><br><span class="line">    if (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        throw new CalledFromWrongThreadException(</span><br><span class="line">                &quot;Only the original thread that created a view hierarchy can touch its views.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2 、最终走到这个方法来<code>ViewRootImpl.scheduleTraversals()</code>,在其中可以看到一行非常有意思的代码<br><code>mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code> ,其中有个对象<code>mTraversalRunnable</code>,这样下去就会重新的测量、布局和绘制；具体的流程可以看这篇文章<a href="https://www.jianshu.com/p/b63c6afa1844" target="_blank" rel="noopener">Android源码分析(View的绘制流程)</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   // requestLayout()  会调用这个方法 </span><br><span class="line">void scheduleTraversals() &#123;</span><br><span class="line">    if (!mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = true;</span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        // 最终调用的是这个方法</span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">        if (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>有个问题，我先抛出结论，<code>requessLayout() 、invalidate()、postInvalidate()</code>最终的底层调用的是 <code>ViewRootImpl.scheduleTraversals()</code>的方法,为什么仅仅<code>requessLayout()</code>才会执行<code>onMeasure()  onLayout()  onDraw()</code>这几个方法？</p></li><li><p>关于<code>view.measure()</code>方法:在前面我们知道 <code>mPrivateFlags |= PFLAG_FORCE_LAYOUT</code> 所以 <code>forceLayout = true</code>,也就是会执行<code>onMeasure(widthMeasureSpec, heightMeasureSpec);</code>,同时执行完了以后呢，最后为标记位设置为<code>mPrivateFlags |=PFLAG_LAYOUT_REQUIRED</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">       ...</span><br><span class="line">       // requestLayout的方法改变的  mPrivateFlags |= PFLAG_FORCE_LAYOUT; 所以 forceLayout = true</span><br><span class="line">       final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT;</span><br><span class="line">       ...</span><br><span class="line">       if (forceLayout || needsLayout) &#123;</span><br><span class="line">       ...</span><br><span class="line">           if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123;</span><br><span class="line">               //最终会走到这方法来</span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; </span><br><span class="line">           // 接着最后为标记位设置为PFLAG_LAYOUT_REQUIRED</span><br><span class="line">           mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>关于<code>view.layout()</code>方法：判断标记位是否为<code>PFLAG_LAYOUT_REQUIRED</code>，如果有，则对该<code>View</code>进行布局,也就是走到<code>onLayout(changed, l, t, r, b);</code>,最后清除标记<code>mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&#123;&quot;unchecked&quot;&#125;)</span><br><span class="line">   public void layout(int l, int t, int r, int b) &#123;</span><br><span class="line">       if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) &#123;</span><br><span class="line">           //第二次调用这个方法，，，</span><br><span class="line">           onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">           mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       int oldL = mLeft;</span><br><span class="line">       int oldT = mTop;</span><br><span class="line">       int oldB = mBottom;</span><br><span class="line">       int oldR = mRight;</span><br><span class="line"></span><br><span class="line">       boolean changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">               setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line">          //判断标记位是否为PFLAG_LAYOUT_REQUIRED，如果有，则对该View进行布局</span><br><span class="line">       if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line">           onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">           if (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">               if(mRoundScrollbarRenderer == null) &#123;</span><br><span class="line">                   mRoundScrollbarRenderer = new RoundScrollbarRenderer(this);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mRoundScrollbarRenderer = null;</span><br><span class="line">           &#125;</span><br><span class="line">           //  onLayout方法完成后，清除PFLAG_LAYOUT_REQUIRED标记位</span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">   //  //最后清除PFLAG_FORCE_LAYOUT标记位</span><br><span class="line">       mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">       mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>以上就是 <code>requestLayout()</code>的分析的结果:<code>view</code>调用了这个方法，其实会从<code>view</code>树重新进行一次测量、布局、绘制这三个流程。</p></li><li>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-727eb9d2da018f43.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="requestLayout()的原理.jpg"></li></ul><h4 id="invalidate-源码分析"><a href="#invalidate-源码分析" class="headerlink" title="invalidate()源码分析"></a><code>invalidate()源码分析</code></h4><ul><li><p><code>view.invalidate()</code>;继承一个Textview，然后重写方法，设置一个but，同时请求方法，打印日志：请求一次的输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p>方法详情 : <code>view.invalidate()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void invalidate() &#123;</span><br><span class="line">      invalidate(true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>该视图的绘图缓存是否也应无效。对于完全无效,设置为true，但是如果视图的内容或维度没有改变，则可以设置为false。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void invalidate(boolean invalidateCache) &#123;</span><br><span class="line">     invalidateInternal(0, 0, mRight - mLeft, mBottom - mTop, invalidateCache, true);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>invalidateInternal()</code>方法详情：其实关键的方法就是<code>invalidateChild()</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">void invalidateInternal(int l, int t, int r, int b, boolean invalidateCache,</span><br><span class="line">          boolean fullInvalidate) &#123;</span><br><span class="line">      if (mGhostView != null) &#123;</span><br><span class="line">          mGhostView.invalidate(true);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      // 判断是否可见，是否在动画中，是否不是ViewGroup，三项满足一项，直接返回</span><br><span class="line">      if (skipInvalidate()) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">//根据View的标记位来判断该子View是否需要重绘，假如View没有任何变化，那么就不需要重绘</span><br><span class="line">      if ((mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)</span><br><span class="line">              || (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == PFLAG_DRAWING_CACHE_VALID)</span><br><span class="line">              || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED</span><br><span class="line">              || (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)) &#123;</span><br><span class="line">          if (fullInvalidate) &#123;</span><br><span class="line">              mLastIsOpaque = isOpaque();</span><br><span class="line">              mPrivateFlags &amp;= ~PFLAG_DRAWN;</span><br><span class="line">          &#125;</span><br><span class="line">          //设置PFLAG_DIRTY标记位</span><br><span class="line">          mPrivateFlags |= PFLAG_DIRTY;</span><br><span class="line"></span><br><span class="line">          if (invalidateCache) &#123;</span><br><span class="line">              mPrivateFlags |= PFLAG_INVALIDATED;</span><br><span class="line">              mPrivateFlags &amp;= ~PFLAG_DRAWING_CACHE_VALID;</span><br><span class="line">          &#125;</span><br><span class="line">          //把需要重绘的区域传递给父容器</span><br><span class="line">          // Propagate the damage rectangle to the parent view.</span><br><span class="line">          final AttachInfo ai = mAttachInfo;</span><br><span class="line">          final ViewParent p = mParent;</span><br><span class="line">          if (p != null &amp;&amp; ai != null &amp;&amp; l &lt; r &amp;&amp; t &lt; b) &#123;</span><br><span class="line">              final Rect damage = ai.mTmpInvalRect;</span><br><span class="line">              damage.set(l, t, r, b);</span><br><span class="line">              //调用父容器的方法，向上传递事件</span><br><span class="line">              p.invalidateChild(this, damage);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          // Damage the entire projection receiver, if necessary.</span><br><span class="line">          // 损坏整个投影接收机，如果不需要。</span><br><span class="line">          if (mBackground != null &amp;&amp; mBackground.isProjected()) &#123;</span><br><span class="line">              final View receiver = getProjectionReceiver();</span><br><span class="line">              if (receiver != null) &#123;</span><br><span class="line">                  receiver.damageInParent();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li><p>1、判断是否可见，是否在动画中，是否不是<code>ViewGroup</code>，三项满足一项，直接返回，这个方法也可以知道，<code>invalidate()</code>针对的是<code>View</code>，而不是<code>ViewGroup</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private boolean skipInvalidate() &#123;</span><br><span class="line">      return (mViewFlags &amp; VISIBILITY_MASK) != VISIBLE &amp;&amp; mCurrentAnimation == null &amp;&amp;</span><br><span class="line">              (!(mParent instanceof ViewGroup) ||</span><br><span class="line">                      !((ViewGroup) mParent).isViewTransitioning(this));</span><br><span class="line">  &#125;</span><br><span class="line"> ``` </span><br><span class="line">   *  2、通过View的标记位来判断孩子View是否需要重新绘制，如果没有变化的话，那么就不需要重新绘制</span><br></pre></td></tr></table></figure><p>mPrivateFlags &amp; (PFLAG_DRAWN | PFLAG_HAS_BOUNDS)) == (PFLAG_DRAWN |<br>PFLAG_HAS_BOUNDS)</p><pre><code>|| (invalidateCache &amp;&amp; (mPrivateFlags &amp; PFLAG_DRAWING_CACHE_VALID) == </code></pre><p>PFLAG_DRAWING_CACHE_VALID)</p><pre><code>     || (mPrivateFlags &amp; PFLAG_INVALIDATED) != PFLAG_INVALIDATED|| (fullInvalidate &amp;&amp; isOpaque() != mLastIsOpaque)</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  3、需要重新绘制的区域传递给父容器，向上传递事件，记住在这里 `damage`这个变量肯定不为`null`,要不然在这个方法里面就会直接抛出空指针异常。</span><br></pre></td></tr></table></figure><p>p.invalidateChild(this, damage);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  4、损坏整个投影接收机，如果不需要。` mBackground.isProjected()`： 这张画是否需要投影。</span><br></pre></td></tr></table></figure><p>if (mBackground != null &amp;&amp; mBackground.isProjected()) {</p><pre><code>    final View receiver = getProjectionReceiver();    if (receiver != null) {        receiver.damageInParent();    }}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">* 关键的方法：`ViewRootImpl.invalidateChild(this, damage);`</span><br></pre></td></tr></table></figure></li></ul><p>@Override<br>  public void invalidateChild(View child, Rect dirty) {</p><pre><code>invalidateChildInParent(null, dirty);</code></pre><p>  }</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*    invalidateChildInParent(null, dirty);进行了offset和union对坐标的调整，然后把dirty区域的信息保存在mDirty中，最后调用了`scheduleTraversals()`方法，触发View的工作流程，由于没有添加measure和layout的标记位，因此measure、layout流程不会执行，而是直接从`draw`流程开始.</span><br><span class="line">       ``` </span><br><span class="line">      @Override</span><br><span class="line">       public ViewParent invalidateChildInParent(int[] location, Rect dirty) &#123;</span><br><span class="line">        // 检查线程，不是ui线程，直接抛出异常</span><br><span class="line">        checkThread();</span><br><span class="line">         if (DEBUG_DRAW) Log.v(mTag, &quot;Invalidate child: &quot; + dirty);</span><br><span class="line"> </span><br><span class="line">        if (dirty == null) &#123;</span><br><span class="line">             invalidate();</span><br><span class="line">            return null;</span><br><span class="line">           &#125; else if (dirty.isEmpty() &amp;&amp; !mIsAnimating) &#123;</span><br><span class="line">              return null;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          if (mCurScrollY != 0 || mTranslator != null) &#123;</span><br><span class="line">            mTempRect.set(dirty);</span><br><span class="line">             dirty = mTempRect;</span><br><span class="line">            if (mCurScrollY != 0) &#123;</span><br><span class="line">                // 将dirty中的坐标转化为父容器中的坐标，考虑mScrollX和mScrollY的影响</span><br><span class="line">                dirty.offset(0, -mCurScrollY);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mTranslator != null) &#123;</span><br><span class="line">                mTranslator.translateRectInAppWindowToScreen(dirty);</span><br><span class="line">            &#125;</span><br><span class="line">            if (mAttachInfo.mScalingRequired) &#123;</span><br><span class="line">                dirty.inset(-1, -1);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         //进行了offset和union对坐标的调整</span><br><span class="line">         invalidateRectOnScreen(dirty);</span><br><span class="line"></span><br><span class="line">         return null;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><pre><code>*  1、检查线程，不是ui线程，直接抛出异常.和`requestLayout()`一样的  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkThread();</span><br></pre></td></tr></table></figure> *  2、如果是从 invalidate() 方法过来的话，那么dirty 肯定不为null  因为要是为null的话，前面调用方法的地方就抛出了空指针的异常 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (dirty == null) &#123;</span><br><span class="line">    invalidate();</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> * 3、通过将dx=0添加到其左、右坐标，并将 mCurScrollY 添加到其顶部和底部坐标来抵消矩形。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirty.offset(0, -mCurScrollY);</span><br></pre></td></tr></table></figure>  *   4、进行了offset和union对坐标的调整  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalidateRectOnScreen(dirty);</span><br></pre></td></tr></table></figure></code></pre></li><li><p>关于<code>invalidateRectOnScreen(dirty)</code>方法:最终的关键的方法： scheduleTraversals();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">private void invalidateRectOnScreen(Rect dirty) &#123;</span><br><span class="line">    final Rect localDirty = mDirty;</span><br><span class="line">    if (!localDirty.isEmpty() &amp;&amp; !localDirty.contains(dirty)) &#123;</span><br><span class="line">        mAttachInfo.mSetIgnoreDirtyState = true;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // Add the new dirty rect to the current one</span><br><span class="line">    // 添加一个新的 dirty rect 给当前的Rect</span><br><span class="line">    localDirty.union(dirty.left, dirty.top, dirty.right, dirty.bottom);</span><br><span class="line">    // Intersect with the bounds of the window to skip</span><br><span class="line">    // updates that lie outside of the visible region</span><br><span class="line">    final float appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    final boolean intersected = localDirty.intersect(0, 0,</span><br><span class="line">            (int) (mWidth * appScale + 0.5f), (int) (mHeight * appScale + 0.5f));</span><br><span class="line">    if (!intersected) &#123;</span><br><span class="line">        localDirty.setEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    if (!mWillDrawSoon &amp;&amp; (intersected || mIsAnimating)) &#123;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最终的关键的方法：<code>ViewRootImpl.scheduleTraversals();</code>，也就是会调用到这个对象<code>mTraversalRunnable</code>;也就是和<code>requessLaout()</code>最终调用的底层的方法一样，只不过对于<code>invalidate()</code>没有添加<code>measure()</code>和<code>layout()</code>的标记位，后面的流程也就不会执行！具体的流程可以看这篇文章<a href="https://www.jianshu.com/p/b63c6afa1844" target="_blank" rel="noopener">Android源码分析(View的绘制流程)</a></p></li><li>该方法的调用会引起<code>View</code>树的重绘，常用于内部调用(比如 setVisiblity())或者需要刷新界面的时候,需要在主线程(即UI线程)中调用该方法，<code>invalidate</code>有多个重载方法，但最终都会调用<code>invalidateInternal</code>方法，在这个方法内部，进行了一系列的判断，判断<code>View</code>是否需要重绘，接着为该<code>View</code>设置标记位，然后把需要重绘的区域传递给父容器，即调用父容器的<code>invalidateChild</code>方法。</li><li>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-f43b39cd42720e77.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="invalidate()的原理.jpg"></li></ul><h4 id="postInvalidate-的源码解析"><a href="#postInvalidate-的源码解析" class="headerlink" title="postInvalidate()的源码解析"></a>postInvalidate()的源码解析</h4><ul><li><p><code>view.postInvalidate()</code>继承一个Textview，然后重写方法，设置一个but，同时请求方法，打印日志：请求一次的输出的结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InvalidateTextView----------draw</span><br><span class="line">InvalidateTextView------------onDraw</span><br></pre></td></tr></table></figure></li><li><p><code>view.postInvalidate()</code>详情,由于方法是public，也可以调用一个时间，延迟多久开始执行，这里是delayMilliseconds，毫秒</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void postInvalidate() &#123;</span><br><span class="line">     postInvalidateDelayed(0);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>view.postInvalidateDelayed（）</code> 只有<code>attachInfo</code>不为null的时候才会继续执行，即只有确保视图被添加到窗口的时候才会通知view树重绘，因为这是一个异步方法，如果在视图还未被添加到窗口就通知重绘的话会出现错误，所以这样要做一下判断!</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void postInvalidateDelayed(long delayMilliseconds) &#123;</span><br><span class="line">     final AttachInfo attachInfo = mAttachInfo;</span><br><span class="line">     if (attachInfo != null) &#123;</span><br><span class="line">         attachInfo.mViewRootImpl.dispatchInvalidateDelayed(this, delayMilliseconds);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>ViewRootImpl.dispatchInvalidateDelayed()</code> 用了Handler，发送了一个异步消息到主线程，显然这里发送的是MSG_INVALIDATE，即通知主线程刷新视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * 用了Handler，发送了一个异步消息到主线程，显然这里发送的是`MSG_INVALIDATE`，即通知主线程刷新视图</span><br><span class="line">    * @param view  只有 postInvalidate() 使用了handler 来发送消息</span><br><span class="line">   * @param delayMilliseconds</span><br><span class="line">   */</span><br><span class="line">  public void dispatchInvalidateDelayed(View view, long delayMilliseconds) &#123;</span><br><span class="line">      Message msg = mHandler.obtainMessage(MSG_INVALIDATE, view);</span><br><span class="line">      mHandler.sendMessageDelayed(msg, delayMilliseconds);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>通知对象去<code>invalidate()</code> ，底层也是调用的是<code>invalidate()</code>，只不过使用了<code>mHandler</code>发送消息,在这里就发送到主线程了，去调用<code>invalidate()</code>方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">case MSG_INVALIDATE:</span><br><span class="line">              //通知对象去 invalidate ，底层也是调用的是 invalidate，只不过使用了handler发送消息</span><br><span class="line">              ((View) msg.obj).invalidate();</span><br><span class="line">              break;0</span><br></pre></td></tr></table></figure></li><li><p>方法的解释 ：<code>postInvalidate</code>是在非UI线程中调用,但是底层使用的是 <code>invalidate()</code>,通过<code>ViewRootImpl的内部handler： ViewRootHandler</code>发送的消息，但是也可以在 主线程中使用，如果在强制在主线程中使用，内部有个 <code>handler</code> 在工作，是不是显得有点浪费 ，对吧！</p></li><li><code>postInvalidate()</code>这个方法也可以主线程中使用</li><li><p>做了一张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a267e92df57adf3e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="postInvalidate()的原理.jpg"></p></li><li><p>最后说明几点</p><ul><li><code>invalidate()、postInvalidate()、requestLayout()</code>,最底层处调用的是<code>viewRootImpl.scheduleTraversals()</code> 这个方法，<code>requestLayout</code>由于设置了<code>measure</code>和<code>layout</code>的标记位，所以<code>requestLayout</code>可以重新走一次绘制的流程<ul><li><code>postInvalidate()</code> 底层通过<code>Handler</code>把非UI线程的工作，调用的是<code>invalidate()</code>.</li><li><code>invalidate()、requestLayout()</code>,方法都检查了是否在<code>UI</code>线程,不在的话，直接抛出异常，所以他们只能在UI线程中使用，<code>postInvalidate()</code>可以在UI线程和非UI线程中使用。</li><li><code>view</code>自身不在适合某个区域，比如说<code></code>LayoutParams<code>发生了改变，需要对其重新的测量、布局和绘制的三个流程，那么使用这个方法最合适</code>requestLayout()`。</li><li>如果说是在刷新当前的view，是当前的view进行重新的绘制，不会进行测量、布局流程。仅仅需要某个<code>view</code>重新绘制而不需要测量，使用<code>invalidate()方法往往比requestLayout()方法更高效</code></li></ul></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 源码解析 </tag>
            
            <tag> invalidate </tag>
            
            <tag> postInvalidate </tag>
            
            <tag> requestLayout </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Go语言实现RPC</title>
      <link href="/2018/07/19/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RPC/"/>
      <url>/2018/07/19/Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0RPC/</url>
      <content type="html"><![CDATA[<h4 id="RPC定义，来源于百度百科"><a href="#RPC定义，来源于百度百科" class="headerlink" title="RPC定义，来源于百度百科"></a>RPC定义，来源于百度百科</h4><ul><li>RPC（Remote Procedure Call）—<a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8" target="_blank" rel="noopener">远程过程调用</a>，它是一种通过<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">网络</a>从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。<a href="https://baike.baidu.com/item/RPC%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">RPC协议</a>假定某些<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输协议</a>的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1" target="_blank" rel="noopener">网络通信</a>模型中，RPC跨越了<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82" target="_blank" rel="noopener">传输层</a>和<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82" target="_blank" rel="noopener">应用层</a>。RPC使得开发包括网络<a href="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F" target="_blank" rel="noopener">分布式</a>多程序在内的应用程序更加容易。<a id="more"></a></li><li><p>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复<a href="https://baike.baidu.com/item/%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">信息</a>，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p></li><li><p>有多种 RPC模式和执行。最初由 Sun 公司提出。IETF ONC 宪章重新修订了 Sun 版本，使得 ONC RPC 协议成为 IETF 标准协议。现在使用最普遍的模式和执行是开放式软件基础的分布式计算<a href="https://baike.baidu.com/item/%E7%8E%AF%E5%A2%83" target="_blank" rel="noopener">环境</a>（DCE）。</p></li><li>个人的理解：不用管什么底层网络技术的协议，是一种通过网络从计算机程序上请求服务，通俗一点，我们写代码，要在一个地方，比如安卓，就需要在一个工程里面，才可以调用到其他的程序代码执行的过程。Go语言提供RPC支持使得开发网络分布式多程序在内的应用程序更加的<code>easy</code></li></ul><h4 id="RPC工作流程图"><a href="#RPC工作流程图" class="headerlink" title="RPC工作流程图"></a>RPC工作流程图</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-147298372fc05727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来源于gitHub"></p><ul><li>1.调用客户端句柄；执行传送参数</li><li>2.调用本地系统内核发送网络消息</li><li>3.消息传送到远程主机</li><li>4.服务器句柄得到消息并取得参数</li><li>5.执行远程过程</li><li>6.执行的过程将结果返回服务器句柄</li><li>7.服务器句柄返回结果，调用远程系统内核</li><li>8.消息传回本地主机</li><li>9.客户句柄由内核接收消息</li><li>10.客户接收句柄返回的数据</li></ul><h4 id="Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC-但是在Go中RPC是独一无二的，它采用了GoLang-Gob编码-只能支持Go语言！"><a href="#Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC-但是在Go中RPC是独一无二的，它采用了GoLang-Gob编码-只能支持Go语言！" class="headerlink" title="Go语言提供对RPC的支持：HTTP、TCP、JSPNRPC,但是在Go中RPC是独一无二的，它采用了GoLang Gob编码,只能支持Go语言！"></a>Go语言提供对RPC的支持：<code>HTTP、TCP、JSPNRPC</code>,但是在<code>Go</code>中<code>RPC</code>是独一无二的，它采用了<code>GoLang Gob</code>编码,只能支持Go语言！</h4><ul><li>GoLang Gob:是Golang包自带的一个数据结构序列化的编码/解码工具。编码使用Encoder，解码使用Decoder。一种典型的应用场景就是RPC(remote procedure calls)。</li></ul><h4 id="HTTP-RPC-Demo"><a href="#HTTP-RPC-Demo" class="headerlink" title="HTTP RPC Demo"></a>HTTP RPC Demo</h4><ul><li><p>服务端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">     rpcDemo()</span><br><span class="line">&#125;</span><br><span class="line">type Arith int</span><br><span class="line">func rpcDemo() &#123;</span><br><span class="line">arith:=new(Arith)</span><br><span class="line">//arith=== 0xc04204e090</span><br><span class="line">fmt.Println(&quot;arith===&quot;,arith)</span><br><span class="line"></span><br><span class="line">rpc.Register(arith)</span><br><span class="line">//HandleHTTP将RPC消息的HTTP处理程序注册到Debug服务器</span><br><span class="line">//DEFAUTUPCPATH和Debug调试路径上的调试处理程序。</span><br><span class="line">//仍然需要调用http.Services（），通常是在GO语句中。</span><br><span class="line">    rpc.HandleHTTP()</span><br><span class="line">err:=http.ListenAndServe(&quot;:1234&quot;,nil)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err=====&quot;,err.Error())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">type Args struct &#123;</span><br><span class="line">A, B int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Quotient struct &#123;</span><br><span class="line">Quo, Rem int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//函数必须是导出的(首字母大写)</span><br><span class="line">//必须有两个导出类型的参数，</span><br><span class="line">//第一个参数是接收的参数，第二个参数是返回给客户端的参数，第二个参数必须是指针类型的</span><br><span class="line">//函数还要有一个返回值error</span><br><span class="line">func (t *Arith) Multiply(args *Args, reply *int) error &#123;</span><br><span class="line">*reply = args.A * args.B</span><br><span class="line">fmt.Println(&quot;这个方法执行了啊---嘿嘿--- Multiply &quot;,reply)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (t *Arith) Divide(args *Args, quo *Quotient) error &#123;</span><br><span class="line">if args.B == 0 &#123;</span><br><span class="line">return errors.New(&quot;divide by zero&quot;)</span><br><span class="line">&#125;</span><br><span class="line">quo.Quo = args.A / args.B</span><br><span class="line">quo.Rem = args.A % args.B</span><br><span class="line">fmt.Println(&quot;这个方法执行了啊---嘿嘿--- Divide quo==&quot;,quo)</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go RPC 的函数只有符合四个条件才能够被远程访问，不然会被忽略</p><ul><li>函数必须是首字母大写（可以导出的）</li><li>必须有两个导出类型的参数 </li><li>第一个参数是接受的参数，第二个参数是返回给客户端的参数，而且第二个参数是指针的类型 </li><li>函数还要有一个返回值<code>error</code> </li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func (t *T) MethodName(argType T1, replyType *T2) error</span><br></pre></td></tr></table></figure><ul><li><p>T、T1和T2类型必须能被<code>encoding/gob</code>包编解码。</p></li><li><p>客户端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type ArgsTwo struct &#123;</span><br><span class="line">A, B int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type QuotientTwo struct &#123;</span><br><span class="line">Quo, Rem int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">// 如果什么都不输入的话 ，就是以下的这个值</span><br><span class="line">//os***************** [C:\Users\win7\AppData\Local\Temp\go-build669605574\command-</span><br><span class="line">//line-arguments\_obj\exe\GoRPCWeb.exe 127.0.0.1] **********************</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;os*****************&quot;,os.Args,&quot;**********************&quot;)</span><br><span class="line">if len(os.Args) != 4 &#123; //   todo  第二个地址是  我们本地的地址</span><br><span class="line">fmt.Println(&quot;老子要退出了哦 傻逼 一号start--------》》》&quot;, os.Args[0], &quot;《《《---------------server  end&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;长度是多少 &quot;+strconv.Itoa( len(os.Args))+&quot;才是准确的长度 哦---》&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    //获取输入的地址是获取输入得 os 数据的 第一个位置的值</span><br><span class="line">serverAddress := os.Args[1]</span><br><span class="line">    fmt.Println(&quot;severAddress==&quot;,serverAddress)</span><br><span class="line">// //DelayHTTP在指定的网络地址连接到HTTP RPC服务器</span><br><span class="line">///在默认HTTP RPC路径上监听。</span><br><span class="line">client, err := rpc.DialHTTP(&quot;tcp&quot;, serverAddress)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;发生错误了 在这里地方  DialHTTP&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">i1,_:=strconv.Atoi( os.Args[2])</span><br><span class="line">i2,_:=strconv.Atoi( os.Args[3])</span><br><span class="line">args := ArgsTwo&#123;i1, i2&#125;</span><br><span class="line">var reply int</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err = client.Call(&quot;Arith.Multiply&quot;, args, &amp;reply)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;Call Multiply  发生错误了哦   arith error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Arith 乘法: %d*%d=%d\n&quot;, args.A, args.B, reply)</span><br><span class="line"></span><br><span class="line">var quot QuotientTwo</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err = client.Call(&quot;Arith.Divide&quot;, args, &amp;quot)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;arith error:&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Arith 除法取整数: %d/%d=%d 余数 %d\n&quot;, args.A, args.B, quot.Quo, quot.Rem)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/5363507-2ebbd9d70053e8e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行的结果图"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoRPCWeb8.go 127.0.0.1:1234  20 3</span><br><span class="line">os***************** [C:\Users\win7\AppData\Local\Temp\go-build011170718\command-</span><br><span class="line">line-arguments\_obj\exe\GoRPCWeb8.exe 127.0.0.1:1234 20 3] *********************</span><br><span class="line">*</span><br><span class="line">长度是多少 4才是准确的长度 哦---》</span><br><span class="line">severAddress== 127.0.0.1:1234</span><br><span class="line">Arith 乘法: 20*3=60</span><br><span class="line">Arith 除法取整数: 20/3=6 余数 2</span><br></pre></td></tr></table></figure></p><ul><li>go run GoRPCWeb8.go 127.0.0.1:1234  20 3 <ul><li>go run 运行的命令 </li><li>GoRPCWeb8.go ：这是文件的名称，需要到指定的目录下启动<code>cmd</code> <ul><li>127.0.0.1:1234  ： ip地址和端口号</li></ul></li><li>20 3 这是客服端传入的值：一个除数，一个被除数，传入到服务器做乘法运算 乘法: <code>20*3=60</code>和除法取整数: <code>20/3=6</code> 余数 <code>2</code>,怎么做的，客户端不关心，给到服务端去完成</li></ul></li><li><code>os.Args[0]</code>=<code>[C:\Users\win7\AppData\Local\Temp\go-build011170718\command-line-arguments\_obj\exe\GoRPCWeb8.exe 127.0.0.1:1234 20 3]</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if len(os.Args) != 4 &#123; //   todo  第二个地址是  我们本地的地址</span><br><span class="line">fmt.Println(&quot;老子要退出了哦 傻逼 一号start--------》》》&quot;, os.Args[0], &quot;《《《---------------server  end&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;长度是多少 &quot;+strconv.Itoa( len(os.Args))+&quot;才是准确的长度 哦---》&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="TCP-RPC-Demo"><a href="#TCP-RPC-Demo" class="headerlink" title="TCP RPC Demo"></a>TCP RPC Demo</h4><ul><li><p>基于TCP协议实现的RPC，服务端的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">fmt.Println(&quot;基于TCP协议实现的RPC，服务端的代码如下&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type Me struct &#123;</span><br><span class="line">A,B int</span><br><span class="line">&#125;</span><br><span class="line">type You struct &#123;</span><br><span class="line">CC,D int</span><br><span class="line">&#125;</span><br><span class="line">type Num int</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">Go RPC的函数只有符合下面的条件才能够被远程访问，不然会被忽略</span><br><span class="line">1 函数必须是导出的（首字母大写）</span><br><span class="line">2 必须有两个导出类型的参数</span><br><span class="line">3 第一个参数是接受的参数，第二个参数是返回给客户端的参数，第二个参数必须是指正类型的</span><br><span class="line">4 函数还必须有一个返回值error</span><br><span class="line"> */</span><br><span class="line">func (n *Num) M(args *Me,reply *int) error  &#123;</span><br><span class="line">*reply=args.A * args.B</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func (n *Num) F(args * Me,u *You ) error  &#123;</span><br><span class="line">if  args.B==0&#123;</span><br><span class="line">return errors.New(&quot;输入不能够为0 被除数&quot;)</span><br><span class="line">&#125;</span><br><span class="line">u.D=args.A/args.B</span><br><span class="line">u.CC=args.A % args.B</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">//内建函数new本质上说跟其它语言中的同名函数功能一样：new(T)分配了零值填充的T类型的内存空间，并且返回其地址，即一个*T类型的值。用Go的术语说，它返回了一个指针，指向新分配的类型T的零值。有一点非常重要：</span><br><span class="line">//new返回指针。</span><br><span class="line">    num:=new(Num)</span><br><span class="line">    rpc.Register(num)</span><br><span class="line">    //ResolveTCPAddr返回TCP端点的地址。</span><br><span class="line">//网络必须是TCP网络名称。</span><br><span class="line">    tcpAddr,err:=net.ResolveTCPAddr(&quot;tcp&quot;,&quot;:1234&quot;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;错误了哦&quot;)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">    listener,err:=net.ListenTCP(&quot;tcp&quot;,tcpAddr)</span><br><span class="line">for  &#123;</span><br><span class="line">// todo   需要自己控制连接，当有客户端连接上来后，我们需要把这个连接交给rpc 来处理</span><br><span class="line">conn,err:=listener.Accept()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">rpc.ServeConn(conn)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于TCP客户端代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go&quot;)</span><br><span class="line"></span><br><span class="line">if len(os.Args)==4&#123;</span><br><span class="line">fmt.Println(&quot;长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip=&quot;,os.Args[1],&quot;嘿嘿,加上后面的被除数os.Args[2]=&quot;,os.Args[2],&quot;和除数os.Args[3]=&quot;,os.Args[3])</span><br><span class="line">//os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">    // 获取 ip 地址</span><br><span class="line">    service:= os.Args[1]</span><br><span class="line">    //连接 拨号连接到指定的网络地址的RPC服务器。</span><br><span class="line">    client,err:=rpc.Dial(&quot;tcp&quot;,service)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">log.Fatal(&quot;老子在连接Dial的发生了错误，我要退出了&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">num1:=os.Args[2]</span><br><span class="line">i1,error1:=strconv.Atoi(num1)</span><br><span class="line">if error1!=nil &#123;</span><br><span class="line">fmt.Println(&quot;自己不知道 自己输入错误了啊 请看error ：&quot;,error1)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">num2:=os.Args[3]</span><br><span class="line">i2,error2:=strconv.Atoi(num2)</span><br><span class="line">if error2!=nil &#123;</span><br><span class="line">fmt.Println(&quot;自己不知道 自己输入错误了啊 请看error ：&quot;,error2)</span><br><span class="line">os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line">aa:=AAA&#123;i1,i2&#125;</span><br><span class="line">var reply  int</span><br><span class="line">err1:=client.Call(&quot;Num.M&quot;,aa,&amp;reply)</span><br><span class="line"></span><br><span class="line">if err1 != nil&#123;</span><br><span class="line">log.Fatal(&quot;我要退出了，因为我在Call的时候发生了 错误&quot;,err1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;我进行正常结果如下&quot;)</span><br><span class="line">fmt.Printf(&quot;Num : %d*%d=%d\n&quot;,aa.A,aa.B,reply)</span><br><span class="line"></span><br><span class="line">var bb BDemo</span><br><span class="line">//调用调用命名函数，等待它完成，并返回其错误状态。</span><br><span class="line">err= client.Call(&quot;Num.F&quot;,aa,&amp;bb)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">log.Fatal(&quot;我对这个方法发生了过敏的反应 哈哈哈哈  err=====&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(&quot;Num: %d/%d=%d 余数 %d\n&quot;,aa.A,aa.B,bb.DD,bb.CC)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义两个类，那边需要操作的类</span><br><span class="line">type AAA struct &#123;</span><br><span class="line">A,B int</span><br><span class="line">&#125;</span><br><span class="line">//记住这里不能够大写 两个连着一起大写 有点意思</span><br><span class="line">//reading body gob: type mismatch: no fields matched compiling decoder for  DDDD</span><br><span class="line">//  todo 为啥 第二个参数  只要是两个连在一起的DDDD   就会报错   reading body gob: type mismatch: no fields matched compiling decoder for</span><br><span class="line">type BDemo struct &#123;</span><br><span class="line">DD, CC int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行结果图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-a4168e88f7eaf474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果图"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 1</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 1</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*1=20</span><br><span class="line">Num: 20/1=0 余数 0</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 2</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 2</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*2=40</span><br><span class="line">Num: 20/2=0 余数 0</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoTCPRPCWeb10.go 127.0.0.1:1234  20 3</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:1234 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= 20 和除数os.Args[3]= 3</span><br><span class="line">我进行正常结果如下</span><br><span class="line">Num : 20*3=60</span><br><span class="line">Num: 20/3=0 余数 2</span><br></pre></td></tr></table></figure><ul><li>在定义<code>BDemo</code> 的时候，  如果定义的<code>DD, CC int</code>和服务端不一样，就会报错  <code>reading body gob: type mismatch: no fields matched compiling decoder for</code> ,其实发现好多种情况，也会出现这种错误，但是目前不知道为啥会这样，后续，等源码深入一点，回来看这个问题    todo2018/07/19 </li><li><p>这种<code>TCP</code>方式和上面的<code>HTTP</code>不同的是</p><ul><li><p>HTTP:指定的网络地址连接到HTTP RPC服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">        //DelayHTTP在指定的网络地址连接到HTTP RPC服务器</span><br><span class="line">///在默认HTTP RPC路径上监听。</span><br><span class="line">client, err := rpc.DialHTTP(&quot;tcp&quot;, serverAddress)</span><br></pre></td></tr></table></figure></li><li><p>TCP:指定的网络地址连接到HTTP RPC服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client,err:=rpc.Dial(&quot;tcp&quot;,service)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="JSON-RPC"><a href="#JSON-RPC" class="headerlink" title="JSON RPC"></a>JSON RPC</h4><ul><li><p><code>JSON RPC</code>是数据编码采用了<code>JSON</code>，而不是<code>gob</code>编码，其他和上面介绍的<code>RPC</code>概念一模一样的。</p></li><li><p>服务端的代码如下</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;net/rpc&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;net/rpc/jsonrpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//使用Go提供的json-rpc 标准包</span><br><span class="line">func init() &#123;</span><br><span class="line">fmt.Println(&quot;JSON RPC 采用了JSON，而不是 gob编码，和RPC概念一模一样，&quot;)</span><br><span class="line">&#125;</span><br><span class="line">type Work struct &#123;</span><br><span class="line">Who,DoWhat string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DemoM string</span><br><span class="line"></span><br><span class="line">func (m *DemoM) DoWork(w *Work,whoT *string) error  &#123;</span><br><span class="line">    *whoT=&quot;是谁：&quot;+w.Who+&quot;，在做什么---&quot;+w.DoWhat</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    str:=new(DemoM)</span><br><span class="line">    rpc.Register(str)</span><br><span class="line"></span><br><span class="line">    tcpAddr,err:=net.ResolveTCPAddr(&quot;tcp&quot;,&quot;:8080&quot;)</span><br><span class="line">if  err!=nil&#123;</span><br><span class="line">fmt.Println(&quot;大哥发生错误了啊，请看错误 ResolveTCPAddr err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    listener,err:=net.ListenTCP(&quot;tcp&quot;,tcpAddr)</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">fmt.Println(&quot;发生错误了--》err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for  &#123;</span><br><span class="line"> conn,err:= listener.Accept()</span><br><span class="line">if err!=nil &#123;</span><br><span class="line">continue</span><br><span class="line">&#125;</span><br><span class="line">jsonrpc.ServeConn(conn)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>客户端的代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;net/rpc/jsonrpc&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;这是客户端，用来启动，通过命令行来启动&quot;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go&quot;)</span><br><span class="line"></span><br><span class="line">if len(os.Args)==4&#123;</span><br><span class="line">fmt.Println(&quot;长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip=&quot;,os.Args[1],&quot;嘿嘿,加上后面的被除数os.Args[2]=&quot;,os.Args[2],&quot;和除数os.Args[3]=&quot;,os.Args[3])</span><br><span class="line">//os.Exit(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> service:=os.Args[1]</span><br><span class="line"> client,err:=jsonrpc.Dial(&quot;tcp&quot;,service)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatal(&quot;Dial 发生了错误了哦 错误的信息为   err=&quot;,err)</span><br><span class="line">&#125;</span><br><span class="line">send:=Send&#123;os.Args[2],os.Args[3]&#125;</span><br><span class="line">var  resive  string</span><br><span class="line">err1:=client.Call(&quot;DemoM.DoWork&quot;,send,&amp;resive)</span><br><span class="line">if err1!=nil &#123;</span><br><span class="line">fmt.Println(&quot;shiming call error    &quot;)</span><br><span class="line">fmt.Println(&quot;Call 的时候发生了错误了哦  err=&quot;,err1)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;收到信息了&quot;,resive)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 类可以不一样 但是 Who 和DoWhat 要必须一样  要不然接收到不到值，等我在详细的了解了 才去分析下原因  感觉有点蒙蔽啊</span><br><span class="line">type Send struct &#123;</span><br><span class="line">Who, DoWhat string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行的结果如下<br><img src="https://upload-images.jianshu.io/upload_images/5363507-48090786abf0e69c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoJSONRPCWeb11.go 127.0.0.1:8080  shiming g</span><br><span class="line">ongzuo</span><br><span class="line">这是客户端，用来启动，通过命令行来启动</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:8080 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= shiming 和除数os.Args[3]= gongzuo</span><br><span class="line">收到信息了 是谁：shiming，在做什么---gongzuo</span><br><span class="line"></span><br><span class="line">E:\new_code\GoDemo\web_server&gt;go run GoJSONRPCWeb11.go 127.0.0.1:8080  shiming q</span><br><span class="line">iaodaima</span><br><span class="line">这是客户端，用来启动，通过命令行来启动</span><br><span class="line">客户端 其他端 去调用的地方  对应的例子是 GoTCPRPC9.go</span><br><span class="line">长度必须等于4,因为呢，你输入的肯定是一个ip的地址ip= 127.0.0.1:8080 嘿嘿,加上后面</span><br><span class="line">的被除数os.Args[2]= shiming 和除数os.Args[3]= qiaodaima</span><br><span class="line">收到信息了 是谁：shiming，在做什么---qiaodaima</span><br></pre></td></tr></table></figure><ul><li><code>os.Args</code>是一个数组  <code>var Args []string</code>,通过输入获取到，然后把这个客户端输入的内容传送到服务端，服务端做些操作，然后在返回给客户端 </li><li><code>Go</code>已经提供了<code>RPC</code>良好的支持，通过<code>HTTP</code> <code>TCP</code> <code>JSONRPC</code>的实现，可以很方便开发分布式的<code>Web</code>应用，但是我目前还不会，在学习中。遗憾的是<code>Go</code>没有提供<code>SOAP RPC</code>的支持~~~</li></ul>]]></content>
      
      
        <tags>
            
            <tag> Go </tag>
            
            <tag> Golang </tag>
            
            <tag> RPC </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
