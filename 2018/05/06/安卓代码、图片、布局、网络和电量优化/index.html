<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Shiming_Li" />



<meta name="description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布  写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！">
<meta name="keywords" content="安卓代码、图片、布局、网络和电量优化">
<meta property="og:type" content="article">
<meta property="og:title" content="安卓代码、图片、布局、网络和电量优化">
<meta property="og:url" content="http://yoursite.com/2018/05/06/安卓代码、图片、布局、网络和电量优化/index.html">
<meta property="og:site_name" content="仕明的后花园">
<meta property="og:description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布  写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-151e1acaa8105b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-bfcb14dc69cb04ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-6e976e35bf70ebbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-796b8e15dd7eda3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-8f5601da0c982aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-14T08:24:07.050Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="安卓代码、图片、布局、网络和电量优化">
<meta name="twitter:description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布  写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5363507-151e1acaa8105b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="仕明的后花园" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>安卓代码、图片、布局、网络和电量优化 | 仕明的后花园</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1add6c64d9c467153aaed18d249d81c4";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Shiming_Li</a></h1>
        </hgroup>

        
        <p class="header-subtitle">趁还能折腾的时候多学习！</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-9-正式版/">Android 9 正式版</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-P/">Android P</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android事件传递/">Android事件传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android源码/">Android源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/">ArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment-setNextAnim-int-on-a-null-object-reference/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler机制/">Handler机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet/">HashSet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jni/">Jni</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LayoutInflater/">LayoutInflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinckedList/">LinckedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedHashMap/">LinkedHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lint的使用/">Lint的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LruCache/">LruCache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOM/">OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLC/">PLC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PopupWindow/">PopupWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/So库/">So库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SparseArray/">SparseArray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vector/">Vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewStub/">ViewStub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/invalidate/">invalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postInvalidate/">postInvalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requestLayout/">requestLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setContentView源码解析/">setContentView源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作方式/">工作方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂文/">杂文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解（Annotation）/">注解（Annotation）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解析/">源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/田字格Demo/">田字格Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/绘制/">绘制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/谷歌/">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里域名/">阿里域名</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于移动开发，Go后台开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Shiming_Li</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Shiming_Li</a></h1>
            </hgroup>
            
            <p class="header-subtitle">趁还能折腾的时候多学习！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" target="_blank" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" target="_blank" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-安卓代码、图片、布局、网络和电量优化" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/" class="article-date">
      <time datetime="2018-05-06T08:23:16.000Z" itemprop="datePublished">2018-05-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      安卓代码、图片、布局、网络和电量优化
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布</li>
</ul>
<h4 id="写在前面的话，前段时间写了一篇文章-二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！"><a href="#写在前面的话，前段时间写了一篇文章-二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！" class="headerlink" title="写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！"></a>写在前面的话，前段时间写了一篇文章 <a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a>，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！</h4><a id="more"></a>
<h4 id="这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！"><a href="#这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！" class="headerlink" title="这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！"></a>这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-151e1acaa8105b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="Demo下载的地址"><a href="#Demo下载的地址" class="headerlink" title="Demo下载的地址"></a>Demo下载的地址</h4><p><img src="https://upload-images.jianshu.io/upload_images/5363507-bfcb14dc69cb04ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="F0xJ.png"></p>
<h4 id="代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）"><a href="#代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）" class="headerlink" title="代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）"></a>代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）</h4><p>数据集合的使用：建议最佳的做法是可能使用ArrayList作为首选，只要你需要使用额外的功能的时候，或者当程序性能由于经常从表的中间进行插入和删除而变差的时候，才会去选择LinkedList。HashMap性能上于HashTable相当，因为HashMap和HashTable在底层的存储和查找机制是一样的，但是TreeMap通常比HashMap要慢。HashSet总体上的性能比TreeSet好，特别实在添加和查询元素的时候，而这两个操作也是最重要的操作。TreeSet存在的唯一的原因是它可以维持元素的排序的状态，所以当需要一个排好序的Set，才使用TreeSet。因为其内部的结果欧支持排序，并且因为迭代是我们更有可能执行的操作，所以，用TreeSet迭代通常比用HashSet要快。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">       * 建议最佳的做法是可能使用ArrayList作为首选，只要你需要使用额外的功能的时候，或者当程序性能由于经常从表的中间进行</span><br><span class="line">       * 插入和删除而变差的时候，才会去选择LinkedList</span><br><span class="line">       */</span><br><span class="line">      //数据结构的选择，对于ArrayList，插入的操作特别高昂，并且其代价将随着列表的尺寸的增加而增加</span><br><span class="line">      ArrayList list=new ArrayList();</span><br><span class="line">      //需要执行大量的随机的访问，这个不是一个好的选择，如果是使用迭代器在列表中插入新的数据，使用这个，比较低廉（插入和移除的代价比较低廉）</span><br><span class="line">      LinkedList linkedList=new LinkedList();</span><br><span class="line">      //HashMap性能上于HashTable相当，因为HashMap和HashTable在底层的存储和查找机制是一样的，但是TreeMap通常比HashMap要慢</span><br><span class="line">      HashMap&lt;String,String&gt; hashMap=new HashMap&lt;&gt;();</span><br><span class="line">      /**</span><br><span class="line">       * HashSet总体上的性能比TreeSet好，特别实在添加和查询元素的时候，而这两个操作也是最重要的操作。TreeSet存在的唯一的原因是它</span><br><span class="line">       * 可以维持元素的排序的状态，所以当需要一个排好序的Set，才使用TreeSet。因为其内部的结果欧支持排序，并且因为迭代是我们更有可能</span><br><span class="line">       * 执行的操作，所以，用TreeSet迭代通常比用HashSet要快</span><br><span class="line">       */</span><br><span class="line">      HashSet&lt;String&gt;  hashSet=new HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      TreeSet&lt;String&gt; treeSet=new TreeSet&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>SparseArray是Android特有的稀疏数组的实现，他是Integer和Object的为例进行的一个映射用于代替 HsahMap&lt;Integer,<e>&gt;,提高性能。</e></p>
<ul>
<li>SparseArray<ul>
<li>线程不安全（多线程中需要注意）</li>
<li>由于要进行二分查找，（可以是有序的），SparseArray会对插入的数据按照Key的大小顺序插入</li>
<li>SparseArray对删除操作做了优化，它并不会立刻删除这个元素，而是通过设置标记位（DELETED）的方法，后面尝试重用。</li>
</ul>
</li>
</ul>
<p>内部核心的实现（二分查找）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">    * 二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。</span><br><span class="line">    * 但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</span><br><span class="line">    * @param array</span><br><span class="line">    * @param size</span><br><span class="line">    * @param value</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   //二分查找</span><br><span class="line">   static int binarySearch(int[] array, int size, int value) &#123;</span><br><span class="line">       int lo = 0;</span><br><span class="line">       int hi = size - 1;</span><br><span class="line"></span><br><span class="line">       while (lo &lt;= hi) &#123;</span><br><span class="line">           /**</span><br><span class="line">            * &gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用0填充。</span><br><span class="line">            * —比如你的例子，byte是8位的，-1表示为byte型是11111111(补码表示法）</span><br><span class="line">            * b&gt;&gt;&gt;4就是无符号右移4位，即00001111，这样结果就是15。</span><br><span class="line">            * 这里相当移动一位，除以二</span><br><span class="line">            */</span><br><span class="line">           final int mid = (lo + hi) &gt;&gt;&gt; 1;</span><br><span class="line">           final int midVal = array[mid];</span><br><span class="line"></span><br><span class="line">           if (midVal &lt; value) &#123;</span><br><span class="line">               lo = mid + 1;</span><br><span class="line">           &#125; else if (midVal &gt; value) &#123;</span><br><span class="line">               hi = mid - 1;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return mid;  // value found</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       //按位取反（~）运算符 ,没有找到，这个数据</span><br><span class="line">       return ~lo;  // value not present</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>SpareArray 家族有以下的四类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  //SpareArray 家族有以下的四类</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line">SparseBooleanArray sparseBooleanArray=new SparseBooleanArray();</span><br><span class="line">sparseBooleanArray.append(1,false);</span><br><span class="line">//用于替换    HashMap&lt;Integer,Interger&gt;</span><br><span class="line">SparseIntArray SparseIntArray=new SparseIntArray();</span><br><span class="line">SparseIntArray.append(1,1);</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line"></span><br><span class="line">@SuppressLint(&#123;&quot;NewApi&quot;, &quot;LocalSuppress&quot;&#125;)</span><br><span class="line">SparseLongArray SparseLongArray=new SparseLongArray();</span><br><span class="line">SparseLongArray.append(1,1111000L);</span><br><span class="line">//用于替换    HashMap&lt;Integer,boolean&gt;</span><br><span class="line">SparseArray&lt;String&gt; SparseArray11=new SparseArray&lt;String&gt;();</span><br><span class="line">SparseArray11.append(1,&quot;dd&quot;);</span><br></pre></td></tr></table></figure></p>
<p>SpareArray中的设计模式：原型模式:这里有使用到了的，原型模式内存中复制数据的，不会调用到类的构造的方法，而且访问的权限对原型模式无效</p>
<ul>
<li>优点： 1、性能提高。 2、逃避构造函数的约束。<ul>
<li>缺点：<pre><code>1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。
 2、必须实现 Cloneable 接口。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SparseArray&lt;String&gt; clone = sparseArray.clone();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>Handler正确的使用姿势（☺☺☺）<br>下面的代码是很多人都会这样写，这样会造成内存泄漏<br>原因：Handler是和Looper以及MessageQueue一起工作的，在安卓中，一个 应用启动了，系统会默认创建一个主线程服务的Looper对象 ，该Looper对象处理主线程的所有的Message消息，他的生命周期贯穿整个应用。在主线程中使用的Handler的都会默认的绑定到这个looper的对象，咋主线程中创建handler的时候，它会立即关联主线程Looper对象的MessageQueue，这时发送到的MessageQueue 中的Message对象都会持有这个Handler的对象的引用，这样Looper处理消息时Handler的handlerMessage的方法，因此，如果Message还没有处理完成，那么handler的对象不会立即被垃圾回收<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   /*-------------old ide 已经告诉我们这里可能内存泄露-------------------*/</span><br><span class="line">    @SuppressLint(&quot;HandlerLeak&quot;)</span><br><span class="line">    private final Handler mHandler=new Handler()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">//        mHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public void run() &#123;</span><br><span class="line">//                // TODO: 2018/4/28  用户即使退出了应用的话，这里也是会执行的 ，通过日记的观察</span><br><span class="line">//                //这里有可能用户退出了Activity</span><br><span class="line">//                System.out.println(&quot;shiming mHandler --todo&quot;);</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;,5000);</span><br></pre></td></tr></table></figure></p>
<p>如何避免，有两点的可以尝试</p>
<ul>
<li>1、在子线程中使用Handler，但是Handler不能再子线程中使用，需要开发者自己创建一个Looper对象，实现难，方法怪<ul>
<li>2、将handler声明为静态的内部类，静态内部类不会持有外部类的引用，因此，也不会引起内存泄露，</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  InnerHandler innerHandler = new InnerHandler(this);</span><br><span class="line">      innerHandler.postDelayed(new Runnable() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              //这里这要 退出了 就不会执行了</span><br><span class="line">              System.out.println(&quot;shiming innerHandler --todo&quot;);</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;,5000);</span><br><span class="line">public class InnerHandler extends Handler&#123;</span><br><span class="line">      //弱应用，在另外一个地方会讲到</span><br><span class="line">      private final WeakReference&lt;HandlerActivity&gt; mActivityWeakReference;</span><br><span class="line"></span><br><span class="line">      public InnerHandler(HandlerActivity activity)&#123;</span><br><span class="line">          mActivityWeakReference=new WeakReference&lt;HandlerActivity&gt;(activity);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Context正确的姿势<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Context的种类</span><br><span class="line">     //Application 全局唯一的Context实例</span><br><span class="line">     Application application = getApplication();</span><br><span class="line">     Context applicationContext = application.getApplicationContext();</span><br><span class="line">     //不同的Activity，得到这个Context，是独立的，不会进行复用</span><br><span class="line">     Context baseContext = this.getBaseContext();</span><br><span class="line"></span><br><span class="line">     MyBroadcaseRecriver myBroadcaseRecriver = new MyBroadcaseRecriver();</span><br><span class="line"></span><br><span class="line">     //ContentProvider 中的Context</span><br><span class="line"></span><br><span class="line">     /**</span><br><span class="line">      *如果创建单利必须需要使用到context对象</span><br><span class="line">      */</span><br><span class="line">     //这样不会内存泄露，不用改动单利类中代码</span><br><span class="line">     SingleInstance.getSingleInstance(getApplication().getApplicationContext());</span><br></pre></td></tr></table></figure></p>
<ul>
<li>单例模式，如果不得不传入Context，由于单例一直存在会导致Activity或者是Service的单例引用，从而不会被垃圾回收， Activity中的关联的View和数据结构也不会被释放，正确的方式应该使用Application中的Context</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class SingleInstance &#123;</span><br><span class="line">    private static SingleInstance sSingleInstance;</span><br><span class="line">    private final Context mContext;</span><br><span class="line"></span><br><span class="line">    private SingleInstance(Context context)&#123;</span><br><span class="line">        mContext = context;</span><br><span class="line">    &#125;</span><br><span class="line">//    因为每次调用实例都需要判断同步锁，很多项目包括很多人都是用这种的</span><br><span class="line">//    双重判断校验的方法，这种的方法看似很完美的解决了效率的问题，但是它</span><br><span class="line">//    在并发量不多，安全性不太高的情况下能完美的运行，但是，</span><br><span class="line">//    在jvm编译的过程中会出现指令重排的优化过程，这就会导致singleton实际上</span><br><span class="line">//    没有被初始化，就分配了内存空间，也就是说singleton！=null但是又没有被初始化，</span><br><span class="line">//    这就会导致返回的singletonthird返回的是不完整的</span><br><span class="line">    public static SingleInstance getSingleInstance(Context context)&#123;</span><br><span class="line">        if (sSingleInstance==null)&#123;</span><br><span class="line">            synchronized (SingleInstance.class)&#123;</span><br><span class="line">                if (sSingleInstance==null)   &#123;</span><br><span class="line">                    // TODO: 2018/4/28 注意外面传入的conext对象是否，是哪个 </span><br><span class="line">                    sSingleInstance= new SingleInstance(context);</span><br><span class="line">                    //第二种是改动代码，使用application 中的context变量</span><br><span class="line">                    sSingleInstance= new SingleInstance(context.getApplicationContext());</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return sSingleInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java 四种引用方式和引用队列的解释<br>和java一样，Android也是基于垃圾回收（GC）机制实现内存的自动的回收，垃圾回收的算法“标记-清除（Mark-Sweep）” “标记压缩（Mark-Compact）“复制算法（Copying）以及引用计数算法（Reference-Counting），安卓的虚拟机（Dalvik还是Art），都是使用标记清除算法。 在Android中，内存泄露是指不再使用的对象依然占有内存，或者是他们占用的内存没有得到释放， 从而导致内存空间不断的减少，由于可用的空间比较少，发生内存泄露会使得内存更加的紧张，甚至最终由于内存耗尽而发生的OOM，导致应用的崩溃。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> * 和java一样，Android也是基于垃圾回收（GC）机制实现内存的自动的回收，垃圾回收的算法“标记-清除（Mark-Sweep）”</span><br><span class="line"> * “标记压缩（Mark-Compact）“复制算法（Copying）以及引用计数算法（Reference-Counting），安卓的虚拟机（Dalvik还是Art），</span><br><span class="line"> * 都是使用标记清除算法”</span><br><span class="line"> *</span><br><span class="line"></span><br><span class="line">mTextView1.setText(des1);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 在Android中，内存泄露是指不再使用的对象依然占有内存，或者是他们占用的内存没有得到释放，</span><br><span class="line"> * 从而导致内存空间不断的减少，由于可用的空间比较少，发生内存泄露会使得内存更加的紧张，</span><br><span class="line"> * 甚至最终由于内存耗尽而发生的OOM，导致应用的崩溃</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">mTextView2.setText(des2);</span><br></pre></td></tr></table></figure>
<ul>
<li>强引用：Java中里面最广泛的使用的一种，也是对象默认的引用类型，如果又一个对象具有强引用，那么垃圾回收器是不会对它进行回收操作的，当内存的空间不足的时候，Java虚拟机将会抛OutOfMemoryError错误，这时应用将会被终止运行</li>
<li>软引用：一个对象如果只有一个软引用，那么当内存空间充足是，垃圾回收器不会对他进行回收操作，只有当内存空间不足的时候，这个对象才会被回收，软引用可以用来实现内存敏感的高速缓存，如果配合引用队列（ReferenceQueue使用，当软引用指向对象被垃圾回收器回收后，java会把这个软引用加入到与之关联的引用队列中）</li>
<li>弱引用：弱引用是比软引用更弱的一种的引用的类型，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不敢当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用</li>
<li><p>引用队列：ReferenceQueue一般是作为WeakReference SoftReference 的构造的函数参数传入的，在WeakReference 或者是 softReference 的指向的对象被垃圾回收后，ReferenceQueue就是用来保存这个已经被回收的Reference</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String des3=&quot;强引用：Java中里面最广泛的使用的一种，也是对象默认的引用类型，如果又一个对象具有强引用，那么垃圾回收器是不会对它进行回收操作的，当内存的空间不足的时候，Java虚拟机将会抛出OutOfMemoryError错误，这时应用将会被终止运行&quot;;</span><br><span class="line"></span><br><span class="line">mTextView3.setText(des3);</span><br><span class="line">String des4=&quot;软引用：一个对象如果只有一个软引用，那么当内存空间充足是，垃圾回收器不会对他进行回收操作，只有当内存空间不足的时候，这个对象才会被回收，软引用可以用来实现内存敏感的高速缓存，如果配合引用队列（ReferenceQueue使用，当软引用指向对象被垃圾回收器回收后，java会把这个软引用加入到与之关联的引用队列中）&quot;;</span><br><span class="line"></span><br><span class="line">Object obj=new Object();</span><br><span class="line"></span><br><span class="line">SoftReference&lt;Object&gt; sr = new SoftReference&lt;&gt;(obj);//这里使用了软引用...</span><br><span class="line">/*</span><br><span class="line"> *在这个期间，有可能会出现内存不足的情况发生，那么GC就会直接把所有的软引用全部清除..并释放内存空间</span><br><span class="line"> *如果内存空间足够的话，那么就GC就不会进行工作...</span><br><span class="line"> *GC的工作取决于内存的大小，以及其内部的算法,,,,</span><br><span class="line"> */</span><br><span class="line">if(sr!=null)&#123;</span><br><span class="line">    //如果软引用还存在，那么直接就可以获取这个对象的相关数据...这样就实现了cache...</span><br><span class="line">    obj = sr.get();</span><br><span class="line"></span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //如果已经不存在，表示GC已经将其回收，我们需要重新实例化对象，获取数据信息...</span><br><span class="line">    obj = new Object();</span><br><span class="line">    sr = new SoftReference&lt;&gt;(obj);</span><br><span class="line">&#125;</span><br><span class="line">mTextView4.setText(des4);</span><br><span class="line">String des5=&quot;弱引用：弱引用是比软引用更弱的一种的引用的类型，只有弱引用指向的对象的生命周期更短，当垃圾回收器扫描到只有具有弱引用的对象的时候，不敢当前空间是否不足，都会对弱引用对象进行回收，当然弱引用也可以和一个队列配合着使用&quot;;</span><br><span class="line"></span><br><span class="line">Object obj1 = new Object();</span><br><span class="line">WeakReference&lt;Object&gt; weakProductA = new WeakReference&lt;&gt;(obj1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mTextView5.setText(des5);</span><br><span class="line">String des6=&quot;虚引用：和软引用和弱引用不同，虚引用并不会对所指向的对象生命周期产生任何影响，也就是对象还是会按照它原来的方式别垃圾回收期回收，虚引用本质上只是有一个标记作用，主要用来跟踪对象被垃圾回收的活动，虚引用必须和引用队列配合使用，当对象被垃圾回收时，如果存在虚引用，那么Java虚拟机会将这个虚引用加入到与之关联的引用队列中&quot;;</span><br><span class="line"></span><br><span class="line">mTextView6.setText(des6);</span><br><span class="line">/**</span><br><span class="line"> * 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</span><br><span class="line"> * 虚引用主要用来跟踪对象被垃圾回收器回收的活动</span><br><span class="line"> */</span><br><span class="line">// TODO: 2018/5/2 程序可以通过判断引用队列中是否已经加入了虚引用，</span><br><span class="line">// 来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，</span><br><span class="line">// 那么就可以在所引用的对象的内存被回收之前采取必要的行动。</span><br><span class="line">ReferenceQueue queue = new ReferenceQueue ();</span><br><span class="line">PhantomReference pr = new PhantomReference&lt;Object&gt;(obj1, queue);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String des7=&quot;引用队列：ReferenceQueue一般是作为WeakReference SoftReference 的构造的函数参数传入的，在WeakReference 或者是 softReference 的指向的对象被垃圾回收后，ReferenceQueue就是用来保存这个已经被回收的Reference&quot;;</span><br><span class="line">mTextView7.setText(des7);</span><br></pre></td></tr></table></figure>
</li>
<li><p>将HashMap封装成一个线程安全的集合，并且使用软引用的方式防止OOM（内存不足）。由于在ListView中会加载大量的图片.那么为了有效的防止OOM导致程序终止的情况</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * list中使用大量的bitmap，这种情况的话，我自己感觉使用的比较少</span><br><span class="line">   */</span><br><span class="line">  public class MemoryCache &#123;</span><br><span class="line">      //将HashMap封装成一个线程安全的集合，并且使用软引用的方式防止OOM（内存不足）...</span><br><span class="line">      //由于在ListView中会加载大量的图片.那么为了有效的防止OOM导致程序终止的情况...</span><br><span class="line">      private Map&lt;String,SoftReference&lt;Bitmap&gt;&gt; cache=Collections.synchronizedMap(new HashMap&lt;String, SoftReference&lt;Bitmap&gt;&gt;());</span><br><span class="line"></span><br><span class="line">      public Bitmap get(String id)&#123;</span><br><span class="line">          if(!cache.containsKey(id))</span><br><span class="line">              return null;</span><br><span class="line">          SoftReference&lt;Bitmap&gt;ref=cache.get(id);</span><br><span class="line">          return ref.get();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void put(String id,Bitmap bitmap)&#123;</span><br><span class="line">          cache.put(id, new SoftReference&lt;Bitmap&gt;(bitmap));</span><br><span class="line">      &#125;</span><br><span class="line">      public void clear()&#123;</span><br><span class="line">          cache.clear();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的Demo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/2 14:50</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class EmployeeCache &#123;</span><br><span class="line">    static private EmployeeCache cache;// 一个Cache实例</span><br><span class="line">    private Hashtable&lt;String, EmployeeRef&gt; employeeRefs;// 用于Chche内容的存储</span><br><span class="line">    private ReferenceQueue&lt;Employee&gt; q;// 垃圾Reference的队列</span><br><span class="line"></span><br><span class="line">     // 继承SoftReference，使得每一个实例都具有可识别的标识。</span><br><span class="line">    // 并且该标识与其在HashMap内的key相同。</span><br><span class="line">    public class EmployeeRef extends SoftReference&lt;Employee&gt; &#123;</span><br><span class="line">        private String _key = &quot;&quot;;</span><br><span class="line">        public EmployeeRef(Employee em, ReferenceQueue&lt;Employee&gt; q) &#123;</span><br><span class="line">            super(em, q);</span><br><span class="line">            _key = em.getID();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 构建一个缓存器实例</span><br><span class="line">    private EmployeeCache() &#123;</span><br><span class="line">        employeeRefs = new Hashtable&lt;String, EmployeeRef&gt;();</span><br><span class="line">        q = new ReferenceQueue&lt;Employee&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 取得缓存器实例</span><br><span class="line">    public static EmployeeCache getInstance() &#123;</span><br><span class="line">        if (cache == null) &#123;</span><br><span class="line">            cache = new EmployeeCache();</span><br><span class="line">        &#125;</span><br><span class="line">        return cache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 以软引用的方式对一个Employee对象的实例进行引用并保存该引用</span><br><span class="line">    private void cacheEmployee(Employee em) &#123;</span><br><span class="line">        cleanCache();// 清除垃圾引用</span><br><span class="line">        EmployeeRef ref = new EmployeeRef(em, q);</span><br><span class="line">        employeeRefs.put(em.getID(), ref);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 依据所指定的ID号，重新获取相应Employee对象的实例</span><br><span class="line">    public Employee getEmployee(String ID) &#123;</span><br><span class="line">        Employee em = null;</span><br><span class="line">       // 缓存中是否有该Employee实例的软引用，如果有，从软引用中取得。</span><br><span class="line">        if (employeeRefs.containsKey(ID)) &#123;</span><br><span class="line">            EmployeeRef ref = (EmployeeRef) employeeRefs.get(ID);</span><br><span class="line">            em = (Employee) ref.get();</span><br><span class="line">        &#125;</span><br><span class="line">       // 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，</span><br><span class="line">       // 并保存对这个新建实例的软引用</span><br><span class="line">        if (em == null) &#123;</span><br><span class="line">            em = new Employee(ID);</span><br><span class="line">            System.out.println(&quot;Retrieve From EmployeeInfoCenter. ID=&quot; + ID);</span><br><span class="line">            this.cacheEmployee(em);</span><br><span class="line">        &#125;</span><br><span class="line">        return em;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除那些所软引用的Employee对象已经被回收的EmployeeRef对象</span><br><span class="line">    private void cleanCache() &#123;</span><br><span class="line">        EmployeeRef ref = null;</span><br><span class="line">        while ((ref = (EmployeeRef) q.poll()) != null) &#123;</span><br><span class="line">            employeeRefs.remove(ref._key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 清除Cache内的全部内容</span><br><span class="line">    public void clearCache() &#123;</span><br><span class="line">        cleanCache();</span><br><span class="line">        employeeRefs.clear();</span><br><span class="line">        //告诉垃圾收集器打算进行垃圾收集，而垃圾收集器进不进行收集是不确定的</span><br><span class="line">        System.gc();</span><br><span class="line">        //强制调用已经失去引用的对象的finalize方法</span><br><span class="line">        System.runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 当垃圾收集器认为没有指向对象实例的引用时，会在销毁该对象之前调用finalize()方法。</span><br><span class="line">     * 该方法最常见的作用是确保释放实例占用的全部资源。java并不保证定时为对象实例调用该方法，</span><br><span class="line">     * 甚至不保证方法会被调用，所以该方法不应该用于正常内存处理。</span><br><span class="line">     * @throws Throwable</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    protected void finalize() throws Throwable &#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/2 14:49</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line">    private String id;// 雇员的标识号码</span><br><span class="line">    private String name;// 雇员姓名</span><br><span class="line">    private String department;// 该雇员所在部门</span><br><span class="line">    private String Phone;// 该雇员联系电话</span><br><span class="line">    private int salary;// 该雇员薪资</span><br><span class="line">    private String origin;// 该雇员信息的来源</span><br><span class="line"></span><br><span class="line">    // 构造方法</span><br><span class="line">    public Employee(String id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        getDataFromlnfoCenter();</span><br><span class="line">    &#125;</span><br><span class="line">    // 到数据库中取得雇员信息</span><br><span class="line">    private void getDataFromlnfoCenter() &#123;</span><br><span class="line">// 和数据库建立连接井查询该雇员的信息，将查询结果赋值</span><br><span class="line">// 给name，department，plone，salary等变量</span><br><span class="line">// 同时将origin赋值为&quot;From DataBase&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getID() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他需要注意到的地方：</p>
<ul>
<li>1、不要重复的创建相同的对象，对象的创建都是需要内存分配的，对象的销毁需要垃圾回收，这些都在一定程度上影响程序的性能</li>
<li>2、对常量使用static final修饰，对于基本类型和String类型的常量，建议使用常量static final 修饰，因为final类型的常量会在静态dex文件的域初始化部分，这时对基本数据类型和String类型常量的调用不会涉及类的初始化，而是直接调用字面量</li>
<li>3、避免内部的get set方法的调用，get set的作用是对以外屏蔽具体的变量定义，从而达到更好的封装性，如果在类的内部调用get set的方法访问变量的话，会降低访问的速度，根据在安卓的官方的文档，在没有jit编译器时，直接访问变量的速度是调用get方法的3倍，在jit编译器，直接访问变量是调用get方法的7倍，当然使用了ProGuard的话，perGuard会对get set 进行内联的操作，从而达到直接访问的效果</li>
</ul>
<p>关于JIT：</p>
<ul>
<li>JIT是”Just In Time Compiler”的缩写，就是”即时编译技术”，与Dalvik虚拟机相关,JIT是在2.2版本提出的，目的是为了提高Android的运行速度，一直存活到4.4版本，因为在4.4之后的ROM中，就不存在Dalvik虚拟机了。 </li>
<li>编译打包APK文件:1、Java编译器将应用中所有Java文件编译为class文件,2、dx工具将应用编译输出的类文件转换为Dalvik字节码，即dex文件</li>
<li>Google在2.2版本添加了JIT编译器，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。<ul>
<li>dex字节码翻译成本地机器码是发生在应用程序的运行过程中的，并且应用程序每一次重新运行的时候，都要做重做这个翻译工作，所以这个工作并不是一劳永逸，每次重新打开App，都需要JIT编译，Dalvik虚拟机从Android一出生一直活到4.4版本，而JIT在Android刚发布的时候并不存在，在2.2之后才被添加到Dalvik中。</li>
</ul>
</li>
<li>AOT是”Ahead Of Time”的缩写，指的就是ART(Anroid RunTime)这种运行方式。<ul>
<li>JIT是运行时编译，这样可以对执行次数频繁的dex代码进行编译和优化，减少以后使用时的翻译时间，虽然可以加快Dalvik运行速度，但是还是有弊病，那就是将dex翻译为本地机器码也要占用时间，所以Google在4.4之后推出了ART，用来替换Dalvik。</li>
</ul>
</li>
<li>ART的策略与Dalvik不同，在ART 环境中，应用在第一次安装的时候，字节码就会预先编译成机器码，使其成为真正的本地应用。之后打开App的时候，不需要额外的翻译工作，直接使用本地机器码运行，因此运行速度提高。<ul>
<li>当然ART与Dalvik相比，还是有缺点的。<ul>
<li>ART需要应用程序在安装时，就把程序代码转换成机器语言，所以这会消耗掉更多的存储空间，但消耗掉空间的增幅通常不会超过应用代码包大小的20%</li>
<li>由于有了一个转码的过程，所以应用安装时间难免会延长<ul>
<li>但是这些与更流畅的Android体验相比而言，不值一提。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><p>四种图片格式</p>
<ul>
<li><p>JPEG</p>
<ul>
<li>是一种广泛使用的有损压缩图像标准格式，它不支持透明和多帧动画，一般摄影的作品是JEPG格式的，通过控制压缩比，可以调整图片的大小</li>
</ul>
</li>
<li><p>PNG</p>
<ul>
<li>是一种无损压缩的图片格式，他支持完整的透明通道，从图片处理的领域来讲，JEPG只有RGB三个通道，而PNG有ARGB四个通道，因此PNG图片占用空间一般比较大，会无形的增加app的大小，在做app瘦身时一般都要对PNG图片进行梳理以减小其占用的体积</li>
</ul>
</li>
</ul>
<ul>
<li><p>GIF</p>
<pre><code>* 是一种古老的图片的格式，诞生于1987年，随着初代互联网流行开来，他的特别是支持多帧动画，表情图，
</code></pre><ul>
<li>Webp<ul>
<li>google于2010年发布，支持有损和无损、支持完整的透明通道、也支持多帧动画，目前主流的APP都已经使用了Webp，淘宝，微信，即保证了图片的大小和质量</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>在安卓应用开发中能够使用编解码格式的只有三种 JEPG PNG WEBP<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 在安卓应用开发中能够使用编解码格式的只有三种 JEPG PNG WEBP</span><br><span class="line">  */</span><br><span class="line"> public enum CompressFormat &#123;</span><br><span class="line">     JPEG    (0),</span><br><span class="line">     PNG     (1),</span><br><span class="line">     WEBP    (2);//安卓4.0后开始支持</span><br><span class="line"></span><br><span class="line">     CompressFormat(int nativeInt) &#123;</span><br><span class="line">         this.nativeInt = nativeInt;</span><br><span class="line">     &#125;</span><br><span class="line">     final int nativeInt;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>推荐几种图片处理网站</p>
<ul>
<li>无损压缩ImageOptin，在不牺牲图片质量的前提下，即减下来PNG图片占用的空间，又提高了图片的加载速度  <a href="https://imageoptim.com/api" target="_blank" rel="noopener">https://imageoptim.com/api</a><br><img src="https://upload-images.jianshu.io/upload_images/5363507-6e976e35bf70ebbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="智图.png"></li>
</ul>
<ul>
<li><p>有损压缩ImageAlpha，图片大小得到极大的缩小，如果需要使用的话，一定要ui设计师看能否使用  <a href="https://pngmini.com/" target="_blank" rel="noopener">https://pngmini.com/</a></p>
</li>
<li><p>有损压缩TinyPNG 比较知名的png压缩的工具，也需要ui设计师看能够使用不  <a href="https://tinypng.com/" target="_blank" rel="noopener">https://tinypng.com/</a></p>
</li>
<li><p>PNG/JPEG 转化为 wepb  ：智图  ：<a href="http://zhitu.isux.us/" target="_blank" rel="noopener">http://zhitu.isux.us/</a></p>
</li>
</ul>
<p>如果ui设计师工作量不饱和的话，可以推荐， 尽量使用 .9.png 点9图   小黑点表示 可拉伸区域，黑边表示纵向显示内容的范围</p>
<p>####布局优化：如果创建的层级结构比较复杂，View树嵌套的层次比较深，那么将会使得页面的响应的时间变长，导致运行的时候越来越慢</p>
<ul>
<li>merge标签(对安卓的事件传递要达到源码级的熟悉才可以理解) 在某些场景下可以减少布局的层次,由于所有的Activity的根布局都是FrameLayout    Window   PhoneWindow  DecorView   事件的传递，包括设置setContentView 等的方法—&gt; 我会写一篇文章独立解释安卓事件的源码解析，会更加清楚的介绍这个类，(对安卓的事件传递要达到源码级的熟悉才可以理解)todo&lt;—–所以，当独立的一个布局文件最外层是FrameLayout的时候，并且和这个布局不需要设置 background 或者 padding的时候，可以使用<merge>标签来代替FrameLayout布局。另外一种的情况可以使用《merge》便签的情况是当前布局作为另外一个布局的子布局</merge></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">  &lt;include android:layout_height=&quot;50dp&quot;</span><br><span class="line">      android:layout_width=&quot;match_parent&quot;</span><br><span class="line">      layout=&quot;@layout/layout_include_merge&quot;</span><br><span class="line">      /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView android:gravity=&quot;center&quot;</span><br><span class="line">        android:text=&quot;merge 标签 在某些场景下可以减少布局的层次,由于所有的&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot; /&gt;</span><br><span class="line">&lt;/merge&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在安卓中经常会使用到相同的布局，比如说title，最佳的实践的方法就是把相同的布局抽取出来，独立成一个xml文件，需要使用到的时候，就把这个布局include进来，不仅减少了代码量，而且修改这个相同的布局，只需要修改一个地方即可.</p>
</li>
<li><p>ViewStub 是一种不可见的并且大小为0的试图，它可以延迟到运行时才填充inflate 布局资源，当Viewstub设为可见或者是inflate的时候，就会填充布局资源，这个布局和普通的试图就基本上没有任何区别，比如说，加载网络失败，或者是一个比较消耗性能的功能，需要用户去点击才可以加载，参考我的开源的项目 <a href="https://www.jianshu.com/p/6746d68ef2c3" target="_blank" rel="noopener">WritingPen</a></p>
</li>
</ul>
<p>注意事项：如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点</p>
<p>###———-&gt;2018.6.7修正这个说法，以前我说的是错误的，根本上的原因是ViewStub设置了 inflateid ，这才是更本身的原因,对不起！搞错了，还是要看源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   &lt;ViewStub</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:background=&quot;@color/colorPrimary&quot;</span><br><span class="line">        android:layout_gravity=&quot;center&quot;</span><br><span class="line">        android:inflatedId=&quot;@+id/find_view_stub&quot;</span><br><span class="line">        android:id=&quot;@+id/view_stub&quot;</span><br><span class="line">        android:layout=&quot;@layout/view_stub_imageview&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:padding=&quot;10dp&quot;</span><br><span class="line">    android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    &lt;!--如果这个根布局是个View，比如说是个ImagView，那么找出来的id为null，得必须注意这一点--&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:layout_marginTop=&quot;20dp&quot;</span><br><span class="line">        android:id=&quot;@+id/imageview&quot;</span><br><span class="line">        android:padding=&quot;10dp&quot;</span><br><span class="line">        android:src=&quot;@drawable/ic_launcher_background&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;/&gt;</span><br><span class="line">&lt;/FrameLayout&gt;</span><br></pre></td></tr></table></figure></p>
<p>调用todo: 2018/5/4 為啥為null  原因是布局文件中根布局只有View，没有ViewGroup，ViewStub.inflate() 的方法和 setVisibility 方法是差不多，因为 setVisibility方法会（看源码）走这个inflate的方法</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> if (null!=mViewStub.getParent())&#123;</span><br><span class="line">                    /*</span><br><span class="line">                    android:inflatedId 的值是Java代码中调用ViewStub的 inflate()或者是serVisibility方法返回的Id，这个id就是被填充的View的Id</span><br><span class="line">                     */</span><br><span class="line">                    /**</span><br><span class="line">                     * ViewStub.inflate() 的方法和 setVisibility 方法是差不多，因为 setVisibility方法会（看源码）走这个inflate的方法</span><br><span class="line">                     */</span><br><span class="line">//                    View inflate = mViewStub.inflate();</span><br><span class="line">                    mViewStub.setVisibility(View.VISIBLE);</span><br><span class="line">                    //inflate---&gt;android.support.v7.widget.AppCompatImageView&#123;de7e3a2 V.ED..... ......I. 0,0-0,0 #7f07003e app:id/find_view_stub&#125;</span><br><span class="line">//                    System.out.println(&quot;shiming inflate---&gt;&quot;+inflate);</span><br><span class="line">                    final View find_view_stub = findViewById(R.id.find_view_stub);</span><br><span class="line">                    System.out.println(&quot;shiming ----&quot;+find_view_stub);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    View iamgeivew11 = find_view_stub.findViewById(R.id.imageview);</span><br><span class="line">                    //himing ---- iamgeivew11null</span><br><span class="line">                    // TODO: 2018/5/4 為啥為null  原因是布局文件中根布局只有View，没有ViewGroup</span><br><span class="line">                    System.out.println(&quot;shiming ---- iamgeivew11&quot;+iamgeivew11);</span><br><span class="line"></span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    Toast.makeText(LayoutOptimizationActivity.this,&quot;已经inflate了&quot;,Toast.LENGTH_LONG).show();</span><br><span class="line">                    final View viewById = findViewById(R.id.find_view_stub);</span><br><span class="line">                    View iamgeivew = findViewById(R.id.imageview);</span><br><span class="line">                    //已经inflate了android.support.v7.widget.AppCompatImageView&#123;4637833 V.ED..... ........ 348,294-732,678 #7f07003e app:id/find_view_stub&#125;</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了&quot;+viewById);//</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了iamgeivew&quot;+iamgeivew);//已经inflate了iamgeivew==null</span><br><span class="line">                    View iamgeivew11 = viewById.findViewById(R.id.imageview);</span><br><span class="line">                    //已经inflate了 iamgeivew11null</span><br><span class="line">                    System.out.println(&quot;shiming l----已经inflate了 iamgeivew11&quot;+iamgeivew11);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>尽量使用CompoundDrawable,如果存在相邻的ImageView和TextView 的话</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;LinearLayout</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;150dp&quot;&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;我是文字&quot;</span><br><span class="line">        android:drawableBottom=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">   &lt;TextView</span><br><span class="line">       android:text=&quot;我是title2&quot;</span><br><span class="line">       android:drawableEnd=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">       android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">       android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">       android:drawableRight=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:text=&quot;我是文字33&quot;</span><br><span class="line">        android:drawableLeft=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:drawableStart=&quot;@mipmap/ic_launcher_round&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:drawableTop=&quot;@mipmap/ic_launcher_round&quot;</span><br><span class="line">        android:text=&quot;我是文字3&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot; /&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/5363507-796b8e15dd7eda3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>使用Lint 检查代码，和布局是否可以存在优化的地方，我会写个简单的经常遇见过的问题，同时完成一篇文档，加以说明,地址<a href="https://www.jianshu.com/p/d6068542b00b" target="_blank" rel="noopener">Lint的使用（安卓性能提升必备掌握的工具）</a></li>
</ul>
<h4 id="网络优化-移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量"><a href="#网络优化-移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量" class="headerlink" title="网络优化. 移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量"></a>网络优化. 移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量</h4><ul>
<li>2018年7月2日增加上网过程的说明流程（最近面试别人，发现好多同学这个都说的不太明白，特此说明下）：对于普通的上网，系统是这样做的：浏览器本身就是一个客户端，当你输入URL的时候，首先浏览器会去请求DNS服务器，通过DNS获取相应域名的对应的Ip地址，通过IP地址找到对应Ip对应的服务器，要求建立TCP连接，等浏览器发送完HTTP Request包后，服务器接受到请求包之后才开始处理请求包，服务器调用自身服务，返回Http Response （响应包）：客户端收到来自服务器的响应后开始渲染这个Response包里的主体（body）,等收到全部的内容随后断开与该服务器之间的TCP连接。具体的文章在这里<a href="https://www.jianshu.com/p/84aa55a8a7eb" target="_blank" rel="noopener">Web工作的方式</a></li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5363507-8f5601da0c982aed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图解"></p>
<ul>
<li>DNS域名的系统，主要的功能根据应用请求所用的域名URL去网络上面映射表中查相对应的IP地址，这个过程有可能会消耗上百毫秒，而且可能存在着DNS劫持的危险，可以替换为Ip直接连接的方式来代替域名访问的方法，从而达到更快的网络请求，但是使用Ip地址不够灵活，当后台变换了Ip地址的话，会出现访问不了，前段的App需要发包，解决方法是增加Ip地址动态更新的能力，或者是在IP地址访问失败了，切换到域名的访问.</li>
</ul>
<p>Demo—&gt;ping 一个地址，不正确的话，切换到备用的地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> boolean ping = ping(&quot;wwww.baidu.com&quot;);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">    * 测试主域名是否可用</span><br><span class="line">    *</span><br><span class="line">    * @param ip</span><br><span class="line">    * @return</span><br><span class="line">    */</span><br><span class="line">   private final int PING_TIME_OUT = 1000; // ping 超时时间</span><br><span class="line">   private boolean ping(String ip) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           Integer status = executeCommandIp( ip, PING_TIME_OUT );</span><br><span class="line">           if ( status != null &amp;&amp; status == 0 ) &#123;</span><br><span class="line">               return true;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; catch (TimeoutException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br><span class="line">  /**</span><br><span class="line">    * 执行域名是否可通</span><br><span class="line">    * @param command</span><br><span class="line">    * @param timeout</span><br><span class="line">    * @return</span><br><span class="line">    * @throws IOException</span><br><span class="line">    * @throws InterruptedException</span><br><span class="line">    * @throws TimeoutException</span><br><span class="line">    */</span><br><span class="line">   private int executeCommandIp( final String command, final long timeout )</span><br><span class="line">           throws IOException, InterruptedException, TimeoutException &#123;</span><br><span class="line">       Process process = Runtime.getRuntime().exec(</span><br><span class="line">               &quot;ping -c 1 -w 100 &quot; + command);</span><br><span class="line">       mWorker = new PingWorker(process);</span><br><span class="line">       mWorker.start();</span><br><span class="line">       try &#123;</span><br><span class="line">           mWorker.join(timeout);</span><br><span class="line">           if (mWorker.exit != null) &#123;</span><br><span class="line">               return mWorker.exit;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //throw new TimeoutException();</span><br><span class="line">               return -1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (InterruptedException ex) &#123;</span><br><span class="line">           mWorker.interrupt();</span><br><span class="line">           Thread.currentThread().interrupt();</span><br><span class="line">           throw ex;</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           process.destroy();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>PingWorker 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class PingWorker extends Thread &#123;</span><br><span class="line">       private final Process process;</span><br><span class="line">       private Integer exit;</span><br><span class="line">       private String ip;</span><br><span class="line"></span><br><span class="line">       public PingWorker(Process process) &#123;</span><br><span class="line">           this.process = process;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void run() &#123;</span><br><span class="line">           try &#123;</span><br><span class="line">               exit = process.waitFor();</span><br><span class="line">               if (exit == 0) &#123;</span><br><span class="line">                   BufferedReader buf = new BufferedReader(new InputStreamReader(process.getInputStream()));</span><br><span class="line">                   String str = new String();</span><br><span class="line">                   StringBuffer ipInfo = new StringBuffer();</span><br><span class="line"></span><br><span class="line">                   //读出所有信息并显示</span><br><span class="line">                   while((str=buf.readLine())!=null) &#123;</span><br><span class="line">                       ipInfo.append(str);</span><br><span class="line">                   &#125;</span><br><span class="line">                   /*</span><br><span class="line">                   PING sni1st.dtwscache.ourwebcdn.com (14.215.228.4) 56(84) bytes of data.64 bytes from 14.215.228.4: icmp_seq=1 ttl=57 time=16.6 ms--- sni1st.dtwscache.ourwebcdn.com ping statistics ---1 packets transmitted, 1 received, 0% packet loss, time 0msrtt min/avg/max/mdev = 16.656/16.656/16.656/0.000 ms</span><br><span class="line">                    */</span><br><span class="line">                   System.out.println(&quot;shiming ipInfo-----&gt;&quot;+ipInfo);</span><br><span class="line">                   Pattern mPattern = Pattern.compile(&quot;\\((.*?)\\)&quot;);</span><br><span class="line">                   Matcher matcher = mPattern.matcher(ipInfo.toString());</span><br><span class="line">                   if ( matcher.find() ) &#123;</span><br><span class="line">                       ip = matcher.group( 1 );</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               else &#123;</span><br><span class="line">                   ip = &quot; process.waitFor()===&quot;+exit;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           catch (IOException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">               ip=&quot;java.io.IOException: Stream closed&quot;;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">           catch (InterruptedException e) &#123;</span><br><span class="line">               ip=&quot;java.io.InterruptedException: Stream closed&quot;;</span><br><span class="line">               return;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>合并网络请求，一次完整的Http请求，首先进行的是DNS查找，通过TCP三次握手，从而建立连接，如果是https请求的话，还要经过TLS握手成功后才可以进行连接，对于网络请求，减少接口，能够合并的网络请求就尽量合并</p>
<ul>
<li>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。</li>
</ul>
<p>HTTPS和HTTP的区别主要为以下四点：</p>
<ul>
<li>一、https协议需要到ca申请证书，一般免费证书很少，需要交费。</li>
</ul>
</li>
<li>二、http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。</li>
<li>三、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li>
<li>四、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<ul>
<li><p>预先获取数据能够将网络请求集中在一次，这样其他时间段手机就可以切换到空闲的时间，从而避免经常性的唤醒，从而节约用电</p>
</li>
<li><p>避免轮询：如果说每个一段时间需要向服务器发起主动的网络请求，其实不建议在app端做这样的操作，可以使用推送，如果说在不得已的情况下，也要避免使用Thread.sleep()函数来循环等待，建议使用系统的AlarmManager来实现定时轮询，AlarmManager 可以保证在系统休眠的时候，CPU也可以得到休息，在下一次需要发起网络球球的时候才唤醒</p>
</li>
<li><p>尽量避免网络请求失败时候，无限制的循环重试连接，在我第一篇简书博客有写过一个网络加载的框架 ：<a href="https://www.jianshu.com/p/141ee58eb143" target="_blank" rel="noopener">https://www.jianshu.com/p/141ee58eb143</a>    中有提到过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//基于Rxjava 和 RxAndroid Retorfit</span><br><span class="line">        o.subscribeOn(Schedulers.io())</span><br><span class="line">              .retryWhen(new RetryWhenHandler(1, 5))</span><br><span class="line">              .doOnSubscribe(new Action0() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public void call() &#123;</span><br><span class="line">                      s.onBegin();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .subscribeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .unsubscribeOn(Schedulers.io())</span><br><span class="line">              .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">              .subscribe(s);</span><br></pre></td></tr></table></figure>
</li>
<li><p>离线缓存，对于图片或者文件，内存缓存+磁盘缓存+网络缓存，一般我们本地需要做的是二级缓存，当缓存中存在图片或者是文件，直接从缓存中读取，不会走网络，下载图片，在Android中使用LruCache实现内存缓存，<a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="noopener">DiskLruCache</a>实现本地缓存</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 图片缓存的核心类</span><br><span class="line">  */</span><br><span class="line"> private LruCache&lt;String, Bitmap&gt; mLruCache;</span><br><span class="line"> // 缓存大小</span><br><span class="line"> private static final int CACHE_MAX_SIZE = 1024;</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</span><br><span class="line">  */</span><br><span class="line"> private void lruCacheDemo() &#123;</span><br><span class="line">     // 获取应用程序最大可用内存</span><br><span class="line">     int maxMemory = (int) Runtime.getRuntime().maxMemory();</span><br><span class="line">     //设置LruCache缓存的大小，一般为当前进程可用容量的1/8。</span><br><span class="line">     int cacheSize = maxMemory / 8;</span><br><span class="line">     mLruCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123;</span><br><span class="line">         //重写sizeOf方法，计算出要缓存的每张图片的大小</span><br><span class="line">         //这个方法要特别注意，跟我们实例化 LruCache 的 maxSize 要呼应，怎么做到呼应呢，比如 maxSize 的大小为缓存的个数，这里就是 return 1就 ok，如果是内存的大小，如果5M，这个就不能是个数 了，这是应该是每个缓存 value 的 size 大小，如果是 Bitmap，这应该是 bitmap.getByteCount();</span><br><span class="line">         @Override</span><br><span class="line">         protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">             return value.getRowBytes() * value.getHeight();</span><br><span class="line">         &#125;</span><br><span class="line">         ////这里用户可以重写它，实现数据和内存回收操作</span><br><span class="line">         @Override</span><br><span class="line">         protected void entryRemoved(boolean evicted, String key, Bitmap oldValue, Bitmap newValue) &#123;</span><br><span class="line">             if (oldValue != newValue) &#123;</span><br><span class="line">                 oldValue.recycle();</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 从LruCache中获取一张图片，如果不存在就返回null。</span><br><span class="line">  */</span><br><span class="line"> private Bitmap getBitmapFromLruCache(String key) &#123;</span><br><span class="line">     return mLruCache.get(key);</span><br><span class="line"> &#125;</span><br><span class="line"> /**</span><br><span class="line">  * 往LruCache中添加一张图片</span><br><span class="line">  *</span><br><span class="line">  * @param key</span><br><span class="line">  * @param bitmap</span><br><span class="line">  */</span><br><span class="line"> private void addBitmapToLruCache(String key, Bitmap bitmap) &#123;</span><br><span class="line">     if (getBitmapFromLruCache(key) == null) &#123;</span><br><span class="line">         if (bitmap != null)</span><br><span class="line">             mLruCache.put(key, bitmap);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>压缩数据的大小：可以对发送服务端数据进行gzip压缩，同时可以使用更优的数据传输格式，例如二进制的代替Json格式，这个比较牛逼，估计运用的很少，使用webp格式代替图片格式</li>
</ul>
<ul>
<li>不同的网络环境使用不同的超时策略，常见的网络格式有 2g、3g、4g、wifi,实时的更新当前的网络状态，通过监听来获取最新的网络类型，并动态调整网络超时的时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private void netWorkDemo() &#123;</span><br><span class="line">       TextView netWork = findViewById(R.id.net_work);</span><br><span class="line">       boolean networkConnected = NetworkUtils.isNetworkConnected(this);</span><br><span class="line">       int networkType = NetworkUtils.getNetworkType(this);</span><br><span class="line"></span><br><span class="line">       System.out.println(&quot;shiming 是否联网了&quot;+networkConnected);</span><br><span class="line">       switch (networkType)&#123;</span><br><span class="line">           case TYPE_UNKNOWN:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---无网络连接&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---无网络连接&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_2G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---2G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---2G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_3G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_3G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_3G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_4G:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_4G&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_4G&quot;);</span><br><span class="line">               break;</span><br><span class="line">           case TYPE_WIFI:</span><br><span class="line">               System.out.println(&quot;shiming 联网的类型---TYPE_WIFI&quot;);</span><br><span class="line">               netWork.setText(&quot;是否联网了---》&quot;+networkConnected+&quot; 联网的类型---TYPE_WIFI&quot;);</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>NetworkUtils 类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.performanceoptimization.network_optimization;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.net.ConnectivityManager;</span><br><span class="line">import android.net.NetworkInfo;</span><br><span class="line">import android.telephony.TelephonyManager;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/28 10:52</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * des:网络连接工具类</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class NetworkUtils &#123;</span><br><span class="line">    private static final String SUBTYPE_TD_SCDMA = &quot;SCDMA&quot;;</span><br><span class="line">    private static final String SUBTYPE_WCDMA = &quot;WCDMA&quot;;</span><br><span class="line">    private static final String SUBTYPE_CDMA2000 = &quot;CDMA2000&quot;;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判断是否已连接到网络.</span><br><span class="line">     *</span><br><span class="line">     * @param context Context</span><br><span class="line">     * @return 是否已连接到网络</span><br><span class="line">     */</span><br><span class="line">    public static boolean isNetworkConnected(Context context) &#123;</span><br><span class="line">        ConnectivityManager connectivity = (ConnectivityManager) context.getSystemService(Context</span><br><span class="line">                .CONNECTIVITY_SERVICE);</span><br><span class="line">        if (connectivity != null) &#123;</span><br><span class="line">            NetworkInfo info = connectivity.getActiveNetworkInfo();</span><br><span class="line">            if (info != null &amp;&amp; info.isConnected()) &#123;</span><br><span class="line">                if (info.getState() == NetworkInfo.State.CONNECTED) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 获取当前网络类型</span><br><span class="line">     *</span><br><span class="line">     * @param context Context</span><br><span class="line">     * @return 当前网络类型(Unknown, 2G, 3G, 4G, WIFI)</span><br><span class="line">     */</span><br><span class="line">    public static int getNetworkType(Context context) &#123;</span><br><span class="line">        NetworkInfo info = ((ConnectivityManager) context.getSystemService(</span><br><span class="line">                Context.CONNECTIVITY_SERVICE)).getActiveNetworkInfo();</span><br><span class="line">        if (info != null &amp;&amp; info.isConnected()) &#123;</span><br><span class="line">            if (info.getType() == ConnectivityManager.TYPE_WIFI) &#123;</span><br><span class="line">                return NetworkType.TYPE_WIFI;</span><br><span class="line">            &#125; else if (info.getType() == ConnectivityManager.TYPE_MOBILE) &#123;</span><br><span class="line">                switch (info.getSubtype()) &#123;</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_GPRS:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EDGE:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_CDMA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_1xRTT:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_IDEN: //api&lt;8 : replace by 11</span><br><span class="line">                        return NetworkType.TYPE_2G;</span><br><span class="line"></span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_UMTS:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_0:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_A:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSDPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSUPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSPA:</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EVDO_B: //api&lt;9 : replace by 14</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_EHRPD:  //api&lt;11 : replace by 12</span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_HSPAP:  //api&lt;13 : replace by 15</span><br><span class="line">                        return NetworkType.TYPE_3G;</span><br><span class="line"></span><br><span class="line">                    case TelephonyManager.NETWORK_TYPE_LTE:    //api&lt;11 : replace by 13</span><br><span class="line">                        return NetworkType.TYPE_4G;</span><br><span class="line"></span><br><span class="line">                    default:</span><br><span class="line">                        // http://baike.baidu.com/item/TD-SCDMA 中国移动 联通 电信 三种3G制式</span><br><span class="line">                        String subtypeName = info.getSubtypeName();</span><br><span class="line">                        if (SUBTYPE_TD_SCDMA.equalsIgnoreCase(subtypeName) ||</span><br><span class="line">                                SUBTYPE_WCDMA.equalsIgnoreCase(subtypeName) ||</span><br><span class="line">                                SUBTYPE_CDMA2000.equalsIgnoreCase(subtypeName)) &#123;</span><br><span class="line">                            return NetworkType.TYPE_3G;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            return NetworkType.TYPE_UNKNOWN;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return NetworkType.TYPE_UNKNOWN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NetworkType类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.shiming.performanceoptimization.network_optimization;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/4/28 10:52</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> * des:网络连接类型常量</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class NetworkType &#123;</span><br><span class="line">    /**</span><br><span class="line">     * 无网络连接</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_UNKNOWN = -1;</span><br><span class="line">    /**</span><br><span class="line">     * 2G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_2G = 0;</span><br><span class="line">    /**</span><br><span class="line">     * 3G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_3G = 1;</span><br><span class="line">    /**</span><br><span class="line">     * 4G</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_4G = 2;</span><br><span class="line">    /**</span><br><span class="line">     * WIFI</span><br><span class="line">     */</span><br><span class="line">    public static final int TYPE_WIFI = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。</li>
</ul>
<p>####电量优化</p>
<ul>
<li><p>1、（BroadCastReceiver）为了减少应用耗损的电量，我们在代码中尽量避免使用无用的操作代码，当应用退到后台了，一切页面的刷新都是没有意义的，并且浪费电，比如有个监听网络状态的广播并执行一些动作，弹窗或者是Toast，那么app需要在后台的时候，禁用掉这个功能，</p>
</li>
<li><p>2、数据传输    蓝牙传输，Wi-Fi传输  移动网络传输  后台数据的管理：根据业务需求，接口尽量避免无效数据的传输  数据传输的频度问题：通过经验值或者是数据统计的方法确定好数据传输的频度，避免冗余重复的数据传输，数据传输过程中要压缩数据的大小，合并网络请求，避免轮询</p>
</li>
<li><p>3、位置服务 正确的使用位置复位，是应用耗电的一个关键     </p>
<ul>
<li><p>需要注意以下的三点：</p>
<ul>
<li>1、有没有及时注销位置监听器：和广播差不多<ul>
<li>2、位置更新监听频率的设定；更加业务需求设置一个合理的更新频率值，<ul>
<li>minTime:用来指定间更新通知的最小的时间间隔，单位是毫秒，看日志这里是1s更新的</li>
<li>minDistance:用来指定位置更新通知的最小的距离，单位是米</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>3、Android提供了三种定位<ul>
<li>GPS定位，通过GPS实现定位，精度最高，通常在10米（火星坐标），但是GPS定位在时间和电量上消耗也是最高的</li>
<li>网络定位，通过移动通信的基站信号差异来计算出手机所在的位置，精度比GPS差好多</li>
<li>被动定位，最省电的定位服务，如果使用被动定位服务。说明它想知道位置更新信息但有不主动获取，等待手机中其他应用或者是服务或者是系统组件发出定位请求，并和这些组件的监听器一起接收位置的信息，实际的开发中，一般使用的是第三方的地图，高德，腾讯，百度，他们做了很好的封装，同时在地图上的表现上更加的优化<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">        /**</span><br><span class="line">         *   //设置定位精确度 Criteria.ACCURACY_COARSE比较粗略，Criteria.ACCURACY_FINE则比较精细</span><br><span class="line">         *         criteria.setAccuracy(Criteria.ACCURACY_FINE);</span><br><span class="line">         *         //设置是否要求速度</span><br><span class="line">         *         criteria.setSpeedRequired(false);</span><br><span class="line">         *         // 设置是否允许运营商收费</span><br><span class="line">         *         criteria.setCostAllowed(false);</span><br><span class="line">         *         //设置是否需要方位信息</span><br><span class="line">         *         criteria.setBearingRequired(false);</span><br><span class="line">         *         //设置是否需要海拔信息</span><br><span class="line">         *         criteria.setAltitudeRequired(false);</span><br><span class="line">         *         // 设置对电源的需求</span><br><span class="line">         *         criteria.setPowerRequirement(Criteria.POWER_LOW);</span><br><span class="line">         */</span><br><span class="line">        Criteria criteria = new Criteria();</span><br><span class="line">        criteria.setAccuracy(Criteria.ACCURACY_FINE);</span><br><span class="line">        criteria.setAltitudeRequired(false);</span><br><span class="line">        criteria.setBearingRequired(false);</span><br><span class="line">        criteria.setCostAllowed(true);</span><br><span class="line">        criteria.setPowerRequirement(Criteria.POWER_LOW);</span><br><span class="line">        String serviceName = Context.LOCATION_SERVICE;</span><br><span class="line">        mLocationManager = (LocationManager) getSystemService(serviceName);</span><br><span class="line">//        locationManager.setTestProviderEnabled(&quot;gps&quot;, true);</span><br><span class="line">        // TODO: 2018/5/3 IllegalArgumentException &apos;Provider &quot;gps&quot; unknown&quot;   https://www.cnblogs.com/ok-lanyan/archive/2011/10/12/2208378.html</span><br><span class="line">        mLocationManager.addTestProvider(LocationManager.GPS_PROVIDER,</span><br><span class="line">                &quot;requiresNetwork&quot; == &quot;&quot;, &quot;requiresSatellite&quot; == &quot;&quot;, &quot;requiresCell&quot; == &quot;&quot;, &quot;hasMonetaryCost&quot; == &quot;&quot;,</span><br><span class="line">                &quot;supportsAltitude&quot; == &quot;&quot;, &quot;supportsSpeed&quot; == &quot;&quot;,</span><br><span class="line">                &quot;supportsBearing&quot; == &quot;&quot;, android.location.Criteria.POWER_LOW,</span><br><span class="line">                android.location.Criteria.ACCURACY_FINE);</span><br><span class="line">        mProvider = mLocationManager.getBestProvider(criteria, true);</span><br><span class="line"></span><br><span class="line">        //获取纬度</span><br><span class="line">        //获取经度</span><br><span class="line">        mLlistener = new LocationListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onLocationChanged(Location location) &#123;</span><br><span class="line">                // thread is not runable, msg ignore, state:TIMED_WAITING, 这里的线程有可能ANR</span><br><span class="line">                if (location != null) &#123;</span><br><span class="line">                    double lat = location.getLatitude();//获取纬度</span><br><span class="line">                    double lng = location.getLongitude();//获取经度</span><br><span class="line">                    System.out.println(&quot;shiming   lat+&quot; + lat);</span><br><span class="line">                    System.out.println(&quot;shiming   lng+&quot; + lng);</span><br><span class="line">                    String name = Thread.currentThread().getName();</span><br><span class="line">                    mCount++;</span><br><span class="line">                    System.out.println(&quot;当前线程的位置name---&quot;+name+&quot;i===&quot;+mCount);</span><br><span class="line">                    mTv_location.setText(&quot;位置信息是2s变动的，可以设置,我是第&quot;+mCount+&quot;次变动的---&gt;&quot;+&quot;\n\r&quot;+&quot;lat====&quot;+lat+&quot;      lng-----&gt;&quot;+lng);</span><br><span class="line">                &#125;</span><br><span class="line">                if (mLocationManager!=null) &#123;</span><br><span class="line">                    mLocationManager.removeUpdates(this);</span><br><span class="line">                    if (mLocationManager.isProviderEnabled(LocationManager.NETWORK_PROVIDER)) &#123;</span><br><span class="line">                        mLocationManager.requestLocationUpdates(LocationManager.NETWORK_PROVIDER, 2000, 1000, mLlistener);</span><br><span class="line">                    &#125;else &#123;</span><br><span class="line">                        mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, 2000, 1000, mLlistener);</span><br><span class="line">                    &#125;</span><br><span class="line">//                     TODO: 2018/5/3  这里在报错了，我把他注释掉</span><br><span class="line">//                mLocationManager.setTestProviderEnabled(mProvider, false);//   java.lang.IllegalArgumentException: Provider &quot;network&quot; unknown</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProviderDisabled(String provider) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onProviderEnabled(String provider) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void onStatusChanged(String provider, int status,</span><br><span class="line">                                        Bundle extras) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        /**</span><br><span class="line">         * minTime:用来指定间更新通知的最小的时间间隔，单位是毫秒，看日志这里是1s更新的</span><br><span class="line">         * minDistance:用来指定位置更新通知的最小的距离，单位是米</span><br><span class="line">         */</span><br><span class="line">        mLocationManager.requestLocationUpdates(mProvider, 2000, (float) 1000.0, mLlistener);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在OnDestroy 变量手动值为null，我在测试过程中，只有在值为null的时候这个位置监听才会停止，有兴趣的小伙伴，可以好好看看值为null，底层会做什么操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">     * 记得需要销毁这个监听,</span><br><span class="line">     * todo 如果不手动置为null的话，其实您可以通过日记发现，这个监听还是一直在走的，所以说这里手动值为null的好处</span><br><span class="line">     */</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        if (mAm!=null)&#123;</span><br><span class="line">            mAm.cancel(mPi);</span><br><span class="line">            mAm=null;//变为null</span><br><span class="line">        &#125;</span><br><span class="line">        if (null!=mTag)&#123;</span><br><span class="line">            mTag.release();</span><br><span class="line">            //释放唤醒锁锁</span><br><span class="line">            mTag=null;</span><br><span class="line">        &#125;</span><br><span class="line">        mLocationManager.removeUpdates(mLlistener);</span><br><span class="line">        if (mLocationManager != null) &#123;</span><br><span class="line">            mLocationManager.removeUpdates(mLlistener);</span><br><span class="line">            mLocationManager = null;//不用分配空间</span><br><span class="line">        &#125;</span><br><span class="line">        if (mLlistener != null) &#123;</span><br><span class="line">            mLlistener = null;</span><br><span class="line">        &#125;</span><br><span class="line">        //   mLocationManager.setTestProviderEnabled(mProvider, false);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>WakeLock 是为了保持设备的唤醒状态的API，组织用户长时间不用，仍然需要组织设备进入休眠的状态，比如用户在看电影的时候。使用wakelock 时，需要及时的释放锁，比如播放视屏的时候WakeLock保持屏幕的常亮，在暂停的时候就应该释放锁，而不是等到停止播放才释放。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> @SuppressLint(&quot;WakelockTimeout&quot;)</span><br><span class="line">    private void wakeLockDemo() &#123;</span><br><span class="line">//        PowerManager.PARTIAL_WAKE_LOCK;//保持CPU正常运转，但屏幕和键盘灯有可能是关闭的</span><br><span class="line">//        PowerManager.SCREEN_DIM_WAKE_LOCK://保持CPU正常运转，允许屏幕点亮但可能是置灰的，键盘灯可能是关闭的</span><br><span class="line">//        PowerManager.SCREEN_BRIGHT_WAKE_LOCK;//保持CPU正常的运转，允许屏幕高亮显示，键盘灯可能是关闭的</span><br><span class="line">//        PowerManager.FULL_WAKE_LOCK;//保持CPU正常运转，保持屏幕高亮显示，键盘灯也保持连读</span><br><span class="line">//        PowerManager.ACQUIRE_CAUSES_WAKEUP;//强制屏幕和键盘灯亮起，这种锁针对必须通知用户的操作</span><br><span class="line">//        PowerManager.ON_AFTER_RELEASE;//当WakeLock被释放了，继续保持屏幕和键盘灯开启一定的时间</span><br><span class="line">        PowerManager powerManager = (PowerManager) this.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">        /**</span><br><span class="line">         *   case PARTIAL_WAKE_LOCK:</span><br><span class="line">         *             case SCREEN_DIM_WAKE_LOCK:</span><br><span class="line">         *             case SCREEN_BRIGHT_WAKE_LOCK:</span><br><span class="line">         *             case FULL_WAKE_LOCK:</span><br><span class="line">         *             case PROXIMITY_SCREEN_OFF_WAKE_LOCK:</span><br><span class="line">         *             case DOZE_WAKE_LOCK:</span><br><span class="line">         *             case DRAW_WAKE_LOCK:</span><br><span class="line">         */</span><br><span class="line">        mTag = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;Tag&quot;);</span><br><span class="line">        if (null!= mTag)&#123;</span><br><span class="line">            mTag.acquire();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AlarmManager 也是比较耗电的，通常情况下需要保证两次唤醒操作的时间间隔不要太短了，在不需要使用唤醒功能的情况下，尽早的取消唤醒功能，否则应用会一直消耗电量 AlarmManager 是SDK提供的一个唤醒的APi，是系统级别的服务，可以在特定的时刻广播一个指定的Intent，这个pendingIntent可以用来启动Activity、Service、BroadcastReceiver， app，在后台也会启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  private void alarmManager() &#123;</span><br><span class="line">        //创建Intent对象，action为ELITOR_CLOCK，附加信息为字符串“你该打酱油了”</span><br><span class="line">        Intent intent = new Intent(&quot;action&quot;);</span><br><span class="line">        intent.putExtra(&quot;msg&quot;,&quot;重启---App ---Le  -- 回到前台&quot;);</span><br><span class="line">//        intent.setClass(ElectricQuantityOptimizationActivity.this,MainActivity.class);</span><br><span class="line">        //定义一个PendingIntent对象，PendingIntent.getBroadcast包含了sendBroadcast的动作。</span><br><span class="line">        //也就是发送了action 为&quot;action&quot;的intent</span><br><span class="line">        mPi = PendingIntent.getBroadcast(this,0,intent,0);</span><br><span class="line"></span><br><span class="line">       //AlarmManager对象,注意这里并不是new一个对象，Alarmmanager为系统级服务</span><br><span class="line">        mAm = (AlarmManager)getSystemService(ALARM_SERVICE);</span><br><span class="line"></span><br><span class="line">       //设置闹钟从当前时间开始，每隔5s执行一次PendingIntent对象pi，注意第一个参数与第二个参数的关系</span><br><span class="line">        // 5秒后通过PendingIntent pi对象发送广播</span><br><span class="line">        assert mAm != null;</span><br><span class="line">        /**</span><br><span class="line">         * 频繁的报警对电池寿命不利。至于API 22，警报管理器将覆盖近期和高频报警请求，</span><br><span class="line">         * 在未来至少延迟5秒的警报，并确保重复间隔至少为60秒,如果真的需要间隔很短的话，官方建议使用handler</span><br><span class="line">         * 该方法用于设置重复闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟首次执行时间，</span><br><span class="line">         * 第三个参数表示闹钟两次执行的间隔时间，第三个参数表示闹钟响应动作。</span><br><span class="line">         */</span><br><span class="line">        mAm.setRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),1000, mPi);</span><br><span class="line">        //该方法用于设置一次性闹钟，第一个参数表示闹钟类型，第二个参数表示闹钟执行时间，第三个参数表示闹钟响应动作。</span><br><span class="line">        //am.set(AlarmManager.RTC_WAKEUP,100000,pi);</span><br><span class="line">        /**</span><br><span class="line">         * （1）int type： 闹钟的类型，常用的有5个值：AlarmManager.ELAPSED_REALTIME、 AlarmManager.ELAPSED_REALTIME_WAKEUP、AlarmManager.RTC、 AlarmManager.RTC_WAKEUP、AlarmManager.POWER_OFF_WAKEUP。AlarmManager.ELAPSED_REALTIME表示闹钟在手机睡眠状态下不可用，该状态下闹钟使用相对时间（相对于系统启动开始），状态值为3；</span><br><span class="line">         * AlarmManager.ELAPSED_REALTIME_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟也使用相对时间，状态值为2；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.RTC表示闹钟在睡眠状态下不可用，该状态下闹钟使用绝对时间，即当前系统时间，状态值为1；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.RTC_WAKEUP表示闹钟在睡眠状态下会唤醒系统并执行提示功能，该状态下闹钟使用绝对时间，状态值为0；</span><br><span class="line">         *</span><br><span class="line">         * AlarmManager.POWER_OFF_WAKEUP表示闹钟在手机关机状态下也能正常进行提示功能，所以是5个状态中用的最多的状态之一，该状态下闹钟也是用绝对时间，状态值为4；不过本状态好像受SDK版本影响，某些版本并不支持；</span><br><span class="line">         */</span><br><span class="line">        //该方法也用于设置重复闹钟，与第二个方法相似，不过其两个闹钟执行的间隔时间不是固定的而已。</span><br><span class="line">        //基本上相似,只不过这个方法优化了很多,省电</span><br><span class="line">        // am.setInexactRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),1000,pi);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:28</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line"></span><br><span class="line">        String msg = intent.getStringExtra(&quot;msg&quot;);</span><br><span class="line">        System.out.println(&quot;shiming &quot;  +  msg) ;</span><br><span class="line">        Toast.makeText(context,msg,Toast.LENGTH_SHORT).show();</span><br><span class="line"></span><br><span class="line">//        ElectricQuantityOptimizationActivity context1 = (ElectricQuantityOptimizationActivity) context;</span><br><span class="line">//        context1.startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供一个Demo，当app崩溃了，通过AlarmManager来重启App的功能</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:28</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line">public class CrashHandler implements Thread.UncaughtExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    public static CrashHandler mAppCrashHandler;</span><br><span class="line"></span><br><span class="line">    private Thread.UncaughtExceptionHandler mDefaultHandler;</span><br><span class="line"></span><br><span class="line">    private MyApplication mAppContext;</span><br><span class="line"></span><br><span class="line">    public void initCrashHandler(MyApplication application) &#123;</span><br><span class="line">        this.mAppContext = application;</span><br><span class="line">        // 获取系统默认的UncaughtException处理器</span><br><span class="line">        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();</span><br><span class="line">        Thread.setDefaultUncaughtExceptionHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static CrashHandler getInstance() &#123;</span><br><span class="line">        if (mAppCrashHandler == null) &#123;</span><br><span class="line">            mAppCrashHandler = new CrashHandler();</span><br><span class="line">        &#125;</span><br><span class="line">        return mAppCrashHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void uncaughtException(Thread thread, Throwable ex) &#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">        AlarmManager mgr = (AlarmManager) mAppContext.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">        Intent intent = new Intent(mAppContext, MainActivity.class);</span><br><span class="line">        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">        intent.putExtra(&quot;crash&quot;, true);</span><br><span class="line">        System.out.println(&quot;shiming -----》重启应用了哦&quot;);</span><br><span class="line">        PendingIntent restartIntent = PendingIntent.getActivity(mAppContext, 0, intent, PendingIntent.FLAG_ONE_SHOT);</span><br><span class="line">        mgr.set(AlarmManager.RTC, System.currentTimeMillis() + 5000, restartIntent); // 1秒钟后重启应用</span><br><span class="line">        android.os.Process.killProcess(android.os.Process.myPid());</span><br><span class="line">        System.exit(0);</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序会重新启动，如果点击电量优化，App崩溃了，请给与全部权限，还要在开发者模式里面给与位置信息模拟的设置，如果崩溃了， 你也可以发现app会自动的重新启动，这是AlarmManager的应用，注意看MyApplication里面的代码，tks<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * author： Created by shiming on 2018/5/3 14:48</span><br><span class="line"> * mailbox：lamshiming@sina.com</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">public class MyApplication  extends Application &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        /**</span><br><span class="line">         * 程序会重新启动，如果点击电量优化，App崩溃了，请给与全部权限，</span><br><span class="line">         * 还要在开发者模式里面给与位置信息模拟的设置，如果崩溃了，</span><br><span class="line">         * 你也可以发现app会自动的重新启动，这是AlarmManager的应用，注意看MyApplication里面的代码，tks</span><br><span class="line">         */</span><br><span class="line">       CrashHandler.getInstance().initCrashHandler(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>###以上就是个人总结的基本，总结的不太全面，同时也不太详细，如果可以的话，还请给个小星星，表示鼓励，谢谢了☺☺☺</p>
<p>###git地址<a href="https://github.com/Shimingli/PerformanceOptimizationForAndroid" target="_blank" rel="noopener">PerformanceOptimizationForAndroid</a></p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Shiming_Li</a></p>
        <p><span>发布时间:</span>2018-05-06, 16:23:16</p>
        <p><span>最后更新:</span>2018-08-14, 16:24:07</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/" title="安卓代码、图片、布局、网络和电量优化">http://yoursite.com/2018/05/06/安卓代码、图片、布局、网络和电量优化/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/05/06/安卓代码、图片、布局、网络和电量优化/　　作者: Shiming_Li" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/05/14/Android源码分析（事件传递）/">
                    Android源码分析（事件传递）
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/05/05/Lint的使用（安卓性能提升必备掌握的工具）/">
                    Lint的使用（安卓性能提升必备掌握的工具）
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#写在前面的话，前段时间写了一篇文章-二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话，前段时间写了一篇文章 二十三种设计模式，写的不详细，因为如果要写的很详细，估计一年半载都写不完，完全都是按照自己理解，每个设计模式就画了一个简单的图，同时完成了一个小Demo，哪知道这篇文章成了我在简书点赞最高的一篇文章，实在有点受宠若惊，谢谢各位大佬点赞！！！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！"><span class="toc-number">2.</span> <span class="toc-text">这篇文章分为五个部分代码优化、图片优化、布局优化、网络优化、电量优化，尽量每个方法都写了小的Demo！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Demo下载的地址"><span class="toc-number">3.</span> <span class="toc-text">Demo下载的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）"><span class="toc-number">4.</span> <span class="toc-text">代码优化：不要做多余的工作，尽量避免次数过多的内存的分配，（需要对api有一定的熟悉）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#图片优化"><span class="toc-number">5.</span> <span class="toc-text">图片优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#网络优化-移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量"><span class="toc-number">6.</span> <span class="toc-text">网络优化. 移动端对额App几乎都是联网的，网络延迟等会对App的性能产生较大的影响，网络优化可以节约网络流量和电量</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"安卓代码、图片、布局、网络和电量优化　| 仕明的后花园　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/05/14/Android源码分析（事件传递）/" title="上一篇: Android源码分析（事件传递）">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/05/05/Lint的使用（安卓性能提升必备掌握的工具）/" title="下一篇: Lint的使用（安卓性能提升必备掌握的工具）">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/常用集合的原理分析/">常用集合的原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Hexo-GitHub-阿里域名搭建自己博客/">Hexo+GitHub+阿里域名搭建自己博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-9-Pie-正式版总结/">Android 9 Pie 正式版总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/安卓invalidate、postInvalidate、requestLayout源码分析/">安卓invalidate、postInvalidate、requestLayout源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/Go语言实现RPC/">Go语言实现RPC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/15/Go语言实现的WebSocket/">Go语言实现的WebSocket</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/Go语言使用MySQL数据库/">Go语言使用MySQL数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/Web的工作方式/">Web的工作方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/Android源码分析-View的绘制流程/">Android源码分析:View的绘制流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析LayoutInflater/">Android源码分析LayoutInflater</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析ViewStub源码解析/">Android源码分析ViewStub源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Android源码分析（Activity-setContentView源码析/">Android源码分析（Activity.setContentView源码解析）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/Android源码分析（Handler机制）/">Android源码分析（Handler机制）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/14/Android源码分析（事件传递）/">Android源码分析（事件传递）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Lint的使用（安卓性能提升必备掌握的工具）/">Lint的使用（安卓性能提升必备掌握的工具）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/27/Java/">注解（Annotation） by Thinking in Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/22/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/PLC通讯的安卓App/">PLC通讯的安卓App</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/安卓画笔笔锋的实现探索（三）田字格Demo/">安卓画笔笔锋的实现探索（三）田字格Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/2018/">2018年</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/自己实现Jni，生成so库，实现高效率的高斯模糊效果/">自己实现Jni，生成so库，实现高效率的高斯模糊效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/26/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/Fragment-setNextAnim/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/自定义PopupWindow的超强使用/">自定义PopupWindow的超强使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/17/如何用AndroidStudio查看和解决OOM/">如何用AndroidStudio查看和解决OOM</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Shiming_Li
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>