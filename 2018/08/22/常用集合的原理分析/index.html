<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Shiming_Li" />



<meta name="description" content="分析常用集合的底层的原理：ArrayList、Vector、LinckedList、HashMap、HashSet、LinkedHashMap、LruCache、SparseArray、ConcurrentHashMap一、ArrayList 最佳的做法是将ArrayList作为默认的首选，当你需要而外的功能的时候，或者是当程序性能由于经常需要从表中间插入和删除而变差的时候，才会去选择Linke">
<meta name="keywords" content="ArrayList,Vector,LinckedList,HashMap,HashSet,LinkedHashMap,LruCache,SparseArray,ConcurrentHashMap">
<meta property="og:type" content="article">
<meta property="og:title" content="常用集合的原理分析">
<meta property="og:url" content="http://yoursite.com/2018/08/22/常用集合的原理分析/index.html">
<meta property="og:site_name" content="仕明的后花园">
<meta property="og:description" content="分析常用集合的底层的原理：ArrayList、Vector、LinckedList、HashMap、HashSet、LinkedHashMap、LruCache、SparseArray、ConcurrentHashMap一、ArrayList 最佳的做法是将ArrayList作为默认的首选，当你需要而外的功能的时候，或者是当程序性能由于经常需要从表中间插入和删除而变差的时候，才会去选择Linke">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-638fb161836b6be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-22T08:40:52.206Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="常用集合的原理分析">
<meta name="twitter:description" content="分析常用集合的底层的原理：ArrayList、Vector、LinckedList、HashMap、HashSet、LinkedHashMap、LruCache、SparseArray、ConcurrentHashMap一、ArrayList 最佳的做法是将ArrayList作为默认的首选，当你需要而外的功能的时候，或者是当程序性能由于经常需要从表中间插入和删除而变差的时候，才会去选择Linke">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5363507-638fb161836b6be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="仕明的后花园" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>常用集合的原理分析 | 仕明的后花园</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1add6c64d9c467153aaed18d249d81c4";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Shiming_Li</a></h1>
        </hgroup>

        
        <p class="header-subtitle">趁还能折腾的时候多学习！</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-9-正式版/">Android 9 正式版</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-P/">Android P</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android事件传递/">Android事件传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android源码/">Android源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ArrayList/">ArrayList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment-setNextAnim-int-on-a-null-object-reference/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler机制/">Handler机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HashSet/">HashSet</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jni/">Jni</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LayoutInflater/">LayoutInflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinckedList/">LinckedList</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LinkedHashMap/">LinkedHashMap</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lint的使用/">Lint的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LruCache/">LruCache</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOM/">OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLC/">PLC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PopupWindow/">PopupWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/So库/">So库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SparseArray/">SparseArray</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vector/">Vector</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewStub/">ViewStub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/invalidate/">invalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postInvalidate/">postInvalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requestLayout/">requestLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setContentView源码解析/">setContentView源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/剑指几道算法题的思考/">剑指几道算法题的思考</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作方式/">工作方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂文/">杂文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解（Annotation）/">注解（Annotation）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解析/">源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/田字格Demo/">田字格Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/绘制/">绘制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/谷歌/">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里域名/">阿里域名</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于移动开发，Go后台开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Shiming_Li</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Shiming_Li</a></h1>
            </hgroup>
            
            <p class="header-subtitle">趁还能折腾的时候多学习！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" target="_blank" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" target="_blank" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-常用集合的原理分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/08/22/常用集合的原理分析/" class="article-date">
      <time datetime="2018-08-22T08:38:13.000Z" itemprop="datePublished">2018-08-22</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      常用集合的原理分析
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ArrayList/">ArrayList</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ConcurrentHashMap/">ConcurrentHashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashMap/">HashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HashSet/">HashSet</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinckedList/">LinckedList</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LinkedHashMap/">LinkedHashMap</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LruCache/">LruCache</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SparseArray/">SparseArray</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vector/">Vector</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>分析常用集合的底层的原理：<code>ArrayList、Vector、LinckedList、HashMap、HashSet、LinkedHashMap、LruCache、SparseArray、ConcurrentHashMap</code><h4 id="一、ArrayList"><a href="#一、ArrayList" class="headerlink" title="一、ArrayList"></a>一、ArrayList</h4></li>
<li>最佳的做法是将<code>ArrayList</code>作为默认的首选，当你需要而外的功能的时候，或者是当程序性能由于经常需要从表中间插入和删除而变差的时候，才会去选择<code>LinkedList</code>  来源于<code>THinking in Java</code></li>
<li><p>源码分析</p>
<ul>
<li><p>最重要的两个属性分别是: <code>elementData</code> 数组 <code>size</code>的大小</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transient Object[] elementData;</span><br><span class="line">  /**</span><br><span class="line">   * The size of the ArrayList (the number of elements it contains).</span><br><span class="line">   *</span><br><span class="line">   * @serial</span><br><span class="line">   */</span><br><span class="line">  //以及 size 大小</span><br><span class="line">  private int size;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>transient</code>: <code>java</code>:语言的关键字，变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。</p>
</li>
<li><p>构造函数: <code>new ArrayList()</code> 的时候，会指定一个<code>Object[]</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">      super();</span><br><span class="line">      if (initialCapacity &lt; 0)</span><br><span class="line">          throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                  initialCapacity);</span><br><span class="line">      this.elementData = new Object[initialCapacity];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new Collection()</code> 添加一个集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">      elementData = c.toArray();</span><br><span class="line">      size = elementData.length;</span><br><span class="line">      // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">      if (elementData.getClass() != Object[].class)</span><br><span class="line">          elementData = Arrays.copyOf(elementData, size, </span><br><span class="line">Object[].class);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>添加元素<code>add()</code> 将指定的元素追加到列表的末尾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   public boolean add(E e) &#123;</span><br><span class="line">    // 比如说加了一个元素</span><br><span class="line">    ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">    elementData[size++] = e;//这里的推算是 elementData[0]=e</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ensureCapacityInternal()</code>方法详情，如果是<code>add</code> 一个元素，那么就会走到<code>ensureExplicitCapacity()</code>的方法中！同时第一次扩容的最小的值为<code>DEFAULT_CAPACITY=10</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void ensureCapacityInternal(int minCapacity) &#123;</span><br><span class="line">     // 如果 是直接new ArrayList的话，那么扩容的最小的值为10</span><br><span class="line">     if (elementData == EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">         minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">     &#125;</span><br><span class="line">     //开始扩展</span><br><span class="line">     ensureExplicitCapacity(minCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ensureExplicitCapacity(minCapacity)</code>,其中 <code>minCapacity</code>是最小的长度，如果是使用的 <code>new ArrayList&lt;E&gt;()</code> 然后 <code>add(E)</code>,那么这个 <code>minCapacity=10</code>.具体请看代码的逻辑</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private void ensureExplicitCapacity(int minCapacity) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line"></span><br><span class="line">      // overflow-conscious code</span><br><span class="line">      if (minCapacity - elementData.length &gt; 0)</span><br><span class="line">          grow(minCapacity);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>grow(minCapactity)</code>  增加容量以确保它至少能容纳由最小容量参数指定的元素数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    //(oldCapacity &gt;&gt; 1)等于 oldCapacity%2 意思就是除以2，取整数</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    //最小容量通常接近大小，所以这是一个胜利：</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分析上面的问题，假如第一次添加数据，那么<code>oldCapacity =0</code>;<code>0&gt;&gt;2</code>=<code>0</code>; <code>newCapacity - minCapacity &lt; 0</code>就是 ：<code>0-10</code>肯定小于<code>0</code>的,所以 <code>newCapacity = minCapacity;</code>，根据前面的分析，<code>minCapacity=10</code>!</p>
</li>
<li><p><code>minCapacity is usually close to size, so this is a win:</code> 翻译为：最小容量通常接近大小，所以这是一个胜利： 最后调用等到一个容器长度为<code>10</code>的<code>elementData</code>:</p>
<ul>
<li>最后一步在  <code>elementData[size++] = e;</code>就是把  <code>elementData[0] = e;</code>赋值完成了，size才会++ ，等于<code>size=1</code></li>
<li>关于 <code>&gt;&gt;</code>代表右移; <code>2</code>的二进制是<code>10</code>，&gt;&gt;代表右移，<code>10</code>右移<code>1</code>位是二进制的<code>1</code>，<code>&lt;&lt;</code>代表左移，<code>10</code>左移<code>1</code>位是二进制的<code>100</code>，也就是十进制的<code>4</code>。</li>
</ul>
</li>
<li><p>往指定角标中添加元素 ,过程和添加一个元素一样，只不过这个方法更加的高效<code>System.arraycopy()</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void add(int index, E element) &#123;</span><br><span class="line">      if (index &gt; size || index &lt; 0)</span><br><span class="line">          throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">     // 首先扩容校验。</span><br><span class="line">      ensureCapacityInternal(size + 1);  // Increments modCount!!</span><br><span class="line">      // TODO: 2018/8/16  使用了 native的方法</span><br><span class="line">      // 复制，向后移动 接着对数据进行复制，目的是把 index 位置空出来放本次插入的数据，并将后面的数据向后移动一个位置。</span><br><span class="line">      System.arraycopy(elementData, index, elementData, index + 1,</span><br><span class="line">              size - index);</span><br><span class="line">      elementData[index] = element;</span><br><span class="line">      size++;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>在<code>ArrayList</code>中自定义了 <code>writeObject</code> 和 <code>readObject</code> ,目的是为了：<code>JVM</code> 会调用这两个自定义方法来实现序列化与反序列化 <code>ArrayList</code> 只序列化(序列化 (Serialization)将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象)了被使用的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> private void writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">            throws java.io.IOException&#123;</span><br><span class="line">...</span><br><span class="line">    &#125;</span><br><span class="line">    private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ArrayList</code>的线程不安全,通过下面的方式证明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">final ArrayList&lt;String&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">      Thread t1= new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line">              for (int i=0;i&lt;25;i++)&#123;</span><br><span class="line">                  lists.add(&quot;我是i=&quot;+i);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      Thread t2= new Thread()&#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              super.run();</span><br><span class="line">              for (int i=25;i&lt;50;i++)&#123;</span><br><span class="line">                  lists.add(&quot;我是i=&quot;+i);</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      //主线程休眠1秒钟，以便t1和t2两个线程将lists填装完毕。</span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">      try &#123;</span><br><span class="line">          Thread.sleep(1000);</span><br><span class="line">          // 即使睡完觉了，但是也有可能长度不对</span><br><span class="line">          for(int l=0;l&lt;lists.size();l++)&#123;</span><br><span class="line">              // todo   两个线程不断的插入的话，就会导致插入的是null     我是i=34   我是i=10   我是i=35   我是i=11   null   null   我是i=12   我是i=38   我是i=13   我是i=39</span><br><span class="line">              System.out.print(lists.get(l)+&quot;   &quot;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; catch (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个线程不断的插入的话，就会导致插入的是<code>null</code> <code>我是i=34   我是i=10   我是i=35   我是i=11   null   null   我是i=12   我是i=38   我是i=13   我是i=39</code></p>
<ul>
<li><p>如果要使用安全的线程的话，可以通过<code>List&lt;String&gt; data=Collections.synchronizedList(new ArrayList&lt;String&gt;());</code>得到线程安全的集合，<br>*<code>Collections.synchronizedList</code> 的原理,如下代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">    return (list instanceof RandomAccess ?</span><br><span class="line">            new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            new SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以在<code>SynchronizedList</code>类中方法加入了关键字 <code>synchronized</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">         synchronized (mutex) &#123;return list.get(index);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public E set(int index, E element) &#123;</span><br><span class="line">         synchronized (mutex) &#123;return list.set(index, element);&#125;</span><br><span class="line">     &#125;</span><br><span class="line">     public void add(int index, E element) &#123;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>关于原型模式，<code>ArrayList</code> 实现了接口<code>Cloneable</code>;这个接口只有一个作用，就是在运行时候通知虚拟机可以安全的实现,在java的虚拟机中，只有实现了这个接口的类才可以被拷贝，否者会抛出<code>CloneNotSupportedException</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public Object clone() &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) super.clone();</span><br><span class="line">          v.elementData = Arrays.copyOf(elementData, size);transient</span><br><span class="line">          v.modCount = 0;</span><br><span class="line">          return v;</span><br><span class="line">      &#125; catch (CloneNotSupportedException e) &#123;</span><br><span class="line">          // this shouldn&apos;t happen, since we are Cloneable</span><br><span class="line">          throw new InternalError(e);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以看到这里有个深拷贝和 浅拷贝,幸运的是<code>java</code>中大部分都容器都实现了<code>Cloneable</code>这个接口，所以在程度上去实现深入拷贝不太难。</p>
<ul>
<li>深拷贝：就是需要拷贝的类中，所有的东西，比如说：原型类中的数组，容器，饮用对象等</li>
<li>浅拷贝：就是只拷贝基本东西，容器这些不拷贝<ul>
<li>更多的设计模式 <a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a></li>
</ul>
</li>
</ul>
</li>
<li><p><code>ArrayList</code>遍历的速度快，插入删除速度慢，随机访问的速度快</p>
</li>
</ul>
<h4 id="二、Vector"><a href="#二、Vector" class="headerlink" title="二、Vector"></a>二、Vector</h4><ul>
<li><p>关注<code>add  get</code> 方法:可以得出：使用 <code>synchronized</code>进行同步写数据，但是开销较大，所以 <code>Vector</code> 是一个同步容器并不是一个并发容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public synchronized boolean add(E e) &#123;</span><br><span class="line">      modCount++;</span><br><span class="line">      ensureCapacityHelper(elementCount + 1);</span><br><span class="line">      elementData[elementCount++] = e;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line">  public synchronized E get(int index) &#123;</span><br><span class="line">      if (index &gt;= elementCount)</span><br><span class="line">          throw new ArrayIndexOutOfBoundsException(index);</span><br><span class="line"></span><br><span class="line">      return elementData(index);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>应该避免使用<code>Vector</code> ，它只存在支持遗留代码的类中（它能正常的工作的唯一原因是：因为为了向前兼容，它被适配成为了<code>List</code>）</p>
</li>
<li>其他的不想多说，浪费电！</li>
</ul>
<h4 id="三、LinckedList"><a href="#三、LinckedList" class="headerlink" title="三、LinckedList"></a>三、LinckedList</h4><ul>
<li><p>变量: 集合元素数量;链表头节点;链表尾节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//集合元素数量</span><br><span class="line">   transient int size = 0;</span><br><span class="line">   //链表头节点</span><br><span class="line">   transient Node&lt;E&gt; first;</span><br><span class="line">   //链表尾节点</span><br><span class="line">   transient Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Node</code>类，数据结构的关键类，每一个元素值，都存在两个结点，前一个，后一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">     E item;//元素值</span><br><span class="line">     Node&lt;E&gt; next;//后置节点</span><br><span class="line">     Node&lt;E&gt; prev;//前置节点</span><br><span class="line">     Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">         this.item = element;</span><br><span class="line">         this.next = next;</span><br><span class="line">         this.prev = prev;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public LinkedList() &#123;</span><br><span class="line"> &#125;</span><br><span class="line">public LinkedList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">     this();</span><br><span class="line">     addAll(c);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关注 <code>add(E)</code>方法,可以看到这个返回值永远为<code>true</code>; 每次插入都是移动指针，和 <code>ArrayList</code> 的拷贝数组来说效率要高上不少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">      linkLast(e);</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>linkLast(E)</code> 方法:生成新节点 并插入到 链表尾部， 更新<code>last/first</code>节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null) //若原链表为空链表，需要额外更新头结点</span><br><span class="line">        first = newNode;</span><br><span class="line">    else//否则更新原尾节点的后置节点为现在的尾节点（新节点）</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果说，最后的一个结点为<code>null</code>;那么我们新加入的元素，就是最后一个结点，如果最后一个结点不为<code>null</code>,那么我们插入的新的值就是最后结点的<code>l.next = newNode</code>.</li>
</ul>
</li>
<li><p><code>get()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public E get(int index) &#123;</span><br><span class="line">    // 常看数组角标是否越界</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    return node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>node(index)</code>的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;E&gt; node(int index) &#123;</span><br><span class="line">    //二分查找来看 index 离 size 中间距离来判断是从头结点正序查还是从尾节点倒序查</span><br><span class="line">    // assert isElementIndex(index);</span><br><span class="line">     //通过下标获取某个node 的时候，（增、查 ），会根据index处于前半段还是后半段 进行一个折半，以提升查询效率</span><br><span class="line">    if (index &lt; (size &gt;&gt; 1)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        //不断的往前面找 ，如果查找的角标比linkedList的size的取余还小的话，就通过不断的循环去得到相对应的值</span><br><span class="line">        for (int i = 0; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        for (int i = size - 1; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看出这是一个二分查找，如果 <code>index &lt; (size &gt;&gt; 1)</code> , <code>&gt;&gt;</code>代表右移,其实就是 <code>%2</code>,这里查找下去，知道找到为止</li>
<li>如果假如，我们查找的<code>index</code>约接近<code>size</code>的一半，那么我们需要的次数就会越低，总结一句话：效率是非常低的，特别是当 <code>index</code> 越接近 <code>size</code> 的中间值。</li>
</ul>
</li>
<li>来源于 <code>gitHub</code><br><img src="https://upload-images.jianshu.io/upload_images/5363507-638fb161836b6be1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Linckedlist底层的原理.jpg"></li>
</ul>
<h4 id="四、HashMap"><a href="#四、HashMap" class="headerlink" title="四、HashMap"></a>四、HashMap</h4><ul>
<li>在 1.6 1.7 <code>hashmap</code>的类的代码一共<code>1500</code>行左右，在<code>1.8</code>一共有<code>2000</code>行左右! 这里直接看的是 <code>JDK1.8</code> 的代码。</li>
<li><p>关于变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16</span><br><span class="line">   //左移运算符，num &lt;&lt; 1,相当于num乘以2  最大的长度</span><br><span class="line">   static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 相当于把1 位移30为等于 1 + 30个0的长度</span><br><span class="line">   // 填充比 因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</span><br><span class="line">   // hashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。</span><br><span class="line">   static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br><span class="line">   //当add一个元素到某个位桶，其链表长度达到8时将链表转换为红黑树</span><br><span class="line">   static final int TREEIFY_THRESHOLD = 8;</span><br><span class="line">   static final int UNTREEIFY_THRESHOLD = 6;</span><br><span class="line">   static final int MIN_TREEIFY_CAPACITY = 64;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>Node</code>内部类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;</span><br><span class="line">      final int hash;</span><br><span class="line">      final K key;</span><br><span class="line">      V value;</span><br><span class="line">      Node&lt;K,V&gt; next;</span><br><span class="line">      //todo  构造函数 hash值 key 和value  和 下一个结点</span><br><span class="line">      Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          this.hash = hash;</span><br><span class="line">          this.key = key;</span><br><span class="line">          this.value = value;</span><br><span class="line">          this.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final K getKey()        &#123; return key; &#125;</span><br><span class="line">      public final V getValue()      &#123; return value; &#125;</span><br><span class="line">      public final String toString() &#123; return key + &quot;=&quot; + value; &#125;</span><br><span class="line">      // 是去key的hash值和 value的hash值 然后做位异运算 转为二进制 相同为0，不同为1</span><br><span class="line">      public final int hashCode() &#123;</span><br><span class="line">          //  todo 位异或运算（^）</span><br><span class="line">          // 运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1</span><br><span class="line">          return Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public final V setValue(V newValue) &#123;</span><br><span class="line">          V oldValue = value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          return oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">      // todo  判断两个 node 结点是否相等，一个比较自身相等，一个是比较key和value</span><br><span class="line">      public final boolean equals(Object o) &#123;</span><br><span class="line">          if (o == this)</span><br><span class="line">              return true;</span><br><span class="line">          if (o instanceof Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              if (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                      Objects.equals(value, e.getValue()))</span><br><span class="line">                  return true;</span><br><span class="line">          &#125;</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>Node</code>类的中存储了 <code>hash</code> <code>key</code> <code>value</code> 和下一个结点 <code>Node</code>,后面解释</li>
<li><code>Node</code> 类的 <code>hashCode</code>是<code>Objects.hashCode(key) ^ Objects.hashCode(value)</code>;位异或运算（^）: 运算规则是两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1</li>
<li>判断两个<code>node</code>是否相等：一个比较自身相等，一个是比较<code>key</code>和<code>value</code></li>
</ul>
<ul>
<li><p><code>HashMap</code>的构造方法,指定容量和扩展因子！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">     if (initialCapacity &lt; 0)</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</span><br><span class="line">                 initialCapacity);</span><br><span class="line">     //如果最大的长度大于最大的话，就默认最大的</span><br><span class="line">     if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">         initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">     //填充比为正</span><br><span class="line">     if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</span><br><span class="line">                 loadFactor);</span><br><span class="line">     this.loadFactor = loadFactor;</span><br><span class="line">     // 加入指定的容量为 10 那么新的扩容的临界值为 13</span><br><span class="line">     this.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>tableSizeFor(initialCapacity)</code> 方法，说白了就是算法，给你一个接近的值，设置<code>hashmap</code>的长度为10，那么他的新的扩容的临界值=16</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int cap=10;</span><br><span class="line"> int n = cap - 1;//9</span><br><span class="line"> n |= n &gt;&gt;&gt; 1;//9的二进制=1001  &gt;&gt;&gt;表示无符号的右移 100 =十进制 4     n=  1001 |= 100</span><br><span class="line"> System.out.println(&quot;n=&quot;+n); // n=13; 其实就是等于      n=  1001 |= 100 也就是n=1101 换成十进制等于13</span><br><span class="line"> n |= n &gt;&gt;&gt; 2;</span><br><span class="line"> n |= n &gt;&gt;&gt; 4;</span><br><span class="line"> n |= n &gt;&gt;&gt; 8;</span><br><span class="line"> n |= n &gt;&gt;&gt; 16;</span><br><span class="line"> int i= (n &lt; 0) ? 1 : (n &gt;= 1000000) ? 1000000 : n + 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>无符号的右移（<code>&gt;&gt;&gt;</code>）:按照二进制把数字右移指定数位，高位直接补零，低位移除！<ul>
<li><code>a=a|b</code> 等于 <code>a|=b</code>的意思就是把a和b按位或然后赋值给a 按位或的意思就是先把a和b都换成2进制，然后用或操作</li>
</ul>
</li>
<li>比如：<code>9</code>的二进制<code>1001</code>  <code>&gt;&gt;&gt;</code>表示无符号的右移 得到<code>100</code> 等于十进制 <code>4</code>     <code>n</code>=<code>1001 |= 100</code>  ，最后 <code>n=1101</code> 转化为十进制等于<code>n=13</code>。</li>
<li>上面函数的运算过程 <ul>
<li>n |= n &gt;&gt;&gt; 1;//9的二进制=1001  &gt;&gt;&gt;表示无符号的右移 100 =十进制 4     n=  1001 |= 100<ul>
<li>n |= n &gt;&gt;&gt; 2; // 1101 移动两位 0011 |1101  等于1111</li>
<li>n |= n &gt;&gt;&gt; 4;// 1111 移动4为 0000 |1111 =1111</li>
<li>n |= n &gt;&gt;&gt; 8;// 1111 移动8为 0000 |1111 =1111</li>
<li>n |= n &gt;&gt;&gt; 16;// 1111 移动16为 0000 |1111 =1111</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>HashMap</code>的构造方法,设置容器的长度 但是指定的默认的扩展因子为 <code>0.75</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity) &#123;</span><br><span class="line">      this(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HashMap</code>的构造方法,什么都不指定 都给默认的,我们自己最常用的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//什么都不指定 都给默认的</span><br><span class="line">   public HashMap() &#123;</span><br><span class="line">       this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*<code>HashMap</code>的构造方法, 也可以new一个 map进去，这种的方式 我们使用的比较少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;</span><br><span class="line">     //默认指定了扩展的因子</span><br><span class="line">     this.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">     putMapEntries(m, false);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>putMapEntries()</code>方法,如果是构造函数到这里来的话，就会进入到<code>threshold = tableSizeFor(t);</code>这里来，然后遍历<code>m</code>,然后一个个元素去添加，如果装载进来的<code>map</code>集合过于巨大，建议使用源<code>map</code>的原型模式<code>clone</code>方法克隆一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123;</span><br><span class="line">       int s = m.size();</span><br><span class="line">       if (s &gt; 0) &#123;</span><br><span class="line">           // 如果是hashmap中填充了一个map 就会走到这里来 table == null  =true</span><br><span class="line">           if (table == null) &#123; // pre-size</span><br><span class="line">               float ft = ((float)s / loadFactor) + 1.0F;</span><br><span class="line">               int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?</span><br><span class="line">                       (int)ft : MAXIMUM_CAPACITY);</span><br><span class="line">               // t=ft</span><br><span class="line">               if (t &gt; threshold)</span><br><span class="line">                   //也就会走到这里来</span><br><span class="line">                   threshold = tableSizeFor(t);</span><br><span class="line">           &#125; else if (s &gt; threshold) &#123;</span><br><span class="line">               // 扩容机制</span><br><span class="line">               resize();</span><br><span class="line">           &#125;</span><br><span class="line">           // copy的过程  遍历hashmap的话，这个应该是最高效的方式</span><br><span class="line">           for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">               K key = e.getKey();</span><br><span class="line">               V value = e.getValue();</span><br><span class="line">               putVal(hash(key), key, value, false, evict);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键方法<code>put</code>，了解如何储存的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public V put(K key, V value) &#123;</span><br><span class="line">      return putVal(hash(key), key, value, false, true);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>putVal</code>方法的详情，假装<code>put</code>数据去分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// 在构造函数中，也调用了这个方法，唯一不同的地方就是 evict=fasle</span><br><span class="line"> final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</span><br><span class="line">                boolean evict) &#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</span><br><span class="line">     if ((tab = table) == null || (n = tab.length) == 0)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     /*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/</span><br><span class="line">     if ((p = tab[i = (n - 1) &amp; hash]) == null)</span><br><span class="line">         // todo  LinkedHashMap 重新重写了这个方法，然后使用了 LinkedHashMap.Entry 里面多了两个结点    Entry&lt;K,V&gt; before, after;</span><br><span class="line">         tab[i] = newNode(hash, key, value, null);</span><br><span class="line">     ///*表示有冲突,开始处理冲突*/</span><br><span class="line">     else &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         /*检查第一个Node，p是不是要找的值*/</span><br><span class="line">         if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         else if (p instanceof TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</span><br><span class="line">         else &#123;</span><br><span class="line">             for (int binCount = 0; ; ++binCount) &#123;</span><br><span class="line">                 /*指针为空就挂在后面*/</span><br><span class="line">                 if ((e = p.next) == null) &#123;</span><br><span class="line">                     p.next = newNode(hash, key, value, null);</span><br><span class="line">                     //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　</span><br><span class="line">                     //treeifyBin首先判断当前hashMap的长度，如果不足64，只进行</span><br><span class="line">                     //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树</span><br><span class="line">                     if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     break;</span><br><span class="line">                 &#125;</span><br><span class="line"></span><br><span class="line">                 /*如果有相同的key值就结束遍历*/</span><br><span class="line">                 if (e.hash == hash &amp;&amp;</span><br><span class="line">                         ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</span><br><span class="line">                     break;</span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">  /*就是链表上有相同的key值*/</span><br><span class="line">         if (e != null) &#123; // existing mapping for key</span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             if (!onlyIfAbsent || oldValue == null)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             // todo  LinkedHashMap  对其重写</span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             return oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     ++modCount;</span><br><span class="line">     /*如果当前大小大于门限，门限原本是初始容量*0.75*/</span><br><span class="line">     if (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     // todo  LinkedHashMap 对其重写</span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     return null;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1、可以发现 <code>table</code>肯定为<code>null</code>,没有初始化，所以第一个判断条件肯定成立<code>tab = table) == null || (n = tab.length) == 0</code>,这里有个小小的问题，当<code>tab = table) == null</code>成立的时候，后面<code>||</code>的代码是不会执行的，所以不会抛出空指针的异常。也就会执行<code>n = (tab = resize()).length;</code>的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transient Node&lt;K,V&gt;[] table;// 第一次table没有去初始化，肯定为null</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、关于  <code>resize()</code>的方法，其实这个也是很关键的方法，扩容</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">   // 扩容机制 HasMap的扩容机制resize();</span><br><span class="line">final Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  int oldCap = (oldTab == null) ? 0 : oldTab.length;</span><br><span class="line">   int oldThr = threshold;</span><br><span class="line">   int newCap, newThr = 0;</span><br><span class="line">  	/*如果旧表的长度不是空*/</span><br><span class="line">        if (oldCap &gt; 0) &#123;</span><br><span class="line">         if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">           threshold = Integer.MAX_VALUE;</span><br><span class="line">          return oldTab;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      /*把新表的长度设置为旧表长度的两倍，newCap=2*oldCap*/</span><br><span class="line">      else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">              oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line"></span><br><span class="line">          /*把新表的门限设置为旧表门限的两倍，newThr=oldThr*2*/</span><br><span class="line">          newThr = oldThr &lt;&lt; 1; // double threshold</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  else if (oldThr &gt; 0) // initial capacity was placed in threshold</span><br><span class="line">      newCap = oldThr;</span><br><span class="line">      /*如果旧表的长度的是0，就是说第一次初始化表*/</span><br><span class="line">  else &#123;               // zero initial threshold signifies using defaults</span><br><span class="line">      // todo 在new hashMap中的长度 ，然后调用了 put的方法的时候，就会发生一次扩容 ，长度为16</span><br><span class="line">      newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">      newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  if (newThr == 0) &#123;</span><br><span class="line">      float ft = (float)newCap * loadFactor;//新表长度乘以加载因子</span><br><span class="line">      newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</span><br><span class="line">              (int)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span><br><span class="line">  /*下面开始构造新表，初始化表中的数据*/</span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  if (oldTab != null) &#123;</span><br><span class="line">      for (int j = 0; j &lt; oldCap; ++j) &#123;</span><br><span class="line">          Node&lt;K,V&gt; e;</span><br><span class="line">          if ((e = oldTab[j]) != null) &#123;</span><br><span class="line">              oldTab[j] = null;</span><br><span class="line">              if (e.next == null)//说明这个node没有链表直接放在新表的e.hash &amp; (newCap - 1)位置</span><br><span class="line">                  newTab[e.hash &amp; (newCap - 1)] = e;</span><br><span class="line">              else if (e instanceof TreeNode)</span><br><span class="line">                  ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</span><br><span class="line">              else &#123; // preserve order</span><br><span class="line">                  Node&lt;K,V&gt; loHead = null, loTail = null;</span><br><span class="line">                  Node&lt;K,V&gt; hiHead = null, hiTail = null;</span><br><span class="line">                  Node&lt;K,V&gt; next;</span><br><span class="line">                  do &#123;</span><br><span class="line">                      next = e.next;</span><br><span class="line">                      //记录下一个结点</span><br><span class="line">                      //新表是旧表的两倍容量，实例上就把单链表拆分为两队，</span><br><span class="line">                     //e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对</span><br><span class="line">                      if ((e.hash &amp; oldCap) == 0) &#123;</span><br><span class="line">                          if (loTail == null)</span><br><span class="line">                              loHead = e;</span><br><span class="line">                          else</span><br><span class="line">                              loTail.next = e;</span><br><span class="line">                          loTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                      else &#123;</span><br><span class="line">                          if (hiTail == null)</span><br><span class="line">                              hiHead = e;</span><br><span class="line">                          else</span><br><span class="line">                              hiTail.next = e;</span><br><span class="line">                          hiTail = e;</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125; while ((e = next) != null);</span><br><span class="line">                  if (loTail != null) &#123;</span><br><span class="line">                      loTail.next = null;</span><br><span class="line">                      newTab[j] = loHead;</span><br><span class="line">                  &#125;</span><br><span class="line">                  if (hiTail != null) &#123;</span><br><span class="line">                      hiTail.next = null;</span><br><span class="line">                      newTab[j + oldCap] = hiHead;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return newTab;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>扩容方法也比较复杂，带着问题来分析，第一次，<code>put</code>数据的时候，可以得出<code>oldCap=0</code>、<code>oldThr=0</code>;那么新的长度 <code>newCap = DEFAULT_INITIAL_CAPACITY=16;</code> <code>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY)=0.75*16=12</code>,把新的长度赋值给<code>threshold = newThr;</code></li>
<li>然后<code>Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];</code>,根据上面我们可以的得出 <code>newCap=16</code>;<ul>
<li>由于 <code>oldTab==null</code>，所以，这几返回一个 <code>newTab</code> 这是一个长度为<code>16</code>的<code>Node</code>的数组</li>
</ul>
</li>
<li>3、回到<code>putVal</code>的方法中，那么 <code>n = (tab = resize()).length;</code>也就是<code>n=16</code></li>
<li>4、那么<code>(p = tab[i = (n - 1) &amp; hash]) == null</code>是否成立呢，其实我们可以猜测下，第一次肯定是成立的，这里有个运算符，位与运算符<code>&amp;</code>,把做运算的两个数都转化为二进制的，然后从高位开始比较，如果两个数都是<code>1</code>则为<code>1</code>，否者为<code>0</code>.如下面的 <code>HashMap</code>中的算法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   int newHash=hash(&quot;test&quot;);</span><br><span class="line">   // 1的hash值=1    test :hash值=3556516</span><br><span class="line">   System.out.println( &quot;newHash 1的hash值=&quot;+newHash);</span><br><span class="line">   i = (16 - 1) &amp; newHash;</span><br><span class="line">   // i值=1  test值=4</span><br><span class="line">   System.out.println(&quot;newHash的 i值=&quot;+i);</span><br><span class="line">  int hash(Object key) &#123;</span><br><span class="line">   int h;</span><br><span class="line">   return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>5、这样就是走到这里来<code>tab[i] = newNode(hash, key, value, null);</code>，也就是<code>tab[0]=newNode</code>。这里有个面试，面试经常问，这里注意到 <code>tab</code> 是 <code>resize()</code>方法返回的，在<code>resize()</code>方法中，又把<code>table = newTab;</code>,那么我们改动 <code>tab</code>能否去改变 <code>table</code>呢？其实是能够的，这里传递是地址值，如下面的<code>Demo</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">       String[] newS=setTest();</span><br><span class="line">        newS[0]=&quot;16&quot;;</span><br><span class="line">        // newS =[Ljava.lang.String;@1e0b9a</span><br><span class="line">        System.out.println(&quot;newS =&quot;+newS);</span><br><span class="line">        //newS =[Ljava.lang.String;@1e0b9a</span><br><span class="line">        System.out.println(&quot;test =&quot;+test);</span><br><span class="line">        System.out.println(&quot;test=&quot;+test.length);</span><br><span class="line">        System.out.println(&quot;test=&quot;+test[0]);</span><br><span class="line">     &#125;</span><br><span class="line">    String[] test;</span><br><span class="line">    public String[]  setTest()&#123;</span><br><span class="line">        String[] newS=new String[10];</span><br><span class="line">        test=newS;</span><br><span class="line">        return newS;</span><br><span class="line">    &#125;</span><br><span class="line">     ```  </span><br><span class="line">  * 以上就是 `HashMap`第一次`put`数据的完整过程。</span><br><span class="line">    </span><br><span class="line">* 当多次的`put`数据的时候，如果 某个位置上的 `hash`值相同的话，准确的讲`i = (n - 1) &amp; hash` 是这个值，取出来的 `tab`不为`null`，那么储存的结构转化为链表</span><br></pre></td></tr></table></figure>
<p>for (int binCount = 0; ; ++binCount) {</p>
<pre><code>/*指针为空就挂在后面*/
if ((e = p.next) == null) {
    p.next = newNode(hash, key, value, null);
    //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　
    //treeifyBin首先判断当前hashMap的长度，如果不足64，只进行
    //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树
    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
        treeifyBin(tab, hash);
    break;
}

/*如果有相同的key值就结束遍历*/
if (e.hash == hash &amp;&amp;
        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
    break;
</code></pre></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 当一个位置上的大于 ` TREEIFY_THRESHOLD - 1` 也就是 `7`的话，看是否需要改变冲突节点的存储结构.`treeifyBin`首先判断当前`hashMap`的长度，如果不足`64`，只进行`resize`，扩容`table`，如果达到64，那么将冲突的存储结构为红黑树.如下图的结构</span><br><span class="line">![HashMap](https://upload-images.jianshu.io/upload_images/5363507-d8230dc20a3b52b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br></pre></td></tr></table></figure>
<p>  final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {<br>        int n, index; Node&lt;K,V&gt; e;<br>        if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>            resize();<br>        else if ((e = tab[index = (n - 1) &amp; hash]) != null) {<br>            TreeNode&lt;K,V&gt; hd = null, tl = null;<br>            do {<br>                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);<br>                if (tl == null)<br>                    hd = p;<br>                else {<br>                    p.prev = tl;<br>                    tl.next = p;<br>                }<br>                tl = p;<br>            } while ((e = e.next) != null);<br>            if ((tab[index] = hd) != null)<br>                hd.treeify(tab);<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 是所有链表上的数据结构都会转，不可能在一个链表上，即存在红黑树，也存在链表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* `get`方法相对应就简单了</span><br></pre></td></tr></table></figure></p>
<p> public V get(Object key) {<br>        Node&lt;K,V&gt; e;<br>        return (e = getNode(hash(key), key)) == null ? null : e.value;<br>    }<br> // 不断的去取结点，是红黑树就去找红黑树，是聊边就去找链表<br>    final Node&lt;K,V&gt; getNode(int hash, Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {<br>            if (first.hash == hash &amp;&amp; // always check first node<br>                    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return first;<br>            if ((e = first.next) != null) {<br>                if (first instanceof TreeNode)<br>                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                do {<br>                    if (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        return e;<br>                } while ((e = e.next) != null);<br>            }<br>        }<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `HashMap` 是一个线程不安全的容器，发生扩容时会出现环形链表从而导致死循环</span><br><span class="line">*  ` HashMap` 是一个无序的 `Map`，因为每次根据 `key `的 `hashCode `映射到` Entry` 数组上，所以遍历出来的顺序并不是写入的顺序。</span><br><span class="line">* `HashMap` 遍历的速度慢，底层决定了，插入删除的速度快，随机访问的速度也比较快</span><br><span class="line"></span><br><span class="line">#### 五、ConcurrentHashMap</span><br><span class="line">* 支持线程安全的并发容器 `ConcurrentHashMap`,原理和`HashMap`差不多，区别就是采用了` CAS + synchronized` 来保证并发安全性</span><br><span class="line">* `putVal` 加了同步锁 `synchronized `</span><br></pre></td></tr></table></figure></p>
<p> final V putVal(K key, V value, boolean onlyIfAbsent) {<br>        if (key == null || value == null) throw new NullPointerException();<br>        //根据 key 计算出 hashcode<br>        int hash = spread(key.hashCode());<br>        int binCount = 0;<br>        for (Node&lt;K,V&gt;[] tab = table;;) {<br>            Node&lt;K,V&gt; f; int n, i, fh;<br>            // 判断是否需要进行初始化<br>            if (tab == null || (n = tab.length) == 0)<br>                tab = initTable();<br>            //f 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功<br>            else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {<br>                if (casTabAt(tab, i, null,<br>                        new Node&lt;K,V&gt;(hash, key, value, null)))<br>                    break;                   // no lock when adding to empty bin<br>            }<br>            else if ((fh = f.hash) == MOVED)<br>                tab = helpTransfer(tab, f); //如果当前位置的 hashcode == MOVED == -1,则需要进行扩容<br>            else {<br>                //如果都不满足，则利用 synchronized 锁写入数据<br>                V oldVal = null;<br>                // todo  put  数据的时候  加入了锁<br>                synchronized (f) {<br>                    if (tabAt(tab, i) == f) {<br>                        if (fh &gt;= 0) {<br>                            binCount = 1;<br>                            for (Node&lt;K,V&gt; e = f;; ++binCount) {<br>                                K ek;<br>                                if (e.hash == hash &amp;&amp;<br>                                        ((ek = e.key) == key ||<br>                                                (ek != null &amp;&amp; key.equals(ek)))) {<br>                                    oldVal = e.val;<br>                                    if (!onlyIfAbsent)<br>                                        e.val = value;<br>                                    break;<br>                                }<br>                                Node&lt;K,V&gt; pred = e;<br>                                if ((e = e.next) == null) {<br>                                    pred.next = new Node&lt;K,V&gt;(hash, key,<br>                                            value, null);<br>                                    break;<br>                                }<br>                            }<br>                        }<br>                        else if (f instanceof TreeBin) {<br>                            Node&lt;K,V&gt; p;<br>                            binCount = 2;<br>                            if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,<br>                                    value)) != null) {<br>                                oldVal = p.val;<br>                                if (!onlyIfAbsent)<br>                                    p.val = value;<br>                            }<br>                        }<br>                        else if (f instanceof ReservationNode)<br>                            throw new IllegalStateException(“Recursive update”);<br>                    }<br>                }<br>                if (binCount != 0) {<br>                    //如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树<br>                    if (binCount &gt;= TREEIFY_THRESHOLD)<br>                        treeifyBin(tab, i);<br>                    if (oldVal != null)<br>                        return oldVal;<br>                    break;<br>                }<br>            }<br>        }<br>        addCount(1L, binCount);<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  `get`方法</span><br></pre></td></tr></table></figure></p>
<p> public V get(Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;<br>        int h = spread(key.hashCode());<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;<br>                (e = tabAt(tab, (n - 1) &amp; h)) != null) {<br>            //根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值<br>            if ((eh = e.hash) == h) {<br>                if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))<br>                    return e.val;<br>            }<br>            //如果是红黑树那就按照树的方式获取值<br>            else if (eh &lt; 0)<br>                return (p = e.find(h, key)) != null ? p.val : null;<br>            // 就不满足那就按照链表的方式遍历获取值<br>            while ((e = e.next) != null) {<br>                if (e.hash == h &amp;&amp;<br>                        ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))<br>                    return e.val;<br>            }<br>        }<br>        return null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 基本上的变量都是被`volatile`关键字修饰</span><br></pre></td></tr></table></figure></p>
<pre><code>transient volatile Node&lt;K,V&gt;[] table;
private transient volatile Node&lt;K,V&gt;[] nextTable;
private transient volatile long baseCount;
</code></pre><p>   …<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">###  `volatile`关键字  `Java `多线程的三大核心 </span><br><span class="line">####  1、 原子性 :java原子性和数据库事务的原子性差不多，一个操作要么是全部执行成功或者是失败.</span><br><span class="line">  * JVM 只保证了基本的原子性，但是类似 i++ 之类的操作，看着好像是原子的操作，其实里面涉及到了三个步骤</span><br><span class="line">    *  获取 i 的值</span><br><span class="line">    *  自增</span><br><span class="line">    *  在赋值给 i</span><br><span class="line">  * 这三个步骤 要实现`i++` 这样的原子操作就需要用到 `synchronized `或者是 了`lock  `进行加锁处理。</span><br><span class="line">  *  如果是基础类的自增操作可以使用` AtomicInteger` 这样的原子类来实现(其本质是利用了` CPU` 级别的 的 `CAS` 指令来完成的)。` AtomicInteger` 是线程安全的</span><br><span class="line">* 其中用的最多的方法就是: incrementAndGet() 以原子的方式自增</span><br></pre></td></tr></table></figure></p>
<p>  AtomicInteger atomicInteger=new    AtomicInteger();<br>        int i = atomicInteger.incrementAndGet();<br>        System.out.println(“i=”+i); </p>
<pre><code>public final int incrementAndGet() {
     return U.getAndAddInt(this, VALUE, 1) + 1;
 }
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">####  2、可见性</span><br><span class="line">  *  现在的计算机，由于 `cpu` 直接从 主内存中读取数据的效率不高。所以都会对应的 `cpu`高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存中，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时读取就是修改之前的数据 </span><br><span class="line">  </span><br><span class="line">  *  `volatile `关键字就是用于保存内存的可见性，当线程A更新了` volatite`的修饰的变量的话，他会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新的值</span><br><span class="line">  </span><br><span class="line">  *` synchronized` 和加锁也能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和` volatile` 相比较起来开销比较大 ！</span><br><span class="line">  </span><br><span class="line">  * 但是` volatile `不能够替换` synchronized `因为`volatile` 不能够保证原子性 (要么执行成功或者失败，没有中间的状态) </span><br><span class="line"></span><br><span class="line">#### 3、顺序性</span><br></pre></td></tr></table></figure>
<p>int a = 100 ; //1<br>int b = 200 ; //2<br>int c = a + b ; //3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">  * 正常的代码的执行顺序应该是`1》》2》》3 `。但是有时候 `JVM `为了提高整体的效率会进行指令重排导致执行顺序可能是 `2》》1》》3 `。但是`JVM` 也不能是 什么都进行重排，`是在保证最终结果和代码顺序执行结果是一致的情况下才可能会进行重排`</span><br><span class="line">  * 重排在单线程中不会出现问题，但是在多线程中就会出现顺序不一致的问题 </span><br><span class="line">  *  `java `中可以使用 `volatile` 关键字来保证顺序性，`synchronized `和`lock` 也可以来保证有序性，和保证 原子性的方式一样，通过同一段时间只能一个线程访问来实现的 </span><br><span class="line">  * 除了 `volatile` 关键字显式的保证顺序之外，`jvm HIA`通过 `happen-before` 原则来隐式来保证顺序性。</span><br><span class="line"></span><br><span class="line">*  `volitle`的应用，主要是在单利，个人感觉这是常用的在移动端的开发!当然可以使用内部类或者是单利去实现，[更多的设计模式](https://www.jianshu.com/p/4e01479b6a2c)   </span><br><span class="line">   *  1、`volatile` 实现一个双重检查锁的单例模式</span><br></pre></td></tr></table></figure></p>
<pre><code>   public class Singleton {
    private static volatile Singleton singleton;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  * 这里的 `volatile` 关键字主要是为了防止指令重排。 如果不用` volatile `，`singleton = new Singleton()`;，这段代码其实是分为三步：</span><br><span class="line">    * 分配内存空间。(1)</span><br><span class="line">     *  初始化对象。(2)</span><br><span class="line">     * 将 singleton 对象指向分配的内存地址。(3)</span><br><span class="line">  * 加上` volatile` 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</span><br><span class="line">*  2、控制停止线程的标记</span><br></pre></td></tr></table></figure>
</code></pre><p>  private volatile boolean flag ;<br>     private void run(){<br>        new Thread(new Runnable() {<br>            @Override<br>            public void run() {<br>                doSomeThing();<br>            }<br>        });<br>    }</p>
<pre><code>private void stop(){
    flag = false ;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> *  如果没有用`volatile` 来修饰` flag `，就有可能其中一个线程调用了 `stop()`方法修改了` flag `的值并不会立即刷新到主内存中，导致这个循环并不会立即停止.这里主要利用的是 `volatile` 的内存可见性 .</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 六、HashSet</span><br><span class="line">* `HashSet` 是一个不允许存储重复元素的集合。</span><br><span class="line">* `HashSet`的源码只有三百多行，原理非常简单，主要底层还是`HashMap`。</span><br><span class="line">*  `map` 和 `PERSENT`:</span><br></pre></td></tr></table></figure>
<pre><code>//  map ：用于存放最终数据的。
private transient HashMap&lt;E,Object&gt; map;

// Dummy value to associate with an Object in the backing Map
// PRESENT ：是所有写入 map 的 value 值。
private static final Object PRESENT = new Object();
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法:底层一个hashMap</span><br></pre></td></tr></table></figure>
<pre><code>public HashSet() {
    map = new HashMap&lt;&gt;();
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关键的就是这个 `add() `方法。 可以看出它是将存放的对象当做了 `HashMap `的健，`value` 都是相同的 `RESENT `。由于 `HashMap` 的 `key` 是不能重复的，所以每当有重复的值写入到 `HashSet `时，`value `会被覆盖，但 `key `不会受到影响，这样就保证了` HashSet` 中只能存放不重复的元素。</span><br></pre></td></tr></table></figure>
<p>  public boolean add(E e) {<br>        return map.put(e, PRESENT)==null;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 七、LinkedHashMap</span><br><span class="line">*  `HashMap` 是一个无序的 `Map`，每次根据 `key` 的 `hashcode` 映射到 `Entry` 数组上，所以遍历出来的顺序并不是写入的顺序。 因此 `JDK` 推出一个基于` HashMap `但具有顺序的` LinkedHashMap `来解决有排序需求的场景。它的底层是继承于` HashMap `实现的，由一个双向链表所构成。</span><br><span class="line">* ` LinkedHashMap` 的排序方式有两种：</span><br><span class="line">     *  根据写入顺序排序。</span><br><span class="line">      *  根据访问顺序排序(LRU底层的原理)。 其中根据访问顺序排序时，每次` get `都会将访问的值移动到链表末尾，这样重复操作就能得到一个按照访问顺序排序的链表。</span><br><span class="line">*  `LinkedHashMap`中的 `Entry`:利用了头节点和其余的各个节点之间通过 `Entry `中的 `after `和 `before `指针进行关联</span><br></pre></td></tr></table></figure></p>
<pre><code>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {
    Entry&lt;K,V&gt; before, after;
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {
        super(hash, key, value, next);
    }
}
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 变量</span><br></pre></td></tr></table></figure>
<p>  // 用于指向双向链表的头部<br>    transient LinkedHashMap.Entry&lt;K,V&gt; head;<br>    //用于指向双向链表的尾部</p>
<pre><code>transient LinkedHashMap.Entry&lt;K,V&gt; tail;
// LinkedHashMap 如何达到有序的关键
//   todo   还有一个 accessOrder 成员变量，默认是 false，默认按照插入顺序排序，为 true 时按照访问顺序排序，也可以调用
final boolean accessOrder;
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  构造方法，`LRUchace `最近最少使用的缓存底层就是这个构造函数。</span><br></pre></td></tr></table></figure>
<p> public LinkedHashMap(int initialCapacity,<br>                         float loadFactor,<br>                         boolean accessOrder) {<br>        super(initialCapacity, loadFactor);<br>        this.accessOrder = accessOrder;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 侧重关注 `put`，会走父类`HashMap`中的`put`方法，具体请看`HashMap` `put` 方法的解释</span><br><span class="line">   * 1、 在 `LinkedHashMap` 重写了,`newNode`的方法。 使用了` LinkedHashMap.Entry `里面多了两个结点    `Entry&lt;K,V&gt; before, after`;</span><br></pre></td></tr></table></figure></p>
<pre><code>  Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {
    LinkedHashMap.Entry&lt;K,V&gt; p =
            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    //秘密就在于 new的是自己的Entry类，然后调用了linkedNodeLast
    linkNodeLast(p);
    return p;
}
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  2、实现了`afterNodeAccess()`方法， ` void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;`！此函数执行的效果就是将最近使用的Node，放在链表的最末尾。特别说明一下，这里是显示链表的修改后指针的情况，实际上在桶里面的位置是不变的，只是前后的指针指向的对象变了！</span><br></pre></td></tr></table></figure>

 //  此函数执行的效果就是将最近使用的Node，放在链表的最末尾
void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last
    LinkedHashMap.Entry&lt;K,V&gt; last;
    //仅当按照LRU原则且e不在最末尾，才执行修改链表，将e移到链表最末尾的操作
    if (accessOrder &amp;&amp; (last = tail) != e) {
        //将e赋值临时节点p， b是e的前一个节点， a是e的后一个节点
        LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
        //设置p的后一个节点为null，因为执行后p在链表末尾，after肯定为null
        p.after = null;
        //p前一个节点不存在，情况一
        if (b == null)
            head = a;
        else
            b.after = a;
        if (a != null)
            a.before = b;
            //p的后一个节点不存在，情况二
        else
            last = b;
        if (last == null)
            head = p;
        else {    //正常情况，将p设置为尾节点的准备工作，p的前一个节点为原先的last，last的after为p
            p.before = last;
            last.after = p;
        }
        //将p设置为将p设置为尾节点
        tail = p;
        ++modCount;    // 修改计数器+1
    }
}

 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  3、 `put`方法 执行的第二个步骤   ，这个方法没什么用尽可能删除最老的 插入后把最老的`Entry`删除，不过`removeEldestEntry`总是返回`false`，所以不会删除，估计又是一个方法给子类用的</span><br></pre></td></tr></table></figure>

void afterNodeInsertion(boolean evict) { // possibly remove eldest
    LinkedHashMap.Entry&lt;K,V&gt; first;
    if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {
        K key = first.key;
        // todo hashmap中移除 Node结点
        removeNode(hash(key), key, null, false, true);
    }
}
 // 如果映射表示缓存，这是有用的：它允许通过删除过时条目来减少内存消耗的映射。
protected boolean removeEldestEntry(Map.Entry&lt;K,V&gt; eldest) {
    return false;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  4 、`afterNodeRemoval()`移除结点也会重写，因为结点都不一样</span><br></pre></td></tr></table></figure>

   void afterNodeRemoval(Node&lt;K,V&gt; e) { // unlink
    //与afterNodeAccess一样，记录e的前后节点b，a
    LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;
    //p已删除，前后指针都设置为null，便于GC回收
    p.before = p.after = null;
    //与afterNodeAccess一样类似，一顿判断，然后b，a互为前后节点
    if (b == null)
        head = a;
    else
        b.after = a;
    if (a == null)
        tail = b;
    else
        a.before = b;
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `get()`方法详情,然后调用父类`HashMap` 的`getNode()`去找结点</span><br></pre></td></tr></table></figure>
</code></pre><p>  public V get(Object key) {<br>        Node&lt;K,V&gt; e;<br>        //调用HashMap的getNode的方法，<br>        if ((e = getNode(hash(key), key)) == null)<br>            return null;<br>        if (accessOrder)<br>            afterNodeAccess(e);<br>        return e.value;<br>    }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  `HashMap`中的`getNode()` 方法</span><br></pre></td></tr></table></figure></p>
<p>  final Node&lt;K,V&gt; getNode(int hash, Object key) {<br>        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;<br>        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) {<br>            if (first.hash == hash &amp;&amp; // always check first node<br>                    ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                return first;<br>            if ((e = first.next) != null) {<br>                if (first instanceof TreeNode)<br>                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);<br>                do {<br>                    if (e.hash == hash &amp;&amp;<br>                            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))<br>                        return e;<br>                } while ((e = e.next) != null);<br>            }<br>        }<br>        return null;<br>    }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于访问顺序排序的Demo,我只想说明了一下，等于用了的数据，就会放在链表的末尾，这个类也是安卓中`LruCache`的底层原理</span><br></pre></td></tr></table></figure></p>
<p>LinkedHashMap&lt;String, Integer&gt; map1 = new LinkedHashMap&lt;String, Integer&gt;(10, (float) 0.75,true);<br>        map1.put(“1”,1) ;<br>        map1.put(“2”,2) ;<br>        map1.put(“3”,3) ;<br>        map1.put(“4”,4) ;<br>        map1.put(“5”,5) ;<br>        map1.put(“6”,6) ;<br>        map1.put(“7”,7) ;<br>        map1.put(“8”,8) ;<br>        map1.put(“9”,9) ;<br>        map1.put(“10”,10) ;<br>        map1.get(“6”);<br>        // {1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8, 9=9, 10=10, 6=6}<br>        System.out.println(“map1==”+map1);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  ![LinkedHashMap的原理.png](https://upload-images.jianshu.io/upload_images/5363507-704c9d041bbdeae2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 八、LruCache</span><br><span class="line">* `Android`中提供了一种基本的缓存策略，即`LRU（least recently used）`。基于该种策略，当存储空间用尽时，缓存会清除最近最少使用的对象</span><br><span class="line">*  `LRU（Least Recently Used）`最近最少使用的，看了源码才知道核心是`LRUCache`类，这个类的核心其实是 `LinkedHashMap`类.</span><br><span class="line">*  Demo 如下</span><br></pre></td></tr></table></figure></p>
<p> LruCache&lt;Integer,String&gt; lruCache=new LruCache&lt;&gt;(5);<br>        lruCache.put(1,”1”);<br>        lruCache.put(2,”2”);<br>        lruCache.put(3,”3”);<br>        lruCache.put(4,”4”);<br>        lruCache.put(5,”5”);</p>
<pre><code>lruCache.get(1);
lruCache.get(2);
lruCache.get(3);
lruCache.get(4);
Map&lt;Integer, String&gt; snapshot = lruCache.snapshot();


//lruCache={5=5, 1=1, 2=2, 3=3, 4=4}    5最少使用到
System.out.println(&quot;lruCache=&quot;+snapshot.toString());
//当多添加一个的话，那么5就会被删除，加入6上去
lruCache.put(6,&quot;6&quot;);
// new  lruCache={1=1, 2=2, 3=3, 4=4, 6=6}
Map&lt;Integer, String&gt; snapshot1 = lruCache.snapshot();
System.out.println(&quot; new  lruCache=&quot;+snapshot1.toString());
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法,可以明显看出，底层使用的是`LinkedHashMap`.</span><br></pre></td></tr></table></figure>
<p> public LruCache(int maxSize) {<br>        if (maxSize &lt;= 0) {<br>            throw new IllegalArgumentException(“maxSize &lt;= 0”);<br>        }<br>        this.maxSize = maxSize;<br>        // 初始化这里 就是  new的 true的  所以使用的顺序排序<br>        this.map = new LinkedHashMap&lt;K, V&gt;(0, 0.75f, true);<br>    }</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `put`方法 :重要的就是在添加过缓存对象后，调用` trimToSize()`方法，来判断缓存是否已满，如果满了就要删除近期最少使用的算法.同时线程也是安全的。</span><br></pre></td></tr></table></figure>
<p>   public final V put(K key, V value) {<br>        //不可为空，否则抛出异常<br>        if (key == null || value == null) {<br>            throw new NullPointerException(“key == null || value == null”);<br>        }</p>
<pre><code>    V previous;
    // 多线程 可以使用
    synchronized (this) {
        //插入的缓存对象值加1
        putCount++;
        //增加已有缓存的大小
        size += safeSizeOf(key, value);
        //向map中加入缓存对象
        previous = map.put(key, value);
        if (previous != null) {
            //如果已有缓存对象，则缓存大小恢复到之前
            size -= safeSizeOf(key, previous);
        }
    }
    //entryRemoved()是个空方法，可以自行实现
    if (previous != null) {
        entryRemoved(false, key, previous, value);
    }
    //调整缓存大小(关键方法)
    trimToSize(maxSize);
    return previous;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*  1、`safeSizeOf`方法,这个`sizeof`的方法，就是我们自己需要重写的，记得图片加载框架的设计，就会运用到他</span><br></pre></td></tr></table></figure>
<pre><code>private int safeSizeOf(K key, V value) {
    //  每一个的需要缓存的大小
    int result = sizeOf(key, value);
    if (result &lt; 0) {
        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
    }
    return result;
}
protected int sizeOf(K key, V value) {
    return 1;
}
</code></pre>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 2、调整缓存大小(关键方法) `trimToSize(maxSize);` `maxSize`也就是指定的大小，当`     if (size &lt;= maxSize) &#123; break; &#125;`这个判断不成立的时候，就会往下走，迭代器就会去获取第一个对象，即队尾的元素，近期最少访问的元素。然后把它删除该对象，并更新缓存大小 `  map.remove(key);`</span><br></pre></td></tr></table></figure>
<p>  private void trimToSize(int maxSize) {<br>        while (true) {<br>            K key;<br>            V value;<br>            synchronized (this) {<br>                if (size &lt; 0 || (map.isEmpty() &amp;&amp; size != 0)) {<br>                    throw new IllegalStateException(getClass().getName()</p>
<pre><code>                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);
            }

            if (size &lt;= maxSize) {
                break;
            }
            //迭代器获取第一个对象，即队尾的元素，近期最少访问的元素
            Map.Entry&lt;K, V&gt; toEvict = null;
            for (Map.Entry&lt;K, V&gt; entry : map.entrySet()) {
                toEvict = entry;
            }
            if (toEvict == null) {
                break;
            }
            key = toEvict.getKey();
            value = toEvict.getValue();
            //删除该对象，并更新缓存大小
            map.remove(key);
            size -= safeSizeOf(key, value);
            evictionCount++;
        }
        // 空实现
        entryRemoved(true, key, value, null);
    }
}
</code></pre>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 关于 `get`方法！也是一个同步的方法。</span><br></pre></td></tr></table></figure>
<p> public final V get(K key) {<br>        //key为空抛出异常<br>        if (key == null) {<br>            throw new NullPointerException(“key == null”);<br>        }</p>
<pre><code>V mapValue;
synchronized (this) {
    //获取对应的缓存对象
    //get()方法会实现将访问的元素更新到队列头部的功能
    // todo LinkedHashMap  里面已经实现了 如果 添加到头部去
    mapValue = map.get(key);
    if (mapValue != null) {
        hitCount++;
        return mapValue;
    }
    missCount++;
}
</code></pre><p> …<br>}<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `LruCache`使用的`Demo`,这个 `Demo` 就看看，没吊用。</span><br></pre></td></tr></table></figure></p>
<p> public class ImageCache {<br>        //定义LruCache，指定其key和保存数据的类型<br>        private LruCache&lt;String, Bitmap&gt; mImageCache;</p>
<pre><code>    ImageCache() {
        //获取当前进程可以使用的内存大小，单位换算为KB
        final int maxMemory = (int)(Runtime.getRuntime().maxMemory() / 1024);

        //取总内存的1/4作为缓存
        final int cacheSize = maxMemory / 4;

        //初始化LruCache
        mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) {

            //定义每一个存储对象的大小
            @Override
            protected int sizeOf(String key, Bitmap bitmap) {
                return bitmap.getRowBytes() * bitmap.getHeight() / 1024;
            }
        };
    }

    //获取数据
    public Bitmap getBitmap(String url) {
        return mImageCache.get(url);
    }

    //存储数据
    public void putBitmap(String url, Bitmap bitmap) {
        mImageCache.put(url, bitmap);
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 九、SparseArray</span><br><span class="line">*  `SparseArray`是`android`里为`&lt;Interger,Object&gt;` 这样的`Hashmap`而专门写的类,目的是提高效率，其核心是折半查找函数（`binarySearch`）。` SparseArray  `仅仅提高内存效率，而不是提高执行效率，所以也决定它只适用于`android`系统（内存对android项目有多重要）`SparseArray`不需要开辟内存空间来额外存储外部映射，从而节省内存。</span><br><span class="line"></span><br><span class="line">* 变量,核心就是两个数组:`mKeys`  `mValues`</span><br></pre></td></tr></table></figure>
<p> //是否可以回收，即清理mValues中标记为DELETED的值的元素<br>    private boolean mGarbage = false;<br>    private int[] mKeys;        //保存键的数组<br>    private Object[] mValues;   //保存值的数组<br>    private int mSize;          //当前已经保存的数据个数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 构造方法 ：如果`initialCapacity=0`那么`mKeys,mValuse`都初始化为`size=0`的数组，当`initialCapacity&gt;0`时，系统生成`length=initialCapacity`的`value`数组，同时新建一个同样长度的`key`数组。</span><br></pre></td></tr></table></figure></p>
<pre><code> public SparseArray() {
    this(10);
  }
public SparseArray(int initialCapacity) {
    if (initialCapacity == 0) {
        mKeys = EmptyArray.INT;
        mValues = EmptyArray.OBJECT;
    } else {
        /* ArrayUtils.newUnpaddedObjectArray 的源码
   public static Object[] newUnpaddedObjectArray(int minLen) {
   return (Object[])VMRuntime.getRuntime().newUnpaddedArray(Object.class, minLen);
      }
         */
        mValues = ArrayUtils.newUnpaddedObjectArray(initialCapacity);
        mKeys = new int[mValues.length];
    }
    mSize = 0;
}
</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于`put`方法,关键是通过二分查找，查找相对应的`i`角标,如果存在的话，直接赋值新的值，如果不存在的话，取 `~i` 位非运算符（`~`）: 十进制变二进制：原码--反码--加一（补码），相当于 value +1 然后 取反  就可以了.然后就会走到 ` mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);`和 ` mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);` 中，这样就完成了赋值的过程。</span><br></pre></td></tr></table></figure>
<p>   public void put(int key, E value) {<br>        // 二分查找，这个i的值,<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br>        //如果找到了，就把这个值给替换上去 ，或者是赋值上去<br>        //  这里 也就可以解释出为啥 替换为最新的值<br>        if (i &gt;= 0) {<br>            mValues[i] = value;<br>        } else {<br>            //这里就是key要插入的位置，上面二分查找方法提到过<br>            //位非运算符（~）<br>            i = ~i;<br>            if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {<br>                mKeys[i] = key;<br>                mValues[i] = value;<br>                return;<br>            }</p>
<pre><code>        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {
            gc();

            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }
       // 一个新的值  ，就会把key 和 value 和 i值插入到两个数组中
        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        // todo    然后长度 加上 1   nice
        mSize++;
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*  `get`方法:通过二分查找法，在`mKeys`数组中查询`key`的位置，然后返回`mValues`数组中对应位置的值，找不到则返回默认值</span><br></pre></td></tr></table></figure>
<p> public E get(int key, E valueIfKeyNotFound) {<br>  // 二分查找  感觉不像啊 卧槽<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);</p>
<pre><code>    if (i &lt; 0 || mValues[i] == DELETED) {
        return valueIfKeyNotFound;
    } else {
        return (E) mValues[i];
    }
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `delete`其实就是把这个 `mValues[i]`标记为 `DELETED`.</span><br></pre></td></tr></table></figure>
<p>public void delete(int key) {<br>        int i = ContainerHelpers.binarySearch(mKeys, mSize, key);<br>       /<em><br>       i&gt;0表示，找到了key对应的下标，否则应该是负数。同时判断mValues[i] 是不是Object这个对象，如果不是，直接替换为Object（DELETE起到标记删除位置的作用）,并标记 mGarbage=true，注意：这里delete只操作了values数组，并没有去操作key数组;
        </em>/<br>        if (i &gt;= 0) {<br>            if (mValues[i] != DELETED) {<br>                mValues[i] = DELETED;<br>                mGarbage = true;<br>            }<br>        }<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* `removeReturnOld` 其实就是多了一步，把要删除的值返回，其余同`delete`一样</span><br></pre></td></tr></table></figure></p>
<pre><code> public E removeReturnOld(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        if (mValues[i] != DELETED) {
            final E old = (E) mValues[i];
            mValues[i] = DELETED;
            mGarbage = true;
            return old;
        }
    }
    return null;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* `clear`  这里要留意，`clear`只是清空了`values`数组，并没有操作`keys`数组,这里也是传递的地址值，然后通过`for`循环，把每个元素清空！</span><br></pre></td></tr></table></figure>
<p>  public void clear() {<br>        int n = mSize;<br>        Object[] values = mValues;<br>        for (int i = 0; i &lt; n; i++) {<br>            values[i] = null;<br>        }<br>        mSize = 0;<br>        mGarbage = false;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 其实还有个方法`append`,添加数据的时候最好去使用它，因为它会判断下`mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]`、如果满足了才会调用 `put`方法，不满足，直接添加数据，而不是一上来就开始进行二分查找。</span><br></pre></td></tr></table></figure></p>
<p> // 要使用这个方法 好点 。<br>    public void append(int key, E value) {<br>        // 判断了是否 需要 二分查找，还是直接插入<br>        if (mSize != 0 &amp;&amp; key &lt;= mKeys[mSize - 1]) {<br>            put(key, value);<br>            return;<br>        }</p>
<pre><code>    if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {
        // 通过gc的方法，把DELETED值的 values 清空
        gc();
    }
    // 可以直接都要这里来 ，是最节约能量
    mKeys = GrowingArrayUtils.append(mKeys, mSize, key);
    mValues = GrowingArrayUtils.append(mValues, mSize, value);
    mSize++;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 关于原型模式中的深拷贝的实现，这里也帮我指明了，一定要记得拷贝类中的容器</span><br></pre></td></tr></table></figure>
<p>  @Override<br>    @SuppressWarnings(“unchecked”)<br>    public SparseArray<e> clone() {<br>        SparseArray<e> clone = null;<br>        try {<br>            clone = (SparseArray<e>) super.clone();<br>            //  原型模式的深拷贝   两个容器的拷贝的过程—-！！！<br>            clone.mKeys = mKeys.clone();<br>            clone.mValues = mValues.clone();<br>        } catch (CloneNotSupportedException cnse) {<br>            /<em> ignore </em>/<br>        }<br>        return clone;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 其他的 `SparseBooleanArray  SparseIntArray SparseLongArray` 的原理一样</span><br><span class="line">*  `SparseArray`与`HashMap`无论是怎样进行插入,数据量相同时,前者都要比后者要省下一部分内存,但是效率呢？----在倒序插入的时候,`SparseArray`的插入时间和`HashMap`的插入时间远远不是一个数量级.由于`SparseArray`每次在插入的时候都要使用二分查找判断是否有相同的值被插入.因此这种倒序的情况是`SparseArray`效率最差的时候.</span><br><span class="line"></span><br><span class="line">* 附赠一个二分查找</span><br></pre></td></tr></table></figure></e></e></e></p>
<p> /**</p>
<pre><code> * 二分查找
 * @param ints  需要被查找的数组
 * @param length  数组的长度
 * @param value  查找的值
 */
private int binarySearch(int[] ints, int length, int value) {

    int i = 0;
    int h = length - 1;
    while (i &lt;= h) {
        /**
         * &gt;&gt;&gt;与&gt;&gt;唯一的不同是它无论原来的最左边是什么数，统统都用0填充。
         * —比如你的例子，byte是8位的，-1表示为byte型是11111111(补码表示法）
         * b&gt;&gt;&gt;4就是无符号右移4位，即00001111，这样结果就是15。
         * 这里相当移动一位，除以二
         */
        //中间的角标
        final int mid = (i + h) &gt;&gt;&gt; 1;// 第一次 2 第二次 mid=3 第三次mid=4
        final int midVal = ints[mid];// 第一次 3 第二次 midVal=4 第三次mid=5
        if (midVal &lt; value) {
            i = mid + 1;// 第一次 3  第二次 i=4
        } else if (value &lt; midVal) {
            h = mid - 1;
        } else if (value == midVal) {
            return mid; //第三次mid=5 返回了
        }
    }
    // 这个取反 ，相当于 value +1 然后 取反  就可以了
    return ~value;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 附赠`System.arraycopy()` 的用法</span><br></pre></td></tr></table></figure>
<p> int[] mKeys={10,5,14,5,46};<br>       int[] newKeys=new int[5];<br>        /*</p>
<pre><code> * @param      src      源数组。
 * @param      srcPos    表示源数组要复制的起始位置，
 * @param      dest     目的地数组。
 * @param      destPos  在目标数据中的起始位置。
 * @param      length   要复制的数组元素的数目。
 */
// todo  source of type android.util.SparseArray is not an array
// destPsot +length  不能超过 新的数组的长度
System.arraycopy(mKeys,0, newKeys, 2, 3);
for (Integer str : newKeys) {
    System.out.print(&quot;newKeys=&quot;+str+&quot;   &quot;);
}
</code></pre><p><code>`</code></p>
<h4 id="最后说明几点"><a href="#最后说明几点" class="headerlink" title="最后说明几点"></a>最后说明几点</h4><ul>
<li><code>ArrayList</code> 的主要消耗是数组扩容以及在指定位置添加数据，在日常使用时最好是指定大小，尽量减少扩容。更要减少在指定位置插入数据的操作。</li>
<li><code>ArrayList</code>遍历的速度快，插入删除速度慢，随机访问的速度快</li>
<li><code>LinkedList</code> 插入，删除都是移动指针效率很高。查找需要进行遍历查询，效率较低。二分查找，如果查找的index的越接近size的一半的话，这样查找的效率很低</li>
<li><code>HashMap</code> 是一个线程不安全的容器，发生扩容时会出现环形链表从而导致死循环</li>
<li><code>HashMap</code> 是一个无序的 <code>Map</code>，因为每次根据 <code>key</code>的 <code>hashCode</code>映射到<code>Entry</code> 数组上，所以遍历出来的顺序并不是写入的顺序。</li>
<li><code>HashMap</code> 遍历的速度慢，底层决定了，插入删除的速度快，随机访问的速度也比较快</li>
<li><code>ConcurrentHashMap</code> 并发容器，区别就是采用了CAS + synchronized 来保证并发安全性</li>
<li>位与运算符<code>&amp;</code>,把做运算的两个数都转化为二进制的，然后从高位开始比较，如果两个数都是<code>1</code>则为<code>1</code>，否者为<code>0</code></li>
<li>无符号的右移（<code>&gt;&gt;&gt;</code>）:按照二进制把数字右移指定数位，高位直接补零，低位移除！ </li>
<li><code>a=a|b</code> 等于 <code>a|=b</code>的意思就是把<code>a</code>和<code>b</code>按位或然后赋值给<code>a</code> 按位或的意思就是先把<code>a</code>和<code>b</code>都换成<code>2</code>进制，然后用或操作<ul>
<li>位异或运算（<code>^</code>）: 运算规则是两个数转为二进制，然后从高位开始比较，如果相同则为<code>0</code>，不相同则为<code>1</code></li>
<li><code>HashSet</code> 底层其实就是 <code>HashMap</code>，只不过是一个<code>value</code>都一样的<code>HashSet</code>.</li>
<li><code>LRU（Least Recently Used）</code>最近最少使用的，看了源码才知道核心是<code>LRUCache</code>类，这个类的核心其实是 <code>LinkedHashMap</code>类.</li>
</ul>
</li>
<li><code>~i</code> 位非运算符（<code>~</code>）: 十进制变二进制：原码–反码–加一（补码），相当于 value +1 然后 取反  就可以了</li>
<li><code>SparseArray</code> <code>SparseBooleanArray  SparseIntArray SparseLongArray</code> 的原理一样</li>
<li><code>SparseArray</code>与<code>HashMap</code>无论是怎样进行插入,数据量相同时,前者都要比后者要省下一部分内存,但是效率呢？—-在倒序插入的时候,<code>SparseArray</code>的插入时间和<code>HashMap</code>的插入时间远远不是一个数量级.由于<code>SparseArray</code>每次在插入的时候都要使用二分查找判断是否有相同的值被插入.因此这种倒序的情况是<code>SparseArray</code>效率最差的时候.</li>
<li>二分查找，是当角标越接近数组长度的一半，效率越低</li>
<li>卧槽，刚看了一下总共将近一万字，光写的过程用了16个小时，整理资料大概是10个小时。</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/08/22/常用集合的原理分析/">常用集合的原理分析</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Shiming_Li</a></p>
        <p><span>发布时间:</span>2018-08-22, 16:38:13</p>
        <p><span>最后更新:</span>2018-08-22, 16:40:52</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/08/22/常用集合的原理分析/" title="常用集合的原理分析">http://yoursite.com/2018/08/22/常用集合的原理分析/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/08/22/常用集合的原理分析/　　作者: Shiming_Li" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/08/27/新零售平台V1/">
                    新零售平台V1
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/08/14/Hexo-GitHub-阿里域名搭建自己博客/">
                    Hexo+GitHub+阿里域名搭建自己博客
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、ArrayList"><span class="toc-number">1.</span> <span class="toc-text">一、ArrayList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、Vector"><span class="toc-number">2.</span> <span class="toc-text">二、Vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#三、LinckedList"><span class="toc-number">3.</span> <span class="toc-text">三、LinckedList</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#四、HashMap"><span class="toc-number">4.</span> <span class="toc-text">四、HashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最后说明几点"><span class="toc-number">5.</span> <span class="toc-text">最后说明几点</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"常用集合的原理分析　| 仕明的后花园　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/08/27/新零售平台V1/" title="上一篇: 新零售平台V1">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/08/14/Hexo-GitHub-阿里域名搭建自己博客/" title="下一篇: Hexo+GitHub+阿里域名搭建自己博客">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/09/03/剑指offer中几道算法题的思考/">剑指几道算法题的思考</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/09/02/智能食柜/">智能食柜</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/27/新零售平台V1/">新零售平台V1</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/22/常用集合的原理分析/">常用集合的原理分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Hexo-GitHub-阿里域名搭建自己博客/">Hexo+GitHub+阿里域名搭建自己博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-9-Pie-正式版总结/">Android 9 Pie 正式版总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/安卓invalidate、postInvalidate、requestLayout源码分析/">安卓invalidate、postInvalidate、requestLayout源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/Go语言实现RPC/">Go语言实现RPC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/15/Go语言实现的WebSocket/">Go语言实现的WebSocket</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/Go语言使用MySQL数据库/">Go语言使用MySQL数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/Web的工作方式/">Web的工作方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/Android源码分析-View的绘制流程/">Android源码分析:View的绘制流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析LayoutInflater/">Android源码分析LayoutInflater</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析ViewStub源码解析/">Android源码分析ViewStub源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Android源码分析（Activity-setContentView源码析/">Android源码分析（Activity.setContentView源码解析）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/Android源码分析（Handler机制）/">Android源码分析（Handler机制）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/14/Android源码分析（事件传递）/">Android源码分析（事件传递）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Lint的使用（安卓性能提升必备掌握的工具）/">Lint的使用（安卓性能提升必备掌握的工具）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/27/Java/">注解（Annotation） by Thinking in Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/22/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/PLC通讯的安卓App/">PLC通讯的安卓App</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/安卓画笔笔锋的实现探索（三）田字格Demo/">安卓画笔笔锋的实现探索（三）田字格Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/2018/">2018年</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/自己实现Jni，生成so库，实现高效率的高斯模糊效果/">自己实现Jni，生成so库，实现高效率的高斯模糊效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/26/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/Fragment-setNextAnim/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/自定义PopupWindow的超强使用/">自定义PopupWindow的超强使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/17/如何用AndroidStudio查看和解决OOM/">如何用AndroidStudio查看和解决OOM</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Shiming_Li
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>