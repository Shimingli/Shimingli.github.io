<!DOCTYPE html>
<html lang="zh-CN">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Shiming_Li" />



<meta name="description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 源码基于安卓8.0分析结果 View是何时开始绘制的?Activity走了onCreate方法吗？这篇文章就是从程序的入口ActivityThread入口程序，去解释View中的measure()方法、View中的layout、View中的draw怎么开始调用的，非常有意思！虽然好多的技术文档，在半个月前已经做好了，这篇文章，对">
<meta name="keywords" content="Android源码,绘制,View">
<meta property="og:type" content="article">
<meta property="og:title" content="Android源码分析:View的绘制流程">
<meta property="og:url" content="http://yoursite.com/2018/06/08/Android源码分析-View的绘制流程/index.html">
<meta property="og:site_name" content="仕明的后花园">
<meta property="og:description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 源码基于安卓8.0分析结果 View是何时开始绘制的?Activity走了onCreate方法吗？这篇文章就是从程序的入口ActivityThread入口程序，去解释View中的measure()方法、View中的layout、View中的draw怎么开始调用的，非常有意思！虽然好多的技术文档，在半个月前已经做好了，这篇文章，对">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-9c0147257f0e015b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-c61528fcbe49a9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-06a0a0bfd5bd0ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-14b4c1d369701373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-9f68fbf91f7c7eac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/5363507-07125ab1e5530813.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2018-08-14T08:47:16.514Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android源码分析:View的绘制流程">
<meta name="twitter:description" content="本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 源码基于安卓8.0分析结果 View是何时开始绘制的?Activity走了onCreate方法吗？这篇文章就是从程序的入口ActivityThread入口程序，去解释View中的measure()方法、View中的layout、View中的draw怎么开始调用的，非常有意思！虽然好多的技术文档，在半个月前已经做好了，这篇文章，对">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/5363507-9c0147257f0e015b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="仕明的后花园" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Android源码分析:View的绘制流程 | 仕明的后花园</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script> yiliaConfig.jquery_ui = [false]; </script>



    <script> yiliaConfig.rootUrl = "\/";</script>





    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?1add6c64d9c467153aaed18d249d81c4";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>


</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Shiming_Li</a></h1>
        </hgroup>

        
        <p class="header-subtitle">趁还能折腾的时候多学习！</p>
        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        
            <div id="switch-btn" class="switch-btn">
                <div class="icon">
                    <div class="icon-ctn">
                        <div class="icon-wrap icon-house" data-idx="0">
                            <div class="birdhouse"></div>
                            <div class="birdhouse_holes"></div>
                        </div>
                        <div class="icon-wrap icon-ribbon hide" data-idx="1">
                            <div class="ribbon"></div>
                        </div>
                        
                        <div class="icon-wrap icon-link hide" data-idx="2">
                            <div class="loopback_l"></div>
                            <div class="loopback_r"></div>
                        </div>
                        
                        
                        <div class="icon-wrap icon-me hide" data-idx="3">
                            <div class="user"></div>
                            <div class="shoulder"></div>
                        </div>
                        
                    </div>
                    
                </div>
                <div class="tips-box hide">
                    <div class="tips-arrow"></div>
                    <ul class="tips-inner">
                        <li>菜单</li>
                        <li>标签</li>
                        
                        <li>友情链接</li>
                        
                        
                        <li>关于我</li>
                        
                    </ul>
                </div>
            </div>
        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                <section class="switch-part switch-part2">
                    <div class="widget tagcloud" id="js-tagcloud">
                        <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-9-正式版/">Android 9 正式版</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android-P/">Android P</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android事件传递/">Android事件传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android源码/">Android源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Fragment-setNextAnim-int-on-a-null-object-reference/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Go/">Go</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Golang/">Golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Handler机制/">Handler机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Jni/">Jni</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LayoutInflater/">LayoutInflater</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Lint的使用/">Lint的使用</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OOM/">OOM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PLC/">PLC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PopupWindow/">PopupWindow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RPC/">RPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/So库/">So库</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/View/">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ViewStub/">ViewStub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Web/">Web</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebSocket/">WebSocket</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/invalidate/">invalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/postInvalidate/">postInvalidate</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/requestLayout/">requestLayout</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/setContentView源码解析/">setContentView源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工作方式/">工作方式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/杂文/">杂文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/注解（Annotation）/">注解（Annotation）</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/源码解析/">源码解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/田字格Demo/">田字格Demo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/绘制/">绘制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/谷歌/">谷歌</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/阿里域名/">阿里域名</a></li></ul>
                    </div>
                </section>
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="http://moxfive.xyz/">MOxFIVE</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于移动开发，Go后台开发</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Shiming_Li</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="https://avatars1.githubusercontent.com/u/20720544?s=400&amp;u=c4a1232f66b78874f5f8d1d50479fecdf4458e2c&amp;v=4" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Shiming_Li</a></h1>
            </hgroup>
            
            <p class="header-subtitle">趁还能折腾的时候多学习！</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/Shimingli" title="GitHub"></a>
                            
                                <a class="fa 知乎" target="_blank" href="https://www.zhihu.com/people/li-shi-ming-46-52/activities" title="知乎"></a>
                            
                                <a class="fa 简书" target="_blank" href="https://www.jianshu.com/u/a58eb984bda4" title="简书"></a>
                            
                                <a class="fa 掘金" target="_blank" href="https://juejin.im/user/584a04aea22b9d0058cd2518" title="掘金"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-Android源码分析-View的绘制流程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/06/08/Android源码分析-View的绘制流程/" class="article-date">
      <time datetime="2018-06-08T08:08:28.000Z" itemprop="datePublished">2018-06-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android源码分析:View的绘制流程
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android源码/">Android源码</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/View/">View</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/绘制/">绘制</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <ul>
<li>本篇文章已授权微信公众号 guolin_blog （郭霖）独家发布 <h2 id="源码基于安卓8-0分析结果"><a href="#源码基于安卓8-0分析结果" class="headerlink" title="源码基于安卓8.0分析结果"></a>源码基于安卓8.0分析结果</h2></li>
<li><code>View</code>是何时开始绘制的?<code>Activity</code>走了<code>onCreate</code>方法吗？这篇文章就是从程序的入口<code>ActivityThread</code>入口程序，去解释<code>View中的measure()方法</code>、<code>View中的layout</code>、<code>View中的draw</code>怎么开始调用的，非常有意思！虽然好多的技术文档，在半个月前已经做好了，这篇文章，对我自己来讲的话，是个很好的复习~~</li>
<li>为了更好地阐述着这篇文章，我这里就直接抛出结论了，为啥会这样的，在下篇文章会讲到，这里就记住一点，在<code>Activity onResume</code>后，调用了<code>View onAttachedToWindow</code> 才会开始<code>View measure</code><a id="more"></a>
<img src="https://upload-images.jianshu.io/upload_images/5363507-9c0147257f0e015b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity的生命周期和View的生命周期.jpg"></li>
<li><p>为什么会这样子？先看<code>ActivityThread</code>类里面有个内部<code>private class H extends Handler</code>这就是系统的<code>Handler</code>，具体分析请看<a href="https://www.jianshu.com/p/a2c53e96cae6" target="_blank" rel="noopener">Android源码分析（Handler机制）</a>,里面有个<code>case RESUME_ACTIVITY</code>,获取焦点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">case RESUME_ACTIVITY:</span><br><span class="line">              Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityResume&quot;);</span><br><span class="line">              SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">              handleResumeActivity((IBinder) args.arg1, true, args.argi1 != 0, true,</span><br><span class="line">                      args.argi3, &quot;RESUME_ACTIVITY&quot;);</span><br><span class="line">              Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"> break;</span><br></pre></td></tr></table></figure>
</li>
<li><p>handleResumeActivity()方法,这里只截取了关键的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) &#123;</span><br><span class="line">        ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">        if (!checkAndUpdateLifecycleSeq(seq, r, &quot;resumeActivity&quot;)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = true;</span><br><span class="line">        //在这里执行performResumeActivity的方法中会执行Activity的onResume()方法</span><br><span class="line">        r = performResumeActivity(token, clearHide, reason);</span><br><span class="line">        if (r != null) &#123;</span><br><span class="line">            final Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">            if (localLOGV) Slog.v(</span><br><span class="line">                    TAG, &quot;Resume &quot; + r + &quot; started activity: &quot; +</span><br><span class="line">                            a.mStartedActivity + &quot;, hideForNow: &quot; + r.hideForNow</span><br><span class="line">                            + &quot;, finished: &quot; + a.mFinished);</span><br><span class="line">            final int forwardBit = isForward ?</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0;</span><br><span class="line">            boolean willBeVisible = !a.mStartedActivity;</span><br><span class="line">            if (!willBeVisible) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                            a.getActivityToken());</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    throw e.rethrowFromSystemServer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //PhoneWindow在这里获取到</span><br><span class="line">            if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">                r.window = r.activity.getWindow();</span><br><span class="line">                //DecorView在这里获取到</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                decor.setVisibility(View.INVISIBLE);</span><br><span class="line">                //获取ViewManager对象，在这里getWindowManager()实质上获取的是ViewManager的子类对象WindowManager</span><br><span class="line">                // TODO: 2018/5/24 WindowManager</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">                a.mDecor = decor;</span><br><span class="line">                l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">                l.softInputMode |= forwardBit;</span><br><span class="line">                if (r.mPreserveWindow) &#123;</span><br><span class="line">                    a.mWindowAdded = true;</span><br><span class="line">                    r.mPreserveWindow = false;</span><br><span class="line">                    // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                    // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                    // the decor view we have to notify the view root that the</span><br><span class="line">                    // callbacks may have changed.</span><br><span class="line">                    //获取ViewRootImpl对象</span><br><span class="line">                    ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                    if (impl != null) &#123;</span><br><span class="line">                        impl.notifyChildRebuilt();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一点分析得出<code>performResumeActivity()</code>肯定先于<code>wm.addView(decor, l);</code>执行的~这也是为啥我们 <code>Activity</code>先获取焦点了，才去绘制<code>View</code></p>
</li>
<li>performResumeActivity(),可以得出调用的是<code>r.activity.performResume();</code><br><img src="https://upload-images.jianshu.io/upload_images/5363507-c61528fcbe49a9b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="performResumeActivity"></li>
<li><p>关于<code>r.activity.performResume();</code>；这里也可以，看出，在activity 中的fragment获取焦点要晚于activity，虽然这是常识。注意这个方法<code>mInstrumentation.callActivityOnResume(this);</code>;然后才会执行<code>onPostResume</code>;这也就是为什么，Activity先获取焦点，后执行<code>onPostResume()</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">final void performResume() &#123;</span><br><span class="line">       performRestart();</span><br><span class="line">       mInstrumentation.callActivityOnResume(this);</span><br><span class="line">       mCalled = false;</span><br><span class="line">      //这里也可以，看出，在activity 中的fragment获取焦点要晚于activity，虽然这是常识</span><br><span class="line">       mFragments.dispatchResume();</span><br><span class="line">       mFragments.execPendingActions();</span><br><span class="line">       onPostResume();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关注这个方法<code>mInstrumentation.callActivityOnResume(this)</code>;果然不出所料，这里执行了<code>activity.onResume();</code>;<br><img src="https://upload-images.jianshu.io/upload_images/5363507-06a0a0bfd5bd0ebf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="callActivityOnResume.png"></p>
</li>
<li><p>既然在上面知道了，activity 获取焦点，会在上面执行，那么View的绘制就会在下面的函数中进行。</p>
<ul>
<li>1、获取PhoneWindow；  <code>activity.getWindow()</code>,<code>Window</code>类的唯一子类<ul>
<li>2、获取<code>window.getDecorView()</code>;DecorView,PhoneWindow的内部类，<code>private final class DecorView extends FrameLayout</code> ，安卓的事件分发和它密切相关<a href="https://www.jianshu.com/p/f7e3a14daf51" target="_blank" rel="noopener">Android源码分析（事件传递）</a>,也就是从<code>Activity</code> 传递到 <code>ViewGroup</code>的过程~~</li>
<li>3、获取<code>ViewManager wm = a.getWindowManager();</code>，其实也就是<code>activity.getWindowManager()</code>,也就是获取的是<code>ViewManager</code>的子类对象<code>WindowManager</code>,这里的知道<code>WindowManager</code>其实也是一个接口.<br><img src="https://upload-images.jianshu.io/upload_images/5363507-14b4c1d369701373.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></li>
</ul>
</li>
<li>4、  <code>wm.addView(decor, l);</code>,也就是到这里来了，<code>WindowManager.addView(decor,l)</code>.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">//PhoneWindow在这里获取到</span><br><span class="line">           if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">               r.window = r.activity.getWindow();</span><br><span class="line">               //DecorView在这里获取到</span><br><span class="line">               View decor = r.window.getDecorView();</span><br><span class="line">               decor.setVisibility(View.INVISIBLE);</span><br><span class="line">               //获取ViewManager对象，在这里getWindowManager()实质上获取的是ViewManager的子类对象WindowManager</span><br><span class="line">               // TODO: 2018/5/24 WindowManager</span><br><span class="line">               ViewManager wm = a.getWindowManager();</span><br><span class="line">               WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">               a.mDecor = decor;</span><br><span class="line">               l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">               l.softInputMode |= forwardBit;</span><br><span class="line">               if (r.mPreserveWindow) &#123;</span><br><span class="line">                   a.mWindowAdded = true;</span><br><span class="line">                   r.mPreserveWindow = false;</span><br><span class="line">                   // Normally the ViewRoot sets up callbacks with the Activity</span><br><span class="line">                   // in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span><br><span class="line">                   // the decor view we have to notify the view root that the</span><br><span class="line">                   // callbacks may have changed.</span><br><span class="line">                   //获取ViewRootImpl对象</span><br><span class="line">                   ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">                   if (impl != null) &#123;</span><br><span class="line">                       impl.notifyChildRebuilt();</span><br><span class="line">                   &#125;</span><br><span class="line">               if (!a.mWindowAdded) &#123;</span><br><span class="line">                       a.mWindowAdded = true;</span><br><span class="line">                       //在这里WindowManager将DecorView添加到PhoneWindow中</span><br><span class="line">                       wm.addView(decor, l);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分析到这里来了，会通过<code>WindowManager.addView(decor,l)</code>.我们需要去找<code>WindowManager</code>的实现。<code>WindowManagerImpl</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public final class WindowManagerImpl implements WindowManager &#123;</span><br><span class="line">    private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</span><br><span class="line">   @Override</span><br><span class="line">    public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123;</span><br><span class="line">        applyDefaultToken(params);</span><br><span class="line">        mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>去寻找<code>WindowManagerGlobal</code>的<code>addView()</code>方法。这里有个单利模式,在源码好多地方使用的单利模式都是这样，并没有进行双重判断，在老牌的图片加载框架<code>ImageLoader</code>也是这样获取单利对象，如果想了解更多设计模式的姿势，可以看这片文章<a href="https://www.jianshu.com/p/4e01479b6a2c" target="_blank" rel="noopener">二十三种设计模式</a>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static WindowManagerGlobal getInstance() &#123;</span><br><span class="line">      synchronized (WindowManagerGlobal.class) &#123;</span><br><span class="line">          if (sDefaultWindowManager == null) &#123;</span><br><span class="line">              sDefaultWindowManager = new WindowManagerGlobal();</span><br><span class="line">          &#125;</span><br><span class="line">          return sDefaultWindowManager;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在这里！就是<code>WindowManagerGlobal.addView()</code>的关键的方法，我做了两个注释，一个是<code>view.setLayoutParams(wparams);</code>,这个方法非常有意思，最近在研究ViewGroup的源码，发现不论什么情况下，View或者是ViewGroup都会有两次测量，这里是根本的原因，我先给结论。<br>api26：执行2次onMeasure、1次onLayout、1次onDraw。<br>api25-24：执行2次onMeasure、2次onLayout、1次onDraw，<br>api23-21：执行3次onMeasure、2次onLayout、1次onDraw，<br>api19-16：执行2次onMeasure、2次onLayout、1次onDraw，<br>API等级24：Android 7.0 Nougat<br>API等级25：Android 7.1 Nougat<br>API等级26：Android 8.0 Oreo<br>API等级27：Android 8.1 Oreo<br>后续我会做一篇文章详细解释下，为什么会这样，这里不过多的解释了，自提一句，非常有意思的代码！以前还会有两次的layout，说明谷歌也在优化安卓 <code>framework</code>。todo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void addView(View view, ViewGroup.LayoutParams params,Display display, Window parentWindow) &#123;</span><br><span class="line">   ...</span><br><span class="line">    root = new ViewRootImpl(view.getContext(), display);</span><br><span class="line">          //view setLLayoutParams()在这里</span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line">    try &#123;</span><br><span class="line">              // TODO: 2018/6/4  这里呢？就是ViewRootImpl 调用的setView的方法，就在这里</span><br><span class="line">              root.setView(view, wparams, panelParentView);</span><br><span class="line">          &#125; catch (RuntimeException e) &#123;</span><br><span class="line">              // BadTokenException or InvalidDisplayException, clean up.</span><br><span class="line">              if (index &gt;= 0) &#123;</span><br><span class="line">                  removeViewLocked(index, true);</span><br><span class="line">              &#125;</span><br><span class="line">              throw e;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ok，现在继续的关注这个方法<code>ViewRootImpl.setView(view, wparams, panelParentView)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123;</span><br><span class="line">      synchronized (this) &#123;   try &#123;</span><br><span class="line">               // TODO: 2018/6/4 这里传入的attrs 决定了View 或者是ViewGroup是否会onMeasure 两次</span><br><span class="line">              mWindowAttributes.copyFrom(attrs);</span><br><span class="line">              &#125; catch (RemoteException e) &#123;</span><br><span class="line">                 </span><br><span class="line">                  // TODO: 2018/5/24 就会调动这里的来</span><br><span class="line">                  unscheduleTraversals();</span><br><span class="line">              &#125; finally &#123;</span><br><span class="line">                  if (restore) &#123;</span><br><span class="line">                      attrs.restore();</span><br><span class="line">                  &#125; if (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">                  </span><br><span class="line">                  // TODO: 2018/5/24 就会调动这里的来</span><br><span class="line">                  unscheduleTraversals();&#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unscheduleTraversals(),没有Activity获取焦点的时候，这个方法肯定会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void unscheduleTraversals() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = false;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        mChoreographer.removeCallbacks(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关注mTraversalRunnable对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">final class TraversalRunnable implements Runnable &#123;</span><br><span class="line">      @Override</span><br><span class="line">      public void run() &#123;</span><br><span class="line">          doTraversal();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>doTraversal()方法,Traversal翻译过来就是遍历的意思~~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// TODO: 2018/5/24  到这里来了 ----&gt;     Traversal 遍历</span><br><span class="line">void doTraversal() &#123;</span><br><span class="line">    if (mTraversalScheduled) &#123;</span><br><span class="line">        mTraversalScheduled = false;</span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(&quot;ViewAncestor&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        performTraversals();</span><br><span class="line">        if (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析"><a href="#performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析" class="headerlink" title="performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析"></a><code>performTraversals</code>这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br></pre></td><td class="code"><pre><span class="line">   /**</span><br><span class="line">     * 最终会调动到这里</span><br><span class="line">     * ViewRootImpl的performTraversals()方法完成具体的视图绘制流程</span><br><span class="line">     */</span><br><span class="line">    private void performTraversals() &#123;</span><br><span class="line">        // cache mView since it is used so much below...</span><br><span class="line">        //mView 就是DecorView根布局</span><br><span class="line">        final View host = mView;</span><br><span class="line"></span><br><span class="line">        if (DBG) &#123;</span><br><span class="line">            System.out.println(&quot;======================================&quot;);</span><br><span class="line">            System.out.println(&quot;performTraversals&quot;);</span><br><span class="line">            host.debug();</span><br><span class="line">        &#125;</span><br><span class="line">        //如果host=null  或者是mAdded=false 直接就return了</span><br><span class="line">        if (host == null || !mAdded)</span><br><span class="line">            return;</span><br><span class="line">        //是否正在遍历</span><br><span class="line">        mIsInTraversal = true;</span><br><span class="line">        //是否马上需要绘制View</span><br><span class="line">        mWillDrawSoon = true;</span><br><span class="line">        boolean windowSizeMayChange = false;</span><br><span class="line">        boolean newSurface = false;</span><br><span class="line">        boolean surfaceChanged = false;</span><br><span class="line">        /**</span><br><span class="line">         * 这个WindowMananger 这里标记了 是否是需要 onMeasure 两次 哈哈</span><br><span class="line">         */</span><br><span class="line">        // TODO: 2018/6/4</span><br><span class="line">        WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">        /*</span><br><span class="line">        顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">         */</span><br><span class="line">        int desiredWindowWidth;</span><br><span class="line">        int desiredWindowHeight;</span><br><span class="line"></span><br><span class="line">        final int viewVisibility = getHostVisibility();</span><br><span class="line">        final boolean viewVisibilityChanged = !mFirst</span><br><span class="line">                &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded);</span><br><span class="line">        final boolean viewUserVisibilityChanged = !mFirst &amp;&amp;</span><br><span class="line">                ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE));</span><br><span class="line"></span><br><span class="line">        WindowManager.LayoutParams params = null;</span><br><span class="line">        if (mWindowAttributesChanged) &#123;</span><br><span class="line">            mWindowAttributesChanged = false;</span><br><span class="line">            surfaceChanged = true;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line">        CompatibilityInfo compatibilityInfo =</span><br><span class="line">                mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">        if (compatibilityInfo.supportsScreen() == mLastInCompatMode) &#123;</span><br><span class="line">            params = lp;</span><br><span class="line">            mFullRedrawNeeded = true;</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line">            if (mLastInCompatMode) &#123;</span><br><span class="line">                params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                mLastInCompatMode = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">                mLastInCompatMode = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChangesFlag = 0;</span><br><span class="line"></span><br><span class="line">        Rect frame = mWinFrame;</span><br><span class="line">        //在构造方法中mFirst已经设置为true，表示是否是第一次绘制DecorView</span><br><span class="line">        if (mFirst) &#123;</span><br><span class="line">            mFullRedrawNeeded = true;</span><br><span class="line">            mLayoutRequested = true;</span><br><span class="line"></span><br><span class="line">            final Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            // TODO: 2018/5/25 注意这个方法内部做了什么</span><br><span class="line">            /*</span><br><span class="line">             return lp.type == TYPE_STATUS_BAR_PANEL</span><br><span class="line">                || lp.type == TYPE_INPUT_METHOD</span><br><span class="line">                || lp.type == TYPE_VOLUME_OVERLAY;</span><br><span class="line">             */</span><br><span class="line">            // 如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">            //就是除了状态栏</span><br><span class="line">            if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">                Point size = new Point();</span><br><span class="line">                mDisplay.getRealSize(size);</span><br><span class="line">                desiredWindowWidth = size.x;</span><br><span class="line">                desiredWindowHeight = size.y;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //否者顶层视图DecorView所需要的窗口的宽度和高度就是整个屏幕的宽度</span><br><span class="line">                desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // We used to use the following condition to choose 32 bits drawing caches:</span><br><span class="line">            // PixelFormat.hasAlpha(lp.format) || lp.format == PixelFormat.RGBX_8888</span><br><span class="line">            // However, windows are now always 32 bits by default, so choose 32 bits</span><br><span class="line">            mAttachInfo.mUse32BitDrawingCache = true;</span><br><span class="line">            mAttachInfo.mHasWindowFocus = false;</span><br><span class="line">            mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mLastConfigurationFromResources.setTo(config);</span><br><span class="line">            mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">            // Set the layout direction if it has not been set before (inherit is the default)</span><br><span class="line">            if (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">                host.setLayoutDirection(config.getLayoutDirection());</span><br><span class="line">            &#125;</span><br><span class="line">            host.dispatchAttachedToWindow(mAttachInfo, 0);</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true);</span><br><span class="line">            dispatchApplyInsets(host);</span><br><span class="line">            //Log.i(mTag, &quot;Screen on initialized: &quot; + attachInfo.mKeepScreenOn);</span><br><span class="line"></span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            desiredWindowWidth = frame.width();</span><br><span class="line">            desiredWindowHeight = frame.height();</span><br><span class="line">            if (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">                if (DEBUG_ORIENTATION) Log.v(mTag, &quot;View &quot; + host + &quot; resized to: &quot; + frame);</span><br><span class="line">                mFullRedrawNeeded = true;</span><br><span class="line">                mLayoutRequested = true;</span><br><span class="line">                windowSizeMayChange = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (viewVisibilityChanged) &#123;</span><br><span class="line">            mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">            host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">            if (viewUserVisibilityChanged) &#123;</span><br><span class="line">                host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);</span><br><span class="line">            &#125;</span><br><span class="line">            if (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">                endDragResizing();</span><br><span class="line">                destroyHardwareResources();</span><br><span class="line">            &#125;</span><br><span class="line">            if (viewVisibility == View.GONE) &#123;</span><br><span class="line">                // After making a window gone, we will count it as being</span><br><span class="line">                // shown for the first time the next time it gets focus.</span><br><span class="line">                mHasHadWindowFocus = false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Non-visible windows can&apos;t hold accessibility focus.</span><br><span class="line">        if (mAttachInfo.mWindowVisibility != View.VISIBLE) &#123;</span><br><span class="line">            host.clearAccessibilityFocus();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Execute enqueued actions on every traversal in case a detached view enqueued an action</span><br><span class="line">        getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">        boolean insetsChanged = false;</span><br><span class="line"></span><br><span class="line">        boolean layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        if (layoutRequested) &#123;</span><br><span class="line"></span><br><span class="line">            final Resources res = mView.getContext().getResources();</span><br><span class="line"></span><br><span class="line">            if (mFirst) &#123;</span><br><span class="line">                // make sure touch mode code executes by setting cached value</span><br><span class="line">                // to opposite of the added touch mode.</span><br><span class="line">                mAttachInfo.mInTouchMode = !mAddedTouchMode;</span><br><span class="line">                ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mVisibleInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                if (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                    insetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                        || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                    windowSizeMayChange = true;</span><br><span class="line"></span><br><span class="line">                    if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                        // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">                        Point size = new Point();</span><br><span class="line">                        mDisplay.getRealSize(size);</span><br><span class="line">                        desiredWindowWidth = size.x;</span><br><span class="line">                        desiredWindowHeight = size.y;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        Configuration config = res.getConfiguration();</span><br><span class="line">                        desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                        desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // Ask host how big it wants to be</span><br><span class="line">            windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                    desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (collectViewAttributes()) &#123;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line">        if (mAttachInfo.mForceReportNewAttributes) &#123;</span><br><span class="line">            mAttachInfo.mForceReportNewAttributes = false;</span><br><span class="line">            params = lp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFirst || mAttachInfo.mViewVisibilityChanged) &#123;</span><br><span class="line">            mAttachInfo.mViewVisibilityChanged = false;</span><br><span class="line">            int resizeMode = mSoftInputMode &amp;</span><br><span class="line">                    WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;</span><br><span class="line">            // If we are in auto resize mode, then we need to determine</span><br><span class="line">            // what mode to use now.</span><br><span class="line">            if (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">                final int N = mAttachInfo.mScrollContainers.size();</span><br><span class="line">                for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">                    if (mAttachInfo.mScrollContainers.get(i).isShown()) &#123;</span><br><span class="line">                        resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (resizeMode == 0) &#123;</span><br><span class="line">                    resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;</span><br><span class="line">                &#125;</span><br><span class="line">                if ((lp.softInputMode &amp;</span><br><span class="line">                        WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) &#123;</span><br><span class="line">                    lp.softInputMode = (lp.softInputMode &amp;</span><br><span class="line">                            ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) |</span><br><span class="line">                            resizeMode;</span><br><span class="line">                    params = lp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (params != null) &#123;</span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">                if (!PixelFormat.formatHasAlpha(params.format)) &#123;</span><br><span class="line">                    params.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mAttachInfo.mOverscanRequested = (params.flags</span><br><span class="line">                    &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mApplyInsetsRequested) &#123;</span><br><span class="line">            mApplyInsetsRequested = false;</span><br><span class="line">            mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">            dispatchApplyInsets(host);</span><br><span class="line">            if (mLayoutRequested) &#123;</span><br><span class="line">                // Short-circuit catching a new layout request here, so</span><br><span class="line">                // we don&apos;t need to go through two layout passes when things</span><br><span class="line">                // change due to fitting system windows, which can happen a lot.</span><br><span class="line">                windowSizeMayChange |= measureHierarchy(host, lp,</span><br><span class="line">                        mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (layoutRequested) &#123;</span><br><span class="line">            // Clear this now, so that if anything requests a layout in the</span><br><span class="line">            // rest of this function we will catch it and re-run a full</span><br><span class="line">            // layout pass.</span><br><span class="line">            mLayoutRequested = false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">                &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())</span><br><span class="line">                || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)</span><br><span class="line">                || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));</span><br><span class="line">        windowShouldResize |= mDragResizing &amp;&amp; mResizeMode == RESIZE_MODE_FREEFORM;</span><br><span class="line"></span><br><span class="line">        // If the activity was just relaunched, it might have unfrozen the task bounds (while</span><br><span class="line">        // relaunching), so we need to force a call into window manager to pick up the latest</span><br><span class="line">        // bounds.</span><br><span class="line">        windowShouldResize |= mActivityRelaunched;</span><br><span class="line"></span><br><span class="line">        // Determine whether to compute insets.</span><br><span class="line">        // If there are no inset listeners remaining then we may still need to compute</span><br><span class="line">        // insets in case the old insets were non-empty and must be reset.</span><br><span class="line">        final boolean computesInternalInsets =</span><br><span class="line">                mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners()</span><br><span class="line">                        || mAttachInfo.mHasNonEmptyGivenInternalInsets;</span><br><span class="line"></span><br><span class="line">        boolean insetsPending = false;</span><br><span class="line">        int relayoutResult = 0;</span><br><span class="line">        boolean updatedConfiguration = false;</span><br><span class="line"></span><br><span class="line">        final int surfaceGenerationId = mSurface.getGenerationId();</span><br><span class="line"></span><br><span class="line">        final boolean isViewVisible = viewVisibility == View.VISIBLE;</span><br><span class="line">        final boolean windowRelayoutWasForced = mForceNextWindowRelayout;</span><br><span class="line">        if (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">                viewVisibilityChanged || params != null || mForceNextWindowRelayout) &#123;</span><br><span class="line">            mForceNextWindowRelayout = false;</span><br><span class="line"></span><br><span class="line">            if (isViewVisible) &#123;</span><br><span class="line">                // If this window is giving internal insets to the window</span><br><span class="line">                // manager, and it is being added or changing its visibility,</span><br><span class="line">                // then we want to first give the window manager &quot;fake&quot;</span><br><span class="line">                // insets to cause it to effectively ignore the content of</span><br><span class="line">                // the window during layout.  This avoids it briefly causing</span><br><span class="line">                // other windows to resize/move based on the raw frame of the</span><br><span class="line">                // window, waiting until we can finish laying out this window</span><br><span class="line">                // and get back to the window manager with the ultimately</span><br><span class="line">                // computed insets.</span><br><span class="line">                insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mSurfaceHolder != null) &#123;</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                mDrawingAllowed = true;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            boolean hwInitialized = false;</span><br><span class="line">            boolean contentInsetsChanged = false;</span><br><span class="line">            boolean hadSurface = mSurface.isValid();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                if (DEBUG_LAYOUT) &#123;</span><br><span class="line">                    Log.i(mTag, &quot;host=w:&quot; + host.getMeasuredWidth() + &quot;, h:&quot; +</span><br><span class="line">                            host.getMeasuredHeight() + &quot;, params=&quot; + params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                    // relayoutWindow may decide to destroy mSurface. As that decision</span><br><span class="line">                    // happens in WindowManager service, we need to be defensive here</span><br><span class="line">                    // and stop using the surface in case it gets destroyed.</span><br><span class="line">                    if (mAttachInfo.mThreadedRenderer.pauseSurface(mSurface)) &#123;</span><br><span class="line">                        // Animations were running so we need to push a frame</span><br><span class="line">                        // to resume them</span><br><span class="line">                        mDirty.set(0, 0, mWidth, mHeight);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</span><br><span class="line">                &#125;</span><br><span class="line">                relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line"></span><br><span class="line">                if (DEBUG_LAYOUT) Log.v(mTag, &quot;relayout: frame=&quot; + frame.toShortString()</span><br><span class="line">                        + &quot; overscan=&quot; + mPendingOverscanInsets.toShortString()</span><br><span class="line">                        + &quot; content=&quot; + mPendingContentInsets.toShortString()</span><br><span class="line">                        + &quot; visible=&quot; + mPendingVisibleInsets.toShortString()</span><br><span class="line">                        + &quot; visible=&quot; + mPendingStableInsets.toShortString()</span><br><span class="line">                        + &quot; outsets=&quot; + mPendingOutsets.toShortString()</span><br><span class="line">                        + &quot; surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">                final Configuration pendingMergedConfig =</span><br><span class="line">                        mPendingMergedConfiguration.getMergedConfiguration();</span><br><span class="line">                if (pendingMergedConfig.seq != 0) &#123;</span><br><span class="line">                    if (DEBUG_CONFIGURATION) Log.v(mTag, &quot;Visible with new config: &quot;</span><br><span class="line">                            + pendingMergedConfig);</span><br><span class="line">                    performConfigurationChange(mPendingMergedConfiguration, !mFirst,</span><br><span class="line">                            INVALID_DISPLAY /* same display */);</span><br><span class="line">                    pendingMergedConfig.seq = 0;</span><br><span class="line">                    updatedConfiguration = true;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final boolean overscanInsetsChanged = !mPendingOverscanInsets.equals(</span><br><span class="line">                        mAttachInfo.mOverscanInsets);</span><br><span class="line">                contentInsetsChanged = !mPendingContentInsets.equals(</span><br><span class="line">                        mAttachInfo.mContentInsets);</span><br><span class="line">                final boolean visibleInsetsChanged = !mPendingVisibleInsets.equals(</span><br><span class="line">                        mAttachInfo.mVisibleInsets);</span><br><span class="line">                final boolean stableInsetsChanged = !mPendingStableInsets.equals(</span><br><span class="line">                        mAttachInfo.mStableInsets);</span><br><span class="line">                final boolean outsetsChanged = !mPendingOutsets.equals(mAttachInfo.mOutsets);</span><br><span class="line">                final boolean surfaceSizeChanged = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != 0;</span><br><span class="line">                final boolean alwaysConsumeNavBarChanged =</span><br><span class="line">                        mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">                if (contentInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Content insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mContentInsets);</span><br><span class="line">                &#125;</span><br><span class="line">                if (overscanInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Overscan insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mOverscanInsets);</span><br><span class="line">                    // Need to relayout with content insets.</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (stableInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mStableInsets.set(mPendingStableInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Decor insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mStableInsets);</span><br><span class="line">                    // Need to relayout with content insets.</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (alwaysConsumeNavBarChanged) &#123;</span><br><span class="line">                    mAttachInfo.mAlwaysConsumeNavBar = mPendingAlwaysConsumeNavBar;</span><br><span class="line">                    contentInsetsChanged = true;</span><br><span class="line">                &#125;</span><br><span class="line">                if (contentInsetsChanged || mLastSystemUiVisibility !=</span><br><span class="line">                        mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested</span><br><span class="line">                        || mLastOverscanRequested != mAttachInfo.mOverscanRequested</span><br><span class="line">                        || outsetsChanged) &#123;</span><br><span class="line">                    mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">                    mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">                    mAttachInfo.mOutsets.set(mPendingOutsets);</span><br><span class="line">                    mApplyInsetsRequested = false;</span><br><span class="line">                    dispatchApplyInsets(host);</span><br><span class="line">                &#125;</span><br><span class="line">                if (visibleInsetsChanged) &#123;</span><br><span class="line">                    mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Visible insets changing to: &quot;</span><br><span class="line">                            + mAttachInfo.mVisibleInsets);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!hadSurface) &#123;</span><br><span class="line">                    if (mSurface.isValid()) &#123;</span><br><span class="line">                        // If we are creating a new surface, then we need to</span><br><span class="line">                        // completely redraw it.  Also, when we get to the</span><br><span class="line">                        // point of drawing it we will hold off and schedule</span><br><span class="line">                        // a new traversal instead.  This is so we can tell the</span><br><span class="line">                        // window manager about all of the windows being displayed</span><br><span class="line">                        // before actually drawing them, so it can display then</span><br><span class="line">                        // all at once.</span><br><span class="line">                        newSurface = true;</span><br><span class="line">                        mFullRedrawNeeded = true;</span><br><span class="line">                        mPreviousTransparentRegion.setEmpty();</span><br><span class="line"></span><br><span class="line">                        // Only initialize up-front if transparent regions are not</span><br><span class="line">                        // requested, otherwise defer to see if the entire window</span><br><span class="line">                        // will be transparent</span><br><span class="line">                        if (mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                hwInitialized = mAttachInfo.mThreadedRenderer.initialize(</span><br><span class="line">                                        mSurface);</span><br><span class="line">                                if (hwInitialized &amp;&amp; (host.mPrivateFlags</span><br><span class="line">                                        &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == 0) &#123;</span><br><span class="line">                                    // Don&apos;t pre-allocate if transparent regions</span><br><span class="line">                                    // are requested as they may not be needed</span><br><span class="line">                                    mSurface.allocateBuffers();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                                handleOutOfResourcesException(e);</span><br><span class="line">                                return;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (!mSurface.isValid()) &#123;</span><br><span class="line">                    // If the surface has been removed, then reset the scroll</span><br><span class="line">                    // positions.</span><br><span class="line">                    if (mLastScrolledFocus != null) &#123;</span><br><span class="line">                        mLastScrolledFocus.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                    mScrollY = mCurScrollY = 0;</span><br><span class="line">                    if (mView instanceof RootViewSurfaceTaker) &#123;</span><br><span class="line">                        ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (mScroller != null) &#123;</span><br><span class="line">                        mScroller.abortAnimation();</span><br><span class="line">                    &#125;</span><br><span class="line">                    // Our surface is gone</span><br><span class="line">                    if (mAttachInfo.mThreadedRenderer != null &amp;&amp;</span><br><span class="line">                            mAttachInfo.mThreadedRenderer.isEnabled()) &#123;</span><br><span class="line">                        mAttachInfo.mThreadedRenderer.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if ((surfaceGenerationId != mSurface.getGenerationId()</span><br><span class="line">                        || surfaceSizeChanged || windowRelayoutWasForced)</span><br><span class="line">                        &amp;&amp; mSurfaceHolder == null</span><br><span class="line">                        &amp;&amp; mAttachInfo.mThreadedRenderer != null) &#123;</span><br><span class="line">                    mFullRedrawNeeded = true;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        // Need to do updateSurface (which leads to CanvasContext::setSurface and</span><br><span class="line">                        // re-create the EGLSurface) if either the Surface changed (as indicated by</span><br><span class="line">                        // generation id), or WindowManager changed the surface size. The latter is</span><br><span class="line">                        // because on some chips, changing the consumer side&apos;s BufferQueue size may</span><br><span class="line">                        // not take effect immediately unless we create a new EGLSurface.</span><br><span class="line">                        // Note that frame size change doesn&apos;t always imply surface size change (eg.</span><br><span class="line">                        // drag resizing uses fullscreen surface), need to check surfaceSizeChanged</span><br><span class="line">                        // flag from WindowManager.</span><br><span class="line">                        mAttachInfo.mThreadedRenderer.updateSurface(mSurface);</span><br><span class="line">                    &#125; catch (OutOfResourcesException e) &#123;</span><br><span class="line">                        handleOutOfResourcesException(e);</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                final boolean freeformResizing = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != 0;</span><br><span class="line">                final boolean dockedResizing = (relayoutResult</span><br><span class="line">                        &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != 0;</span><br><span class="line">                final boolean dragResizing = freeformResizing || dockedResizing;</span><br><span class="line">                if (mDragResizing != dragResizing) &#123;</span><br><span class="line">                    if (dragResizing) &#123;</span><br><span class="line">                        mResizeMode = freeformResizing</span><br><span class="line">                                ? RESIZE_MODE_FREEFORM</span><br><span class="line">                                : RESIZE_MODE_DOCKED_DIVIDER;</span><br><span class="line">                        startDragResizing(mPendingBackDropFrame,</span><br><span class="line">                                mWinFrame.equals(mPendingBackDropFrame), mPendingVisibleInsets,</span><br><span class="line">                                mPendingStableInsets, mResizeMode);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        // We shouldn&apos;t come here, but if we come we should end the resize.</span><br><span class="line">                        endDragResizing();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (!USE_MT_RENDERER) &#123;</span><br><span class="line">                    if (dragResizing) &#123;</span><br><span class="line">                        mCanvasOffsetX = mWinFrame.left;</span><br><span class="line">                        mCanvasOffsetY = mWinFrame.top;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        mCanvasOffsetX = mCanvasOffsetY = 0;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DEBUG_ORIENTATION) Log.v(</span><br><span class="line">                    TAG, &quot;Relayout returned: frame=&quot; + frame + &quot;, surface=&quot; + mSurface);</span><br><span class="line"></span><br><span class="line">            mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">            mAttachInfo.mWindowTop = frame.top;</span><br><span class="line"></span><br><span class="line">            // !!FIXME!! This next section handles the case where we did not get the</span><br><span class="line">            // window size we asked for. We should avoid this by getting a maximum size from</span><br><span class="line">            // the window session beforehand.</span><br><span class="line">            if (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">                mWidth = frame.width();</span><br><span class="line">                mHeight = frame.height();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (mSurfaceHolder != null) &#123;</span><br><span class="line">                // The app owns the surface; tell it about what is going on.</span><br><span class="line">                if (mSurface.isValid()) &#123;</span><br><span class="line">                    // XXX .copyFrom() doesn&apos;t work!</span><br><span class="line">                    //mSurfaceHolder.mSurface.copyFrom(mSurface);</span><br><span class="line">                    mSurfaceHolder.mSurface = mSurface;</span><br><span class="line">                &#125;</span><br><span class="line">                mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight);</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                if (mSurface.isValid()) &#123;</span><br><span class="line">                    if (!hadSurface) &#123;</span><br><span class="line">                        mSurfaceHolder.ungetCallbacks();</span><br><span class="line"></span><br><span class="line">                        mIsCreating = true;</span><br><span class="line">                        SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                        if (callbacks != null) &#123;</span><br><span class="line">                            for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                                c.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        surfaceChanged = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) &#123;</span><br><span class="line">                        SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                        if (callbacks != null) &#123;</span><br><span class="line">                            for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                                c.surfaceChanged(mSurfaceHolder, lp.format,</span><br><span class="line">                                        mWidth, mHeight);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mIsCreating = false;</span><br><span class="line">                &#125; else if (hadSurface) &#123;</span><br><span class="line">                    mSurfaceHolder.ungetCallbacks();</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                    if (callbacks != null) &#123;</span><br><span class="line">                        for (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceDestroyed(mSurfaceHolder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mSurfaceHolder.mSurface = new Surface();</span><br><span class="line">                    &#125; finally &#123;</span><br><span class="line">                        mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            final ThreadedRenderer threadedRenderer = mAttachInfo.mThreadedRenderer;</span><br><span class="line">            if (threadedRenderer != null &amp;&amp; threadedRenderer.isEnabled()) &#123;</span><br><span class="line">                if (hwInitialized</span><br><span class="line">                        || mWidth != threadedRenderer.getWidth()</span><br><span class="line">                        || mHeight != threadedRenderer.getHeight()</span><br><span class="line">                        || mNeedsRendererSetup) &#123;</span><br><span class="line">                    threadedRenderer.setup(mWidth, mHeight, mAttachInfo,</span><br><span class="line">                            mWindowAttributes.surfaceInsets);</span><br><span class="line">                    mNeedsRendererSetup = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">                boolean focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                        (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0);</span><br><span class="line">                if (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                        || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                        updatedConfiguration) &#123;</span><br><span class="line">                    // TODO: 2018/5/25 //获得view宽高的测量规格，</span><br><span class="line">                    // TODO: 2018/5/25 mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高</span><br><span class="line">                    int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                    int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                    if (DEBUG_LAYOUT) Log.v(mTag, &quot;Ooops, something changed!  mWidth=&quot;</span><br><span class="line">                            + mWidth + &quot; measuredWidth=&quot; + host.getMeasuredWidth()</span><br><span class="line">                            + &quot; mHeight=&quot; + mHeight</span><br><span class="line">                            + &quot; measuredHeight=&quot; + host.getMeasuredHeight()</span><br><span class="line">                            + &quot; coveredInsetsChanged=&quot; + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                    // Ask host how big it wants to be</span><br><span class="line">                    // TODO: 2018/5/25  这里是第一步的  执行测量的操作</span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                    // Implementation of weights from WindowManager.LayoutParams</span><br><span class="line">                    // We just grow the dimensions as needed and re-measure if</span><br><span class="line">                    // needs be</span><br><span class="line">                    int width = host.getMeasuredWidth();</span><br><span class="line">                    int height = host.getMeasuredHeight();</span><br><span class="line">                    boolean measureAgain = false;</span><br><span class="line">                    /**</span><br><span class="line">*指示额外空间的多少将被水平分配。</span><br><span class="line">*与这些LayOutPARAMs关联的视图。如果视图指定0</span><br><span class="line">*不应被拉伸。否则额外像素将被优先评估。</span><br><span class="line">*在所有重量大于0的视图中。</span><br><span class="line">*/                   // TODO: 2018/5/31  这里</span><br><span class="line">                    // WindowManager.LayoutParams=lp;</span><br><span class="line">                    if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                        childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                        height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                        childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                MeasureSpec.EXACTLY);</span><br><span class="line">                        measureAgain = true;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // TODO: 2018/5/31  我知道这里为啥执行两次</span><br><span class="line">                    if (measureAgain) &#123;</span><br><span class="line">                        if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                                &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                                        + &quot; height=&quot; + height);</span><br><span class="line">                        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    layoutRequested = true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Not the first pass and no window/insets/visibility change but the window</span><br><span class="line">            // may have moved and we need check that and if so to update the left and right</span><br><span class="line">            // in the attach info. We translate only the window frame since on window move</span><br><span class="line">            // the window manager tells us only for the new frame but the insets are the</span><br><span class="line">            // same and we do not want to translate them more than once.</span><br><span class="line">            maybeHandleWindowMove(frame);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            // TODO: 2018/5/25  执行布局操作</span><br><span class="line">            performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">            // By this point all views have been sized and positioned</span><br><span class="line">            // We can compute the transparent area</span><br><span class="line"></span><br><span class="line">            if ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != 0) &#123;</span><br><span class="line">                // start out transparent</span><br><span class="line">                // TODO: AVOID THAT CALL BY CACHING THE RESULT?</span><br><span class="line">                host.getLocationInWindow(mTmpLocation);</span><br><span class="line">                mTransparentRegion.set(mTmpLocation[0], mTmpLocation[1],</span><br><span class="line">                        mTmpLocation[0] + host.mRight - host.mLeft,</span><br><span class="line">                        mTmpLocation[1] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">                host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                    mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                    mFullRedrawNeeded = true;</span><br><span class="line">                    // reconfigure window manager</span><br><span class="line">                    try &#123;</span><br><span class="line">                        mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (DBG) &#123;</span><br><span class="line">                System.out.println(&quot;======================================&quot;);</span><br><span class="line">                System.out.println(&quot;performTraversals -- after setFrame&quot;);</span><br><span class="line">                host.debug();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (triggerGlobalLayoutListener) &#123;</span><br><span class="line">            mAttachInfo.mRecomputeGlobalAttributes = false;</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (computesInternalInsets) &#123;</span><br><span class="line">            // Clear the original insets.</span><br><span class="line">            final ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets;</span><br><span class="line">            insets.reset();</span><br><span class="line"></span><br><span class="line">            // Compute new insets in place.</span><br><span class="line">            mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">            mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty();</span><br><span class="line"></span><br><span class="line">            // Tell the window manager.</span><br><span class="line">            if (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">                mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">                // Translate insets to screen coordinates if needed.</span><br><span class="line">                final Rect contentInsets;</span><br><span class="line">                final Rect visibleInsets;</span><br><span class="line">                final Region touchableRegion;</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                    visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                    touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    contentInsets = insets.contentInsets;</span><br><span class="line">                    visibleInsets = insets.visibleInsets;</span><br><span class="line">                    touchableRegion = insets.touchableRegion;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                            contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">                &#125; catch (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (mFirst &amp;&amp; sAlwaysAssignFocus) &#123;</span><br><span class="line">            // handle first focus request</span><br><span class="line">            if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: mView.hasFocus()=&quot;</span><br><span class="line">                    + mView.hasFocus());</span><br><span class="line">            if (mView != null) &#123;</span><br><span class="line">                if (!mView.hasFocus()) &#123;</span><br><span class="line">                    mView.restoreDefaultFocus();</span><br><span class="line">                    if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: requested focused view=&quot;</span><br><span class="line">                            + mView.findFocus());</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    if (DEBUG_INPUT_RESIZE) Log.v(mTag, &quot;First: existing focused view=&quot;</span><br><span class="line">                            + mView.findFocus());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final boolean changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">        final boolean regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">        if (regainedFocus) &#123;</span><br><span class="line">            mLostWindowFocus = false;</span><br><span class="line">        &#125; else if (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">            mLostWindowFocus = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (changedVisibility || regainedFocus) &#123;</span><br><span class="line">            // Toasts are presented as notifications - don&apos;t present them as windows as well</span><br><span class="line">            boolean isToast = (mWindowAttributes == null) ? false</span><br><span class="line">                    : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">            if (!isToast) &#123;</span><br><span class="line">                host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mFirst = false;</span><br><span class="line">        mWillDrawSoon = false;</span><br><span class="line">        mNewSurfaceNeeded = false;</span><br><span class="line">        mActivityRelaunched = false;</span><br><span class="line">        mViewVisibility = viewVisibility;</span><br><span class="line">        mHadWindowFocus = hasWindowFocus;</span><br><span class="line"></span><br><span class="line">        if (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">            final boolean imTarget = WindowManager.LayoutParams</span><br><span class="line">                    .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">            if (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">                mLastWasImTarget = imTarget;</span><br><span class="line">                InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">                if (imm != null &amp;&amp; imTarget) &#123;</span><br><span class="line">                    imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                    imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                            mWindowAttributes.softInputMode,</span><br><span class="line">                            !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // Remember if we must report the next draw.</span><br><span class="line">        if ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != 0) &#123;</span><br><span class="line">            reportNextDraw();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        boolean cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">        if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">            if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            // TODO: 2018/5/25 执行绘制的操作</span><br><span class="line">            performDraw();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isViewVisible) &#123;</span><br><span class="line">                // Try again</span><br><span class="line">                scheduleTraversals();</span><br><span class="line">            &#125; else if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">                for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                    mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">                &#125;</span><br><span class="line">                mPendingTransitions.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mIsInTraversal = false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1、如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 如果窗口的类型是有状态栏的，那么顶层视图DecorView所需要的窗口的宽度和高度</span><br><span class="line">           //就是除了状态栏</span><br><span class="line">           if (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">               // NOTE -- system code, won&apos;t try to do compat mode.</span><br><span class="line">               Point size = new Point();</span><br><span class="line">               mDisplay.getRealSize(size);</span><br><span class="line">               desiredWindowWidth = size.x;</span><br><span class="line">               desiredWindowHeight = size.y;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //否者顶层视图DecorView所需要的窗口的宽度和高度就是整个屏幕的宽度</span><br><span class="line">               desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">               desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2、/获得view宽高的测量规格</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// TODO: 2018/5/25 //获得view宽高的测量规格，</span><br><span class="line"> // TODO: 2018/5/25 mWidth和mHeight表示窗口的宽高，lp.widthhe和lp.height表示DecorView根布局宽和高</span><br><span class="line"> int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line"> int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br></pre></td></tr></table></figure>
</li>
<li><p>3、注意这个对象<code>WindowManager.LayoutParams lp</code> ,如果说<code>lp.horizontalWeight &gt; 0.0f</code>或者是<code>lp.verticalWeight &gt; 0.0f</code>,那么measureAgain =true；<code>horizontalWeight</code>这个标记大概是这个意思指示额外空间的多少将被水平分配。如果视图指定0不应被拉伸。否则额外像素将被优先评估。在所有重量大于0的视图中。一般都指示出还有多少的水平的空间将要被分配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">      * 这个WindowMananger 这里标记了 是</span><br><span class="line">      */</span><br><span class="line">     // TODO: 2018/6/4</span><br><span class="line">     WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line">           // TODO: 2018/5/25  这里是第一步的  执行测量的操作</span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">       if (lp.horizontalWeight &gt; 0.0f) &#123;</span><br><span class="line">                     width += (int) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                     childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                             MeasureSpec.EXACTLY);</span><br><span class="line">                     measureAgain = true;</span><br><span class="line">                 &#125;</span><br><span class="line">                 if (lp.verticalWeight &gt; 0.0f) &#123;</span><br><span class="line">                     height += (int) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                     childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                             MeasureSpec.EXACTLY);</span><br><span class="line">                     measureAgain = true;</span><br><span class="line">                 &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果这个measureAgain=true的话，就会再次调用<code>performMeasure()</code>,通过代码可以发现这就调用了两次<code>performMeasure</code>;</p>
<h4 id="其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。"><a href="#其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。" class="headerlink" title="其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。"></a>其实我这里犯了一个错误，不是这样的子，这个标记不一定是为<code>true</code>。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (measureAgain) &#123;</span><br><span class="line">                       if (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                               &quot;And hey let&apos;s measure once more: width=&quot; + width</span><br><span class="line">                                       + &quot; height=&quot; + height);</span><br><span class="line">                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4、关于<code>performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</code>方法,其实就是调用的是<code>mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</code>,也就是View第一步是测量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123;</span><br><span class="line">     if (mView == null) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);</span><br><span class="line">     try &#123;</span><br><span class="line">         mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>5、第一次绘制的时候，这个标记一定是<code>didLayout</code>一定是true，一定会走到这个方法里面去<code>performLayout(lp, mWidth, mHeight);</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">     final boolean didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">        boolean triggerGlobalLayoutListener = didLayout</span><br><span class="line">                || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">        if (didLayout) &#123;</span><br><span class="line">            // TODO: 2018/5/25  执行布局操作</span><br><span class="line">            performLayout(lp, mWidth, mHeight);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关于<code>performLayout</code>这个方法，直接会调用<code>host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</code>,也就是View的layout的方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth,</span><br><span class="line">                               int desiredWindowHeight) &#123;</span><br><span class="line">final View host = mView;</span><br><span class="line">  try &#123;</span><br><span class="line">            host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line">           //测试层级</span><br><span class="line">                    measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                            desiredWindowWidth, desiredWindowHeight);</span><br><span class="line"> &#125; finally &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>6、这两个标记也是<code>!cancelDraw &amp;&amp; !newSurface</code>为<code>true</code>,那么就会走到<code>performDraw();</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">         if (mPendingTransitions != null &amp;&amp; mPendingTransitions.size() &gt; 0) &#123;</span><br><span class="line">             for (int i = 0; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                 mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">             &#125;</span><br><span class="line">             mPendingTransitions.clear();</span><br><span class="line">         &#125;</span><br><span class="line">         // TODO: 2018/5/25 执行绘制的操作</span><br><span class="line">         performDraw();</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>关于<code>performDraw();</code>方法,直接调用的是<code>draw(fullRedrawNeeded);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    private void performDraw() &#123;</span><br><span class="line">        mIsDrawing = true;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;draw&quot;);</span><br><span class="line">        try &#123;</span><br><span class="line">            draw(fullRedrawNeeded);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            mIsDrawing = false;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于<code>draw(fullRedrawNeeded);</code>,会调用到这里来<code>drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void draw(boolean fullRedrawNeeded) &#123;</span><br><span class="line">      if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                  return;</span><br><span class="line">              &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关于这个方法<code>drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)</code>。官方的解释为如果绘图成功，如果发生错误，则为false。返回false的，程序就发生了异常，也就是程序GG掉了，绘制失败，这里仅仅贴出关键的代码~~~，这样字，就调用到了<code>mView.draw(canvas);</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff,</span><br><span class="line">                                 boolean scalingRequired, Rect dirty) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">                canvas.translate(-xoff, -yoff);</span><br><span class="line">                if (mTranslator != null) &#123;</span><br><span class="line">                    mTranslator.translateCanvas(canvas);</span><br><span class="line">                &#125;</span><br><span class="line">                canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : 0);</span><br><span class="line">                attachInfo.mSetIgnoreDirtyState = false;</span><br><span class="line">                // TODO: 2018/5/25   调用了View里面的draw方法</span><br><span class="line">                mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">                drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                if (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                    // Only clear the flag if it was not set during the mView.draw() call</span><br><span class="line">                    attachInfo.mIgnoreDirtyState = false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后做了两张图<br><img src="https://upload-images.jianshu.io/upload_images/5363507-9f68fbf91f7c7eac.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的绘制流程（一）.jpg"></p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/5363507-07125ab1e5530813.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="View的绘制流程（二）ViewRootImpl.performTraversals.jpg"></p>
<ul>
<li>说明几点<ul>
<li>如果感兴趣的，一定要去打个断点看一下这个流程</li>
<li>限于作者水平有限，一定会存在有些错误，还望指出，谢谢</li>
</ul>
</li>
</ul>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2018/06/08/Android源码分析-View的绘制流程/">Android源码分析:View的绘制流程</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Shiming_Li</a></p>
        <p><span>发布时间:</span>2018-06-08, 16:08:28</p>
        <p><span>最后更新:</span>2018-08-14, 16:47:16</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2018/06/08/Android源码分析-View的绘制流程/" title="Android源码分析:View的绘制流程">http://yoursite.com/2018/06/08/Android源码分析-View的绘制流程/</a>
            <span class="copy-path" data-clipboard-text="原文: http://yoursite.com/2018/06/08/Android源码分析-View的绘制流程/　　作者: Shiming_Li" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2018/06/14/Web的工作方式/">
                    Web的工作方式
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/2018/06/07/Android源码分析LayoutInflater/">
                    Android源码分析LayoutInflater
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#源码基于安卓8-0分析结果"><span class="toc-number">1.</span> <span class="toc-text">源码基于安卓8.0分析结果</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析"><span class="toc-number">2.</span> <span class="toc-text">performTraversals这里就是整个View绘制的开始，所有的绘制，都会从这里开始，虽然这个方法代码有点多，但是关键的地方我都做了注释，下面一步一步的分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。"><span class="toc-number">2.0.1.</span> <span class="toc-text">其实我这里犯了一个错误，不是这样的子，这个标记不一定是为true。</span></a></li></ol></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"Android源码分析:View的绘制流程　| 仕明的后花园　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2018/06/14/Web的工作方式/" title="上一篇: Web的工作方式">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/2018/06/07/Android源码分析LayoutInflater/" title="下一篇: Android源码分析LayoutInflater">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Hexo-GitHub-阿里域名搭建自己博客/">Hexo+GitHub+阿里域名搭建自己博客</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/14/Android-9-Pie-正式版总结/">Android 9 Pie 正式版总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/07/安卓invalidate、postInvalidate、requestLayout源码分析/">安卓invalidate、postInvalidate、requestLayout源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/19/Go语言实现RPC/">Go语言实现RPC</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/15/Go语言实现的WebSocket/">Go语言实现的WebSocket</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/06/Go语言使用MySQL数据库/">Go语言使用MySQL数据库</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/14/Web的工作方式/">Web的工作方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/08/Android源码分析-View的绘制流程/">Android源码分析:View的绘制流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析LayoutInflater/">Android源码分析LayoutInflater</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/06/07/Android源码分析ViewStub源码解析/">Android源码分析ViewStub源码解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/29/Android源码分析（Activity-setContentView源码析/">Android源码分析（Activity.setContentView源码解析）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/26/Android源码分析（Handler机制）/">Android源码分析（Handler机制）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/14/Android源码分析（事件传递）/">Android源码分析（事件传递）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/06/安卓代码、图片、布局、网络和电量优化/">安卓代码、图片、布局、网络和电量优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/05/05/Lint的使用（安卓性能提升必备掌握的工具）/">Lint的使用（安卓性能提升必备掌握的工具）</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/27/Java/">注解（Annotation） by Thinking in Java</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/22/基于Glide4-7-1二次封装/">基于Glide4.7.1二次封装</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/14/Kotlin中的协变、逆变和不变/">Kotlin中的协变、逆变和不变</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/26/PLC通讯的安卓App/">PLC通讯的安卓App</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/24/安卓画笔笔锋的实现探索（三）田字格Demo/">安卓画笔笔锋的实现探索（三）田字格Demo</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/25/2018/">2018年</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/10/18/安卓画笔笔锋的实现探索（二）/">安卓画笔笔锋的实现探索（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/26/自己实现Jni，生成so库，实现高效率的高斯模糊效果/">自己实现Jni，生成so库，实现高效率的高斯模糊效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/23/自定义卡片效果的ViewGroup/">自定义卡片效果的ViewGroup</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/26/安卓画笔笔锋的实现探索（一）/">安卓画笔笔锋的实现探索（一）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/14/Fragment-setNextAnim/">Fragment.setNextAnim(int) on a null object reference</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/08/MVP网络框架Retorfit-Rxjava-Rxandroid/">MVP网络框架Retorfit+Rxjava+Rxandroid</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/30/Glide图片处理框架（模糊图，倒圆角，圆形图片）/">Glide图片处理框架（模糊图，倒圆角，圆形图片）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/自定义PopupWindow的超强使用/">自定义PopupWindow的超强使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/02/Activity的转场动画效果/">Activity的转场动画效果</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/04/17/如何用AndroidStudio查看和解决OOM/">如何用AndroidStudio查看和解决OOM</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2018 Shiming_Li
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>